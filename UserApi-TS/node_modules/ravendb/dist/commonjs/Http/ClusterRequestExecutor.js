"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClusterRequestExecutor = void 0;
const GetClusterTopologyCommand_js_1 = require("../ServerWide/Commands/GetClusterTopologyCommand.js");
const NodeSelector_js_1 = require("./NodeSelector.js");
const LogUtil_js_1 = require("../Utility/LogUtil.js");
const RequestExecutor_js_1 = require("./RequestExecutor.js");
const index_js_1 = require("../Exceptions/index.js");
const ServerNode_js_1 = require("./ServerNode.js");
const Topology_js_1 = require("./Topology.js");
const GetTcpInfoCommand_js_1 = require("../ServerWide/Commands/GetTcpInfoCommand.js");
const SemaphoreUtil_js_1 = require("../Utility/SemaphoreUtil.js");
const DocumentConventions_js_1 = require("../Documents/Conventions/DocumentConventions.js");
const Constants_js_1 = require("../Constants.js");
const Semaphore_js_1 = require("../Utility/Semaphore.js");
const OsUtil_js_1 = require("../Utility/OsUtil.js");
const log = (0, LogUtil_js_1.getLogger)({ module: "ClusterRequestExecutor" });
class ClusterRequestExecutor extends RequestExecutor_js_1.RequestExecutor {
    _clusterTopologySemaphore = new Semaphore_js_1.Semaphore();
    constructor(authOptions, conventions) {
        super(null, authOptions, conventions);
    }
    static createForSingleNodeWithConfigurationUpdates(url, databaseName, opts) {
        return (0, index_js_1.throwError)("NotSupportedException");
    }
    static createForSingleNodeWithoutConfigurationUpdates(url, databaseName, opts) {
        return (0, index_js_1.throwError)("NotSupportedException");
    }
    static createForSingleNode(url, opts) {
        const initialUrls = [url];
        const { authOptions, documentConventions } = opts;
        const urls = this.validateUrls(initialUrls, authOptions);
        const executor = new ClusterRequestExecutor(authOptions, documentConventions || DocumentConventions_js_1.DocumentConventions.defaultConventions);
        const serverNode = new ServerNode_js_1.ServerNode({ url: urls[0], serverRole: "Member" });
        const topology = new Topology_js_1.Topology(-1, [serverNode]);
        const nodeSelector = new NodeSelector_js_1.NodeSelector(topology);
        executor._nodeSelector = nodeSelector;
        executor._topologyEtag = -2;
        executor._disableClientConfigurationUpdates = true;
        executor._disableTopologyUpdates = true;
        executor._topologyHeaderName = Constants_js_1.HEADERS.CLUSTER_TOPOLOGY_ETAG;
        executor.firstTopologyUpdatePromise = executor._singleTopologyUpdateAsync(urls, null);
        return executor;
    }
    static create(initialUrls, databaseOrOpts, opts) {
        if (typeof (databaseOrOpts) === "string") {
            return (0, index_js_1.throwError)("NotSupportedException");
        }
        const { authOptions, documentConventions } = (opts || databaseOrOpts) || {};
        const executor = new ClusterRequestExecutor(authOptions, documentConventions ?? DocumentConventions_js_1.DocumentConventions.defaultConventions);
        executor._disableClientConfigurationUpdates = true;
        executor.firstTopologyUpdatePromise = executor._firstTopologyUpdate(initialUrls, null);
        executor._topologyHeaderName = Constants_js_1.HEADERS.CLUSTER_TOPOLOGY_ETAG;
        return executor;
    }
    _performHealthCheck(serverNode, nodeIndex) {
        return this.execute(new GetTcpInfoCommand_js_1.GetTcpInfoCommand("health-check"), null, {
            chosenNode: serverNode,
            nodeIndex,
            shouldRetry: false
        });
    }
    async updateTopology(parameters) {
        if (this._disposed) {
            return false;
        }
        if (this._disableTopologyUpdates) {
            return false;
        }
        const acquiredSemContext = (0, SemaphoreUtil_js_1.acquireSemaphore)(this._clusterTopologySemaphore, { timeout: parameters.timeoutInMs });
        try {
            await acquiredSemContext.promise;
            if (this._disposed) {
                return false;
            }
            const command = new GetClusterTopologyCommand_js_1.GetClusterTopologyCommand(parameters.debugTag);
            await this.execute(command, null, {
                chosenNode: parameters.node,
                nodeIndex: null,
                shouldRetry: false
            });
            const results = command.result;
            const newTopology = ServerNode_js_1.ServerNode.createFrom(results.topology, results.etag);
            this._updateNodeSelector(newTopology, parameters.forceUpdate);
            this._onTopologyUpdatedInvoke(newTopology, parameters.debugTag);
            return true;
        }
        catch (reason) {
            if (reason.name === "TimeoutError") {
                return false;
            }
            throw reason;
        }
        finally {
            acquiredSemContext.dispose();
        }
    }
    _updateClientConfigurationAsync(serverNode) {
        return Promise.resolve();
    }
    _throwExceptions(details) {
        (0, index_js_1.throwError)("InvalidOperationException", "Failed to retrieve cluster topology from all known nodes" + OsUtil_js_1.EOL + details);
    }
    dispose() {
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        this._clusterTopologySemaphore.take(() => {
            // empty
        });
        super.dispose();
    }
}
exports.ClusterRequestExecutor = ClusterRequestExecutor;
//# sourceMappingURL=ClusterRequestExecutor.js.map