import { ServerNode } from "./ServerNode.js";
import { HttpCache } from "./HttpCache.js";
import { Stream, Readable } from "node:stream";
import { HttpRequestParameters, HttpResponse } from "../Primitives/Http.js";
import { IRavenObject } from "../Types/IRavenObject.js";
import { HeadersBuilder } from "../Utility/HttpUtil.js";
import { TypeInfo } from "../Mapping/ObjectMapper.js";
import { JsonSerializer } from "../Mapping/Json/Serializer.js";
import { RavenCommandResponsePipeline } from "./RavenCommandResponsePipeline.js";
import { DocumentConventions } from "../Documents/Conventions/DocumentConventions.js";
import { ObjectTypeDescriptor } from "../Types/index.js";
import { Dispatcher } from "undici-types";
import { DefaultCommandResponseBehavior } from "./Behaviors/DefaultCommandResponseBehavior.js";
export type RavenCommandResponse = string | Response;
export type RavenCommandResponseType = "Empty" | "Object" | "Raw";
export type ResponseDisposeHandling = "Automatic" | "Manually";
export interface IRavenResponse extends IRavenObject {
}
export declare abstract class RavenCommand<TResult> {
    result: TResult;
    statusCode: number;
    failedNodes: Map<ServerNode, Error>;
    protected _responseType: RavenCommandResponseType;
    timeout: number | undefined;
    protected _canCache: boolean;
    protected _canCacheAggressively: boolean;
    protected _canReadFromCache: boolean;
    protected _selectedNodeTag: string;
    private _selectedShardNumber;
    protected _numberOfAttempts: number;
    failoverTopologyEtag: number;
    protected _etag: string;
    get responseBehavior(): DefaultCommandResponseBehavior;
    abstract get isReadRequest(): boolean;
    get responseType(): RavenCommandResponseType;
    set etag(value: string);
    get canCache(): boolean;
    get canCacheAggressively(): boolean;
    get selectedNodeTag(): string;
    set selectedNodeTag(nodeTag: string);
    get selectedShardNumber(): number;
    set selectedShardNumber(value: number);
    get numberOfAttempts(): number;
    set numberOfAttempts(value: number);
    constructor(copy?: RavenCommand<TResult>);
    abstract createRequest(node: ServerNode): HttpRequestParameters;
    protected get _serializer(): JsonSerializer;
    setResponseFromCache(cachedValue: string): Promise<void>;
    protected _defaultPipeline<T = TResult>(bodyCallback?: (body: string) => void): RavenCommandResponsePipeline<T>;
    setResponseAsync(bodyStream: Stream, fromCache: boolean): Promise<string>;
    send(agent: Dispatcher, requestOptions: HttpRequestParameters): Promise<{
        response: HttpResponse;
        bodyStream: Readable;
    }>;
    private static maybeWrapBody;
    setResponseRaw(response: HttpResponse, body: string): void;
    protected _urlEncode(value: string | number | boolean): string;
    static ensureIsNotNullOrEmpty(value: string, name: string): void;
    isFailedWithNode(node: ServerNode): boolean;
    processResponse(cache: HttpCache, response: HttpResponse, bodyStream: Readable, url: string): Promise<ResponseDisposeHandling>;
    protected _cacheResponse(cache: HttpCache, url: string, response: HttpResponse, responseJson: string): void;
    protected _addChangeVectorIfNotNull(changeVector: string, req: HttpRequestParameters): void;
    protected _reviveResultTypes<TResponse extends object>(raw: object, conventions: DocumentConventions, typeInfo?: TypeInfo, knownTypes?: Map<string, ObjectTypeDescriptor>): TResponse;
    protected _parseResponseDefaultAsync(bodyStream: Stream): Promise<string>;
    protected _headers(): HeadersBuilder;
    protected _throwInvalidResponse(): void;
    protected static _throwInvalidResponse(cause: Error): void;
    onResponseFailure(response: HttpResponse): void;
    protected _pipeline<TPipelineResult>(): RavenCommandResponsePipeline<TPipelineResult>;
}
//# sourceMappingURL=RavenCommand.d.ts.map