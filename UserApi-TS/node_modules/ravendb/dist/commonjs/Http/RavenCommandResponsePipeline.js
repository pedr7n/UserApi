"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RavenCommandResponsePipeline = void 0;
const node_events_1 = require("node:events");
const ObjectKeyCaseTransformStream_js_1 = require("../Mapping/Json/Streams/ObjectKeyCaseTransformStream.js");
const StreamUtil_js_1 = require("../Utility/StreamUtil.js");
const node_stream_1 = require("node:stream");
const CollectResultStream_js_1 = require("../Mapping/Json/Streams/CollectResultStream.js");
const index_js_1 = require("../Exceptions/index.js");
const TypeUtil_js_1 = require("../Utility/TypeUtil.js");
const StringBuilder_js_1 = require("../Utility/StringBuilder.js");
const node_buffer_1 = require("node:buffer");
const Parser_js_1 = require("../ext/stream-json/jsonl/Parser.js");
class RavenCommandResponsePipeline extends node_events_1.EventEmitter {
    _opts;
    _body = new StringBuilder_js_1.StringBuilder();
    constructor() {
        super();
        this._opts = {};
    }
    static create() {
        return new RavenCommandResponsePipeline();
    }
    parseJsonSync() {
        this._opts.jsonSync = true;
        return this;
    }
    /**
     * @param type Type of object to extract from objects stream - use Raw to skip extraction.
     * @param options
     */
    parseJsonlAsync(valueExtractor, options = {}) {
        const transforms = options?.transforms ?? [];
        const extractItemTransform = new node_stream_1.Transform({
            objectMode: true,
            transform(chunk, encoding, callback) {
                const value = valueExtractor(chunk["value"]);
                if (!value) {
                    return callback();
                }
                callback(null, { ...chunk, value });
            }
        });
        transforms.unshift(extractItemTransform);
        this._opts.jsonlAsync = {
            transforms
        };
        return this;
    }
    collectBody(callback) {
        this._opts.collectBody = callback || true;
        return this;
    }
    objectKeysTransform(optsOrTransform) {
        this._opts.streamKeyCaseTransform = !optsOrTransform || typeof optsOrTransform === "function"
            ? { defaultTransform: optsOrTransform }
            : optsOrTransform;
        return this;
    }
    stream(src, dst, callback) {
        const streams = this._buildUp(src);
        if (dst) {
            streams.push(dst);
        }
        return node_stream_1.pipeline(...streams, TypeUtil_js_1.TypeUtil.NOOP);
    }
    _appendBody(s) {
        this._body.append(s.toString());
    }
    _buildUp(src) {
        if (!src) {
            (0, index_js_1.throwError)("MappingError", "Body stream cannot be null.");
        }
        const opts = this._opts;
        const streams = [src];
        if (opts.collectBody) {
            src.on("data", (chunk) => this._appendBody(chunk));
        }
        if (opts.jsonlAsync) {
            streams.push(new Parser_js_1.JsonlParser());
            if (opts.jsonlAsync.transforms) {
                streams.push(...opts.jsonlAsync.transforms);
            }
        }
        else if (opts.jsonSync) {
            const bytesChunks = [];
            const parseJsonSyncTransform = new node_stream_1.Transform({
                readableObjectMode: true,
                transform(chunk, enc, callback) {
                    bytesChunks.push(chunk);
                    callback();
                },
                flush(callback) {
                    let str = null;
                    try {
                        str = node_buffer_1.Buffer.concat(bytesChunks).toString("utf8");
                    }
                    catch (err) {
                        callback((0, index_js_1.getError)("InvalidDataException", `Failed to concat / decode server response`, err));
                        return;
                    }
                    try {
                        callback(null, JSON.parse(str));
                    }
                    catch (err) {
                        callback((0, index_js_1.getError)("InvalidOperationException", `Error parsing response: '${str}'.`, err));
                    }
                }
            });
            streams.push(parseJsonSyncTransform);
        }
        if (opts.streamKeyCaseTransform) {
            const keyCaseOpts = Object.assign({}, opts.streamKeyCaseTransform, { handlePath: false });
            streams.push(new ObjectKeyCaseTransformStream_js_1.ObjectKeyCaseTransformStream(keyCaseOpts));
        }
        return streams;
    }
    async process(src) {
        const streams = this._buildUp(src);
        const opts = this._opts;
        const collectResult = new CollectResultStream_js_1.CollectResultStream();
        streams.push(collectResult);
        const resultPromise = collectResult.promise;
        await (0, StreamUtil_js_1.pipelineAsync)(...streams);
        const result = await resultPromise;
        if (opts.collectBody) {
            const body = this._body.toString();
            this.emit("body", body);
            if (typeof opts.collectBody === "function") {
                opts.collectBody(body);
            }
        }
        return result;
    }
}
exports.RavenCommandResponsePipeline = RavenCommandResponsePipeline;
//# sourceMappingURL=RavenCommandResponsePipeline.js.map