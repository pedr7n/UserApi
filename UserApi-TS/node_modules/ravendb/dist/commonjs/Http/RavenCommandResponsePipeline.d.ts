import { EventEmitter } from "node:events";
import { ObjectKeyCaseTransformStreamOptions } from "../Mapping/Json/Streams/ObjectKeyCaseTransformStream.js";
import { Stream, Transform, Readable, Writable } from "node:stream";
import { ErrorFirstCallback } from "../Types/Callbacks.js";
import { FieldNameConversion } from "../Utility/ObjectUtil.js";
export interface RavenCommandResponsePipelineOptions {
    collectBody?: boolean | ((body: string) => void);
    jsonlAsync?: {
        transforms: Transform[];
    };
    jsonSync?: boolean;
    streamKeyCaseTransform?: ObjectKeyCaseTransformStreamOptions;
}
export declare class RavenCommandResponsePipeline<TStreamResult> extends EventEmitter {
    private readonly _opts;
    private _body;
    private constructor();
    static create<TResult>(): RavenCommandResponsePipeline<TResult>;
    parseJsonSync(): this;
    /**
     * @param type Type of object to extract from objects stream - use Raw to skip extraction.
     * @param options
     */
    parseJsonlAsync(valueExtractor: (obj: any) => any, options?: {
        transforms?: Transform[];
    }): this;
    collectBody(callback?: (body: string) => void): this;
    objectKeysTransform(defaultTransform: FieldNameConversion): this;
    objectKeysTransform(opts: ObjectKeyCaseTransformStreamOptions): this;
    stream(src: Stream): Readable;
    stream(src: Stream, dst: Writable, callback: ErrorFirstCallback<void>): Stream;
    private _appendBody;
    private _buildUp;
    process(src: Stream): Promise<TStreamResult>;
}
//# sourceMappingURL=RavenCommandResponsePipeline.d.ts.map