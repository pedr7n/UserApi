{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../src/Types/index.ts"],"names":[],"mappings":";;;AAsCA,MAAsB,6BAA6B;CAMlD;AAND,sEAMC;AAUD,MAAsB,iCAAiC;IAS5C,MAAM,CAAC,GAAW;QACrB,OAAO,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,CAAC;IACpC,CAAC;IAEO,cAAc,CAAC,GAAW;QAC9B,OAAO,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC,MAAM,EAAE,QAAQ,EAAE,EAAE;YAC/C,iDAAiD;YACjD,OAAO,MAAM,IAAI,GAAG,CAAC,cAAc,CAAC,QAAQ,CAAC,CAAC;QAClD,CAAC,EAAE,IAAI,CAAC,CAAC;IACb,CAAC;CACJ;AAnBD,8EAmBC","sourcesContent":["import { SuggestionResult } from \"../Documents/Queries/Suggestions/SuggestionResult.js\";\r\n\r\nexport interface EntitiesCollectionObject<TEntity> extends IRavenObject<TEntity | null> {\r\n    [id: string]: TEntity | null;\r\n}\r\n\r\nexport interface RevisionsCollectionObject<TEntity> extends IRavenObject<TEntity | null> {\r\n    [changeVector: string]: TEntity | null;\r\n}\r\n\r\nexport interface SuggestionsResponseObject {\r\n    [fieldName: string]: SuggestionResult;\r\n}\r\n\r\nexport interface IRavenObject<T = any> {\r\n    [property: string]: T;\r\n}\r\n\r\nexport interface IRavenArrayResult {\r\n    results: any[];\r\n}\r\n\r\nexport type CompareExchangeResultClass<T> = T extends object ? EntityConstructor<T> : unknown;\r\n\r\nexport interface ClassConstructor<T extends object = object> {\r\n    name: string;\r\n\r\n    new(...args: any[]): T;\r\n}\r\n\r\nexport interface EntityConstructor<T extends object = object> {\r\n    new(...args: any): T;\r\n\r\n    name: string;\r\n}\r\n\r\nexport type ObjectTypeDescriptor<T extends object = object> = EntityConstructor<T> | ObjectLiteralDescriptor<T>;\r\n\r\nexport abstract class EntityObjectLiteralDescriptor<T extends object> implements ObjectLiteralDescriptor {\r\n    public abstract name: string;\r\n\r\n    public abstract isType(obj: object);\r\n\r\n    public abstract construct(dto: object): T;\r\n}\r\n\r\nexport interface ObjectLiteralDescriptor<TResult extends object = object> {\r\n    name: string;\r\n\r\n    isType(obj: object): boolean;\r\n\r\n    construct(dto: object): TResult;\r\n}\r\n\r\nexport abstract class PropsBasedObjectLiteralDescriptor<T extends object>\r\n    implements EntityObjectLiteralDescriptor<T> {\r\n    // if it quacks like a duck...\r\n\r\n    public abstract name: string;\r\n    public abstract properties: string[];\r\n\r\n    public abstract construct(dto: object): T;\r\n\r\n    public isType(obj: object) {\r\n        return this._hasProperties(obj);\r\n    }\r\n\r\n    private _hasProperties(obj: object): boolean {\r\n        return this.properties.reduce((result, property) => {\r\n            // eslint-disable-next-line no-prototype-builtins\r\n            return result && obj.hasOwnProperty(property);\r\n        }, true);\r\n    }\r\n}\r\n\r\nexport type CapitalizeType<T> = { [K in keyof T & string as `${Capitalize<K>}`]: T[K] };\r\n\r\nexport type Field<T> = keyof T & string | string;\r\n\r\nexport type ServerResponse<T> = T extends Date|string ? T : {\r\n    [K in keyof T]: T[K] extends Date\r\n        ? string\r\n        : ServerResponse<T[K]>;\r\n}\r\n\r\nexport type CapitalizeObjectKeys<T> = T extends Array<infer U>\r\n    ? Array<CapitalizeObjectKeys<U>>\r\n    : T extends object\r\n        ? {\r\n            [K in keyof T as Capitalize<string & K>]: CapitalizeObjectKeys<T[K]>\r\n        }\r\n        : T\r\n\r\nexport type ServerCasing<T extends object> = CapitalizeObjectKeys<T>;\r\n"]}