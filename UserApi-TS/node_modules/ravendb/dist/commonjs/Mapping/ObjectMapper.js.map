{"version":3,"file":"ObjectMapper.js","sourceRoot":"","sources":["../../../src/Mapping/ObjectMapper.ts"],"names":[],"mappings":"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","sourcesContent":["import { ObjectTypeDescriptor, ObjectLiteralDescriptor, EntityConstructor } from \"../Types/index.js\";\r\nimport { throwError } from \"../Exceptions/index.js\";\r\nimport { TypeUtil } from \"../Utility/TypeUtil.js\";\r\nimport { getLogger } from \"../Utility/LogUtil.js\";\r\nimport { DocumentConventions } from \"../Documents/Conventions/DocumentConventions.js\";\r\nimport { ObjectUtil } from \"../Utility/ObjectUtil.js\";\r\nimport { CONSTANTS } from \"../Constants.js\";\r\n\r\nconst log = getLogger({ module: \"ObjectMapper\" });\r\n\r\nexport interface TypeInfo {\r\n    typeName?: string;\r\n    nestedTypes?: NestedTypes;\r\n}\r\n\r\nexport interface NestedTypes {\r\n    [propertyPath: string]: string;\r\n}\r\n\r\nexport interface ITypesAwareObjectMapper {\r\n    fromObjectLiteral<TResult extends object>(rawResult: object, typeInfo?: TypeInfo, knownTypes?: Map<string, ObjectTypeDescriptor>): TResult;\r\n\r\n    toObjectLiteral<TFrom extends object>(obj: TFrom,\r\n                                          typeInfoCallback?: (typeInfo: TypeInfo) => void,\r\n                                          knownTypes?: Map<string, ObjectTypeDescriptor>\r\n    ): object;\r\n}\r\n\r\nexport class TypesAwareObjectMapper implements ITypesAwareObjectMapper {\r\n\r\n    private _throwMappingErrors: boolean = false;\r\n    private _conventions: DocumentConventions;\r\n\r\n    public constructor(opts?: TypesAwareJsonObjectMapperOptions) {\r\n        if (opts) {\r\n\r\n            if (!opts.documentConventions) {\r\n                throwError(\"InvalidArgumentException\", \"Document conventions cannot be empty.\");\r\n            }\r\n\r\n            this._conventions = opts.documentConventions;\r\n        }\r\n    }\r\n\r\n    public get throwMappingErrors(): boolean {\r\n        return this._throwMappingErrors;\r\n    }\r\n\r\n    public set throwMappingErrors(value: boolean) {\r\n        this._throwMappingErrors = value;\r\n    }\r\n\r\n    public fromObjectLiteral<TResult extends object>(\r\n        rawResult: object, typeInfo?: TypeInfo, knownTypes?: Map<string, ObjectTypeDescriptor>): TResult {\r\n\r\n        rawResult = ObjectUtil.deepLiteralClone(rawResult);\r\n        const typeName = typeInfo ? typeInfo.typeName : null;\r\n        const nestedTypes = typeInfo ? typeInfo.nestedTypes : null;\r\n        const types = knownTypes || this._conventions.knownEntityTypesByName;\r\n        const ctorOrTypeDescriptor = this._getKnownType(typeName, types);\r\n        const result = this._instantiateObject<TResult>(typeName, rawResult, ctorOrTypeDescriptor);\r\n\r\n        this._applyNestedTypes(result, nestedTypes, types);\r\n\r\n        return result;\r\n    }\r\n\r\n    private _applyNestedTypes<TResult extends object>(\r\n        obj: TResult, nestedTypes?: NestedTypes, knownTypes?: Map<string, ObjectTypeDescriptor>) {\r\n        if (!nestedTypes || Object.keys(nestedTypes).length === 0) {\r\n            return obj;\r\n        }\r\n\r\n        const nestedTypesKeys = Object.keys(nestedTypes);\r\n        nestedTypesKeys.sort();\r\n        for (const propertyPath of nestedTypesKeys) {\r\n            const typeName = nestedTypes[propertyPath];\r\n            const objPathSegments = propertyPath\r\n                .replace(/\\[/g, \"![\")\r\n                .replace(/\\$MAP/g, \"!$MAP\")\r\n                .replace(/\\$SET/g, \"!$SET\")\r\n                .split(/[!.]/g);\r\n            const fieldContext = this._getFieldContext(obj, objPathSegments);\r\n            const fieldContexts = Array.isArray(fieldContext) ? fieldContext : [fieldContext];\r\n            for (const [i, c] of fieldContexts.entries()) {\r\n                this._applyTypeToNestedProperty(typeName, c, knownTypes);\r\n            }\r\n        }\r\n\r\n        return obj;\r\n    }\r\n\r\n    public toObjectLiteral<TFrom extends object>(\r\n        obj: TFrom,\r\n        typeInfoCallback?: (typeInfo: TypeInfo) => void,\r\n        knownTypes?: Map<string, ObjectTypeDescriptor>): object {\r\n\r\n        const types = (knownTypes || this._conventions.knownEntityTypesByName);\r\n\r\n        let nestedTypes: NestedTypes;\r\n        const result = this._makeObjectLiteral(obj, null, (nestedType) => {\r\n            nestedTypes = Object.assign(nestedTypes || {}, nestedType);\r\n        }, Array.from(types.values()));\r\n\r\n        let typeName;\r\n        if (TypeUtil.isClass(obj)) {\r\n            typeName = obj.constructor.name;\r\n        } else {\r\n            const typeDescriptor = TypeUtil.findType(obj, Array.from(types.values()));\r\n            typeName = typeDescriptor ? typeDescriptor.name : null;\r\n        }\r\n\r\n        const typeInfo: TypeInfo = {};\r\n        typeInfo.typeName = typeName || null;\r\n        typeInfo.nestedTypes = nestedTypes || {};\r\n\r\n        if (typeInfoCallback) {\r\n            typeInfoCallback(typeInfo);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    private _getFieldContext(parent: object, objPath: string[])\r\n        : ObjectPropertyContext | ObjectPropertyContext[] {\r\n        \r\n        if (!parent) {\r\n            return null;\r\n        }\r\n        \r\n        // eslint-disable-next-line prefer-const\r\n        let [field, ...fieldsPathTail] = objPath;\r\n\r\n        const isFieldArray = field.endsWith(\"[]\");\r\n        if (isFieldArray) {\r\n            field = field.replace(/\\[\\]$/g, \"\");\r\n        }\r\n\r\n        const isFieldSet = field.endsWith(\"$SET\");\r\n        if (isFieldSet) {\r\n            field = field.replace(/\\$SET$/g, \"\");\r\n        }\r\n\r\n        const isFieldMap = field.endsWith(\"$MAP\");\r\n        if (isFieldMap) {\r\n            field = field.replace(/\\$MAP$/g, \"\");\r\n        }\r\n\r\n        const fieldNameConvention = this._conventions.serverToLocalFieldNameConverter;\r\n        if (fieldNameConvention) {\r\n            field = fieldNameConvention(field);\r\n        }\r\n\r\n        let fieldVal = parent[field];\r\n        // eslint-disable-next-line no-prototype-builtins\r\n        if (!parent.hasOwnProperty(field)) {\r\n            if (isFieldArray || isFieldSet || isFieldMap) {\r\n                fieldVal = parent;\r\n            } else {\r\n                return null;\r\n            }\r\n        }\r\n\r\n        if (isFieldArray) {\r\n            return this._getFieldContextsForArrayElements(fieldVal, fieldsPathTail);\r\n        }\r\n\r\n        if (isFieldSet) {\r\n            return this._getFieldContextsForSetElements(fieldVal as Set<any>, fieldsPathTail);\r\n        }\r\n\r\n        if (isFieldMap) {\r\n            return this._getFieldContextsForMapEntries(fieldVal as Map<any, any>, fieldsPathTail);\r\n        }\r\n\r\n        if (fieldsPathTail.length) {\r\n            return this._getFieldContext(parent[field], fieldsPathTail);\r\n        }\r\n\r\n        return {\r\n            parent,\r\n            field,\r\n            getValue() {\r\n                return parent[field];\r\n            },\r\n            setValue(val) {\r\n                parent[field] = val;\r\n            }\r\n        };\r\n    }\r\n\r\n    private _getFieldContextsForMapEntries(mapFieldVal: Map<string, any>, fieldsPathTail: string[]) {\r\n        const result = Array.from(mapFieldVal.entries()).map(([key, val]) => {\r\n            if (!fieldsPathTail.length) {\r\n                return {\r\n                    parent: mapFieldVal,\r\n                    field: key,\r\n                    getValue: () => val,\r\n                    setValue: (newVal) => {\r\n                        mapFieldVal.set(key, newVal);\r\n                    }\r\n                };\r\n            } else {\r\n                return this._getFieldContext(val, fieldsPathTail);\r\n            }\r\n        });\r\n\r\n        return this._flattenFieldContexts(result);\r\n    }\r\n\r\n    private _getFieldContextsForSetElements(setFieldVal: Set<any>, fieldsPathTail: string[]) {\r\n        const result = Array.from(setFieldVal).map(x => {\r\n            if (!fieldsPathTail.length) {\r\n                return {\r\n                    parent: setFieldVal,\r\n                    field: x,\r\n                    getValue: () => x,\r\n                    setValue: (val) => {\r\n                        setFieldVal.delete(x);\r\n                        setFieldVal.add(val);\r\n                    }\r\n                };\r\n            } else {\r\n                return this._getFieldContext(x, fieldsPathTail);\r\n            }\r\n        });\r\n\r\n        return this._flattenFieldContexts(result);\r\n    }\r\n\r\n    private _getFieldContextsForArrayElements(fieldVal, fieldsPathTail) {\r\n        const result = (fieldVal as any[]).map((x, i) => {\r\n            if (x === null) {\r\n                return null;\r\n            }\r\n\r\n            if (!fieldsPathTail.length) {\r\n                return {\r\n                    parent: fieldVal,\r\n                    field: i.toString(),\r\n                    getValue() {\r\n                        return fieldVal[i];\r\n                    },\r\n                    setValue(val) {\r\n                        fieldVal[i] = val;\r\n                    }\r\n                };\r\n            } else {\r\n                return this._getFieldContext(x, fieldsPathTail);\r\n            }\r\n        });\r\n\r\n        return this._flattenFieldContexts(result);\r\n    }\r\n\r\n    private _flattenFieldContexts(\r\n        arr: (ObjectPropertyContext[] | ObjectPropertyContext)[]): ObjectPropertyContext[] {\r\n        return arr.reduce((result: any, next) => {\r\n            if (Array.isArray(next)) {\r\n                return result.concat(next as ObjectPropertyContext[]);\r\n            }\r\n\r\n            result.push(next as ObjectPropertyContext);\r\n            return result;\r\n        }, [] as ObjectPropertyContext[]);\r\n    }\r\n\r\n    private _applyTypeToNestedProperty(\r\n        fieldTypeName: string, fieldContext: ObjectPropertyContext, knownTypes: Map<string, ObjectTypeDescriptor>) {\r\n        let parent: object;\r\n        let field: string;\r\n\r\n        if (fieldContext) {\r\n            ({ parent, field } = fieldContext);\r\n        }\r\n\r\n        if (typeof parent === \"undefined\") {\r\n            return;\r\n        }\r\n\r\n        const fieldVal = fieldContext.getValue();\r\n        if (typeof fieldVal === \"undefined\") {\r\n            return;\r\n        }\r\n\r\n        if (fieldVal === null) {\r\n            fieldContext.setValue(null);\r\n            return;\r\n        }\r\n\r\n        if (fieldTypeName === \"date\") {\r\n            fieldContext.setValue(this._conventions.dateUtil.parse(fieldVal));\r\n            return;\r\n        }\r\n\r\n        if (fieldTypeName === \"Set\") {\r\n            fieldContext.setValue(new Set(fieldVal));\r\n            return;\r\n        }\r\n\r\n        if (fieldTypeName === \"Map\") {\r\n            const map = new Map(fieldVal);\r\n            fieldContext.setValue(map);\r\n            return;\r\n        }\r\n\r\n        if (Array.isArray(fieldVal)) {\r\n            for (const [i, item] of fieldVal.entries()) {\r\n                this._applyTypeToNestedProperty(fieldTypeName, {\r\n                    field: i.toString(),\r\n                    parent: fieldVal,\r\n                    getValue: () => fieldVal[i],\r\n                    setValue: (val) => fieldVal[i] = val\r\n                }, knownTypes);\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        const ctorOrTypeDescriptor = this._getKnownType(fieldTypeName, knownTypes);\r\n        const instance = this._instantiateObject(fieldTypeName, fieldVal, ctorOrTypeDescriptor);\r\n        fieldContext.setValue(instance);\r\n    }\r\n\r\n    private _instantiateObject<TResult>(\r\n        typeName: string, rawValue: object, ctorOrTypeDescriptor: ObjectTypeDescriptor): TResult {\r\n        let instance = null;\r\n        if (!ctorOrTypeDescriptor) {\r\n            instance = Object.assign({}, rawValue);\r\n        } else if (TypeUtil.isClass(ctorOrTypeDescriptor)) {\r\n            instance = this.createEmptyObject(ctorOrTypeDescriptor, rawValue);\r\n        } else if (TypeUtil.isObjectLiteralTypeDescriptor(ctorOrTypeDescriptor)) {\r\n            instance = (ctorOrTypeDescriptor as ObjectLiteralDescriptor).construct(rawValue);\r\n        } else {\r\n            throwError(\"InvalidArgumentException\",\r\n                `Invalid type descriptor for type ${typeName}: ${ctorOrTypeDescriptor}`);\r\n        }\r\n\r\n        return instance as TResult;\r\n    }\r\n\r\n    private _getKnownType(typeName: string, knownTypes: Map<string, ObjectTypeDescriptor>): ObjectTypeDescriptor {\r\n        if (!typeName) {\r\n            return null;\r\n        }\r\n\r\n        const ctorOrTypeDescriptor = knownTypes.get(typeName);\r\n        if (!ctorOrTypeDescriptor) {\r\n            if (this._throwMappingErrors) {\r\n                throwError(\"MappingError\", `Could not find type descriptor '${typeName}'.`);\r\n            } else {\r\n                log.warn(`Could not find type descriptor '${typeName}'.`);\r\n            }\r\n        }\r\n\r\n        return ctorOrTypeDescriptor;\r\n    }\r\n\r\n    protected createEmptyObject<TResult extends object>(ctor: EntityConstructor<TResult>, rawValue: object) {\r\n        if (!ctor) {\r\n            throwError(\"InvalidArgumentException\", \"ctor argument must not be null or undefined.\");\r\n        }\r\n\r\n        return Object.assign(new ctor(), rawValue) as TResult;\r\n    }\r\n\r\n    private _makeObjectLiteral(\r\n        obj: object,\r\n        objPathPrefix: string,\r\n        typeInfoCallback: (types: NestedTypes) => void,\r\n        knownTypes: ObjectTypeDescriptor[],\r\n        skipTypes: boolean = false): any {\r\n\r\n        if (TypeUtil.isDate(obj)) {\r\n            if (!skipTypes) {\r\n                typeInfoCallback({\r\n                    [objPathPrefix]: \"date\"\r\n                });\r\n            }\r\n\r\n            return this._conventions.dateUtil.stringify(obj as Date);\r\n        }\r\n\r\n        if (TypeUtil.isSet(obj)) {\r\n            if (!skipTypes) {\r\n                typeInfoCallback({\r\n                    [objPathPrefix]: \"Set\"\r\n                });\r\n            }\r\n\r\n            const newObjPathPrefix = `${objPathPrefix}$SET`;\r\n            return Array.from((obj as Set<any>))\r\n                .map(x => this._makeObjectLiteral(x, newObjPathPrefix, typeInfoCallback, knownTypes));\r\n        }\r\n\r\n        if (TypeUtil.isMap(obj)) {\r\n            if (!skipTypes) {\r\n                typeInfoCallback({\r\n                    [objPathPrefix]: \"Map\"\r\n                });\r\n            }\r\n\r\n            const valuePathPrefix = `${objPathPrefix}$MAP`;\r\n            const map = obj as Map<any, any>;\r\n            return Array.from(map.entries()).reduce((result, [ name, value ]) => {\r\n                return [\r\n                    ...result,\r\n                    [\r\n                        this._makeObjectLiteral(name, valuePathPrefix + \"KEY\", typeInfoCallback, knownTypes),\r\n                        this._makeObjectLiteral(value, valuePathPrefix, typeInfoCallback, knownTypes)\r\n                    ]\r\n                ];\r\n            }, []);\r\n        }\r\n\r\n        if (Array.isArray(obj)) {\r\n            return obj.map((x, index) => this._makeObjectLiteral(x, `${objPathPrefix}.${index}`, typeInfoCallback, knownTypes));\r\n        }\r\n\r\n        if (TypeUtil.isObject(obj)) {\r\n            if (objPathPrefix) { // if it's non-root object\r\n                const matchedType = TypeUtil.findType(obj, knownTypes);\r\n                if (!skipTypes\r\n                    && matchedType\r\n                    && matchedType.name !== \"Function\") {\r\n                    typeInfoCallback({ [objPathPrefix]: matchedType.name });\r\n                }\r\n            }\r\n\r\n            return Object.keys(obj)\r\n                .reduce((result, key) => {\r\n                    let nestedTypeInfoKey = key;\r\n                    if (this._conventions.localToServerFieldNameConverter) {\r\n                        nestedTypeInfoKey = this._conventions.localToServerFieldNameConverter(key);\r\n                    }\r\n\r\n                    let innerSkipTypes = skipTypes\r\n                    if (!skipTypes) {\r\n                        innerSkipTypes = key === CONSTANTS.Documents.Metadata.KEY;\r\n                    }\r\n\r\n                    const fullPath = objPathPrefix ? `${objPathPrefix}.${nestedTypeInfoKey}` : nestedTypeInfoKey;\r\n                    result[key] = this._makeObjectLiteral(obj[key], fullPath, typeInfoCallback, knownTypes, innerSkipTypes);\r\n                    return result;\r\n                }, {});\r\n        }\r\n\r\n        return obj;\r\n    }\r\n}\r\n\r\nexport interface TypesAwareJsonObjectMapperOptions {\r\n    documentConventions?: DocumentConventions;\r\n}\r\n\r\ninterface ObjectPropertyContext {\r\n    parent: any;\r\n    field: string;\r\n\r\n    getValue(): any;\r\n\r\n    setValue(val: any): void;\r\n}\r\n"]}