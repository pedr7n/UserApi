"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExceptionDispatcher = void 0;
exports.throwError = throwError;
exports.getError = getError;
const HttpUtil_js_1 = require("../Utility/HttpUtil.js");
const StatusCode_js_1 = require("../Http/StatusCode.js");
const Serializer_js_1 = require("../Mapping/Json/Serializer.js");
const OsUtil_js_1 = require("../Utility/OsUtil.js");
function throwError(errName = "RavenException", message, errCause, info) {
    throw getError(errName, message, errCause, info);
}
function buildMessageWithInner(error) {
    if (!error) {
        return null;
    }
    if (!error.cause) {
        return error.message;
    }
    const inner = buildMessageWithInner(error.cause);
    return inner ? error.message + ": " + inner : error.message;
}
function getError(errName = "RavenException", message = "", errCause, info) {
    const innerMessage = buildMessageWithInner(errCause);
    const error = new Error(message + (innerMessage ? ": " + innerMessage : ""), { cause: errCause });
    error.name = errName;
    if (info) {
        for (const value of Object.entries(info)) {
            error[value[0]] = value[1];
        }
    }
    return error;
}
class ExceptionDispatcher {
    static _jsonSerializer = Serializer_js_1.JsonSerializer.getDefaultForCommandPayload();
    static get(schema, code, inner) {
        const message = schema.message;
        const typeAsString = schema.type;
        if (code === StatusCode_js_1.StatusCodes.Conflict) {
            if (typeAsString.includes("DocumentConflictException")) {
                return getError("DocumentConflictException", message, inner);
            }
            return getError("ConcurrencyException", schema.error, inner);
        }
        const error = schema.error + OsUtil_js_1.EOL
            + "The server at " + schema.url + " responded with status code: " + code;
        const determinedType = this._getType(typeAsString);
        return getError(determinedType || "RavenException", error, inner);
    }
    static throwException(response, body) {
        if (!response) {
            throw getError("InvalidArgumentException", "Response cannot be null");
        }
        let errorToThrow;
        try {
            const json = body;
            const schema = ExceptionDispatcher._jsonSerializer.deserialize(json);
            if (response.status === StatusCode_js_1.StatusCodes.Conflict) {
                errorToThrow = this._getConflictError(schema, json);
            }
            else {
                const determinedType = this._getType(schema.type);
                errorToThrow = getError(determinedType || "RavenException", schema.error);
            }
            ExceptionDispatcher._fillException(errorToThrow, schema);
        }
        catch (errThrowing) {
            errorToThrow = getError("RavenException", errThrowing.message, errThrowing);
        }
        finally {
            (0, HttpUtil_js_1.closeHttpResponse)(response);
        }
        throw errorToThrow;
    }
    static _fillException(exception, json) {
        if (exception.name === "RavenTimeoutException") {
            exception.failImmediately = !!json.FailImmediately;
        }
    }
    static _getConflictError(schema, json) {
        if (schema.type.includes("DocumentConflictException")) {
            return getError("DocumentConflictException", schema.message, null, { json });
        }
        if (schema.type.includes("ClusterTransactionConcurrencyException")) {
            return getError("ClusterTransactionConcurrencyException", schema.message, null, { json });
        }
        return getError("ConcurrencyException", schema.message);
    }
    static _getType(typeAsString) {
        if ("System.TimeoutException" === typeAsString) {
            return "TimeoutException";
        }
        const prefix = "Raven.Client.Exceptions.";
        if (typeAsString && typeAsString.startsWith(prefix)) {
            const exceptionName = typeAsString.substring(prefix.length);
            if (exceptionName.includes(".")) {
                const tokens = exceptionName.split(".");
                return tokens.at(-1);
            }
            return exceptionName;
        }
        else {
            return null;
        }
    }
}
exports.ExceptionDispatcher = ExceptionDispatcher;
//# sourceMappingURL=index.js.map