import { ITypesAwareObjectMapper } from "../../Mapping/ObjectMapper.js";
import { DocumentType } from "../DocumentAbstractions.js";
import { ObjectTypeDescriptor, EntityConstructor, Field } from "../../Types/index.js";
import { ClientConfiguration } from "../Operations/Configuration/ClientConfiguration.js";
import { ReadBalanceBehavior } from "../../Http/ReadBalanceBehavior.js";
import { DateUtil } from "../../Utility/DateUtil.js";
import { FieldNameConversion } from "../../Utility/ObjectUtil.js";
import { LoadBalanceBehavior } from "../../Http/LoadBalanceBehavior.js";
import { BulkInsertConventions } from "./BulkInsertConventions.js";
import { InMemoryDocumentSessionOperations } from "../Session/InMemoryDocumentSessionOperations.js";
import { ShardingConventions } from "./ShardingConventions.js";
export type IdConvention = (databaseName: string, entity: object) => Promise<string>;
export type IValueForQueryConverter<T> = (fieldName: Field<T>, value: T, forRange: boolean, stringValue: (value: any) => void) => boolean;
export declare class DocumentConventions {
    private static _defaults;
    static defaultForServerConventions: DocumentConventions;
    static get defaultConventions(): DocumentConventions;
    private static _cachedDefaultTypeCollectionNames;
    private readonly _listOfQueryValueToObjectConverters;
    private _registeredIdConventions;
    private _registeredIdPropertyNames;
    private _frozen;
    private _originalConfiguration;
    private _identityPartsSeparator;
    private _disableTopologyUpdates;
    private _disableAtomicDocumentWritesInClusterWideTransaction;
    private _disableTcpCompression;
    private _shouldIgnoreEntityChanges;
    private _transformClassCollectionNameToDocumentIdPrefix;
    private _documentIdGenerator;
    private _loadBalancerPerSessionContextSelector;
    private _findCollectionName;
    private _identityProperty;
    private _findJsTypeName;
    private _findJsType;
    private _useOptimisticConcurrency;
    private _maxNumberOfRequestsPerSession;
    private _requestTimeout;
    private _firstBroadcastAttemptTimeout;
    private _secondBroadcastAttemptTimeout;
    private _waitForIndexesAfterSaveChangesTimeout;
    private _waitForReplicationAfterSaveChangesTimeout;
    private _waitForNonStaleResultsTimeout;
    private _loadBalancerContextSeed;
    private _loadBalanceBehavior;
    private _readBalanceBehavior;
    private _maxHttpCacheSize;
    private readonly _knownEntityTypes;
    private _localToServerFieldNameConverter?;
    private _serverToLocalFieldNameConverter?;
    private _objectMapper;
    private _customFetch;
    private _dateUtil;
    private _useHttpDecompression;
    private _httpCompressionAlgorithm;
    private _sendApplicationIdentifier;
    private readonly _bulkInsert;
    get bulkInsert(): BulkInsertConventions;
    private readonly _sharding;
    get sharding(): ShardingConventions;
    private _returnPlainJsObjects;
    /**
     * Gets whether all values returned from API will be plain objects (not class instances).
     * This is useful for environments like Next.js that require serializable results.
     */
    get returnPlainJsObjects(): boolean;
    /**
     * Sets whether all values returned from API will be plain objects (not class instances).
     * This is useful for environments like Next.js that require serializable results.
     */
    set returnPlainJsObjects(value: boolean);
    constructor();
    get requestTimeout(): number;
    set requestTimeout(requestTimeout: number);
    /**
     * Enables sending a unique application identifier to the RavenDB Server that is used for Client API usage tracking.
     * It allows RavenDB Server to issue performance hint notifications e.g. during robust topology update requests which could indicate Client API misuse impacting the overall performance
     * @return if option is enabled
     */
    get sendApplicationIdentifier(): boolean;
    /**
     * Enables sending a unique application identifier to the RavenDB Server that is used for Client API usage tracking.
     * It allows RavenDB Server to issue performance hint notifications e.g. during robust topology update requests which could indicate Client API misuse impacting the overall performance
     * @param sendApplicationIdentifier if option should be enabled
     */
    set sendApplicationIdentifier(sendApplicationIdentifier: boolean);
    /**
     * Get the timeout for the second broadcast attempt.
     * Default: 30 seconds
     *
     * Upon failure of the first attempt the request executor will resend the command to all nodes simultaneously.
     * @return broadcast timeout
     */
    get secondBroadcastAttemptTimeout(): number;
    /**
     * Set the timeout for the second broadcast attempt.
     * Default: 30 seconds
     *
     * Upon failure of the first attempt the request executor will resend the command to all nodes simultaneously.
     *
     * @param secondBroadcastAttemptTimeout broadcast timeout
     */
    set secondBroadcastAttemptTimeout(secondBroadcastAttemptTimeout: number);
    /**
     * Get the timeout for the first broadcast attempt.
     * Default: 5 seconds
     *
     * First attempt will send a single request to a selected node.
     * @return broadcast timeout
     */
    get firstBroadcastAttemptTimeout(): number;
    /**
     * Set the timeout for the first broadcast attempt.
     * Default: 5 seconds
     *
     * First attempt will send a single request to a selected node.
     *
     * @param firstBroadcastAttemptTimeout broadcast timeout
     */
    set firstBroadcastAttemptTimeout(firstBroadcastAttemptTimeout: number);
    get objectMapper(): ITypesAwareObjectMapper;
    set objectMapper(value: ITypesAwareObjectMapper);
    get customFetch(): any;
    /**
     * Allows to override default fetch method
     *
     * This method is useful to enable RavenDB node.js client
     * on CloudFlare Workers
     *
     * You should pass object bound to worker with type: mtls_certificate
     *
     * @param customFetch
     */
    set customFetch(customFetch: any);
    get dateUtil(): DateUtil;
    set dateUtil(value: DateUtil);
    get readBalanceBehavior(): ReadBalanceBehavior;
    set readBalanceBehavior(value: ReadBalanceBehavior);
    get loadBalancerContextSeed(): number;
    set loadBalancerContextSeed(seed: number);
    get isDisableTcpCompression(): boolean;
    /**
     * We have to make this check so if admin activated this, but client code did not provide the selector,
     * it is still disabled. Relevant if we have multiple clients / versions at once.
     */
    get loadBalanceBehavior(): LoadBalanceBehavior;
    set loadBalanceBehavior(loadBalanceBehavior: LoadBalanceBehavior);
    /**
     * Gets the function that allow to specialize the topology
     * selection for a particular session. Used in load balancing
     * scenarios
     */
    get loadBalancerPerSessionContextSelector(): (databaseName: string) => string;
    /**
     * Sets the function that allow to specialize the topology
     * selection for a particular session. Used in load balancing
     * scenarios
     * @param selector selector to use
     */
    set loadBalancerPerSessionContextSelector(selector: (databaseName: string) => string);
    /**
     * Optional field name casing converter
     * This one is applied on local object before sending request to server
     */
    get localToServerFieldNameConverter(): FieldNameConversion;
    /**
     * Optional field name casing converter
     * This one is applied on local object before sending request to server
     */
    set localToServerFieldNameConverter(converter: FieldNameConversion);
    /**
     * Optional field name casing converter
     * This one is applied on server object before returning result to the user
     */
    get serverToLocalFieldNameConverter(): FieldNameConversion;
    /**
     * Optional field name casing converter
     * This one is applied on server object before returning result to the user
     */
    set serverToLocalFieldNameConverter(converter: FieldNameConversion);
    set useOptimisticConcurrency(val: boolean);
    get useOptimisticConcurrency(): boolean;
    deserializeEntityFromJson(documentType: ObjectTypeDescriptor, document: object): object;
    get maxNumberOfRequestsPerSession(): number;
    set maxNumberOfRequestsPerSession(value: number);
    get maxHttpCacheSize(): number;
    set maxHttpCacheSize(value: number);
    get waitForIndexesAfterSaveChangesTimeout(): number;
    set waitForIndexesAfterSaveChangesTimeout(value: number);
    get waitForNonStaleResultsTimeout(): number;
    set waitForNonStaleResultsTimeout(value: number);
    get waitForReplicationAfterSaveChangesTimeout(): number;
    set waitForReplicationAfterSaveChangesTimeout(value: number);
    /**
     * Can accept compressed HTTP response content and will use decompression methods
     */
    get useHttpDecompression(): boolean;
    /**
     * Can accept compressed HTTP response content and will use decompression methods
     */
    set useHttpDecompression(value: boolean);
    get httpCompressionAlgorithm(): "Gzip";
    private _dateUtilOpts;
    get storeDatesInUtc(): boolean;
    set storeDatesInUtc(value: boolean);
    get storeDatesWithTimezoneInfo(): boolean;
    set storeDatesWithTimezoneInfo(value: boolean);
    /**
     * Whether UseOptimisticConcurrency is set to true by default for all opened sessions
     */
    isUseOptimisticConcurrency(): boolean;
    /**
     * Whether UseOptimisticConcurrency is set to true by default for all opened sessions
     */
    setUseOptimisticConcurrency(useOptimisticConcurrency: boolean): void;
    get identityProperty(): string;
    set identityProperty(val: string);
    get findJsType(): (id: string, doc: object) => ObjectTypeDescriptor;
    set findJsType(value: (id: string, doc: object) => ObjectTypeDescriptor);
    get findJsTypeName(): (ctorOrTypeChecker: ObjectTypeDescriptor) => string;
    set findJsTypeName(value: (ctorOrTypeChecker: ObjectTypeDescriptor) => string);
    get findCollectionName(): (constructorOrTypeChecker: ObjectTypeDescriptor) => string;
    set findCollectionName(value: (constructorOrTypeChecker: ObjectTypeDescriptor) => string);
    get documentIdGenerator(): IdConvention;
    set documentIdGenerator(value: IdConvention);
    get identityPartsSeparator(): string;
    set identityPartsSeparator(value: string);
    get shouldIgnoreEntityChanges(): (sessionOperations: InMemoryDocumentSessionOperations, entity: object, documentId: string) => boolean;
    set shouldIgnoreEntityChanges(shouldIgnoreEntityChanges: (sessionOperations: InMemoryDocumentSessionOperations, entity: object, documentId: string) => boolean);
    get disableTopologyUpdates(): boolean;
    set disableTopologyUpdates(value: boolean);
    get transformClassCollectionNameToDocumentIdPrefix(): (maybeClassCollectionName: string) => string;
    set transformClassCollectionNameToDocumentIdPrefix(value: (maybeClassCollectionName: string) => string);
    /**
     *  Default method used when finding a collection name for a type
     */
    static defaultGetCollectionName(ctorOrTypeChecker: ObjectTypeDescriptor): string;
    /**
     * Gets the collection name for a given type.
     */
    getCollectionNameForType(ctorOrTypeChecker: ObjectTypeDescriptor): string;
    /**
     * Gets the collection name for a given type.
     */
    getCollectionNameForEntity(entity: object): string;
    private _findCollectionNameForObjectLiteral;
    get findCollectionNameForObjectLiteral(): (entity: object) => string;
    set findCollectionNameForObjectLiteral(value: (entity: object) => string);
    getTypeDescriptorByEntity<T extends object>(entity: T): ObjectTypeDescriptor<T>;
    getEntityTypeDescriptor<T extends object>(entity: T): ObjectTypeDescriptor<T>;
    /**
     * Generates the document id.
     */
    generateDocumentId(database: string, entity: object): Promise<string>;
    /**
     * Register an id convention for a single type.
     * Note that you can still fall back to the DocumentIdGenerator if you want.
     */
    registerIdConvention<TEntity>(ctorOrTypeChecker: ObjectTypeDescriptor, idConvention: IdConvention): DocumentConventions;
    registerEntityIdPropertyName(ctorOrTypeChecker: ObjectTypeDescriptor, idProperty: string): void;
    /**
     * Get the java class (if exists) from the document
     */
    getJsType(id: string, document: object): ObjectTypeDescriptor;
    /**
     * Get the Java class name to be stored in the entity metadata
     */
    getJsTypeName(entityType: ObjectTypeDescriptor): string;
    /**
     * EXPERT: Disable automatic atomic writes with cluster write transactions. If set to 'true', will only consider explicitly
     * added compare exchange values to validate cluster wide transactions.
     */
    get disableAtomicDocumentWritesInClusterWideTransaction(): boolean;
    /**
     * EXPERT: Disable automatic atomic writes with cluster write transactions. If set to 'true', will only consider explicitly
     * added compare exchange values to validate cluster wide transactions.
     */
    set disableAtomicDocumentWritesInClusterWideTransaction(disableAtomicDocumentWritesInClusterWideTransaction: boolean);
    clone(): DocumentConventions;
    /**
     *  Gets the identity property.
     */
    getIdentityProperty(documentType: DocumentType): string;
    updateFrom(configuration: ClientConfiguration): void;
    static defaultTransformCollectionNameToDocumentIdPrefix(collectionName: string): string;
    registerQueryValueConverter<T extends object>(type: EntityConstructor<T>, converter: IValueForQueryConverter<T>): void;
    tryConvertValueToObjectForQuery(fieldName: string, value: any, forRange: boolean, strValue: (value: any) => void): boolean;
    freeze(): void;
    _assertNotFrozen(): void;
    get knownEntityTypesByName(): Map<string, ObjectTypeDescriptor>;
    get knownEntityTypes(): ObjectTypeDescriptor[];
    registerJsType(entityType: ObjectTypeDescriptor): this;
    registerJsType(entityType: ObjectTypeDescriptor, name: string): this;
    registerEntityType(entityType: ObjectTypeDescriptor): this;
    registerEntityType(entityType: ObjectTypeDescriptor, name: string): this;
    tryRegisterJsType(docType: DocumentType): this;
    tryRegisterEntityType(docType: DocumentType): this;
    getJsTypeByDocumentType<T extends object>(documentType: DocumentType<T>): ObjectTypeDescriptor<T>;
    getJsTypeByDocumentType<T extends object>(typeName: string): ObjectTypeDescriptor<T>;
    transformObjectKeysToRemoteFieldNameConvention(obj: object): object;
    validate(): void;
}
//# sourceMappingURL=DocumentConventions.d.ts.map