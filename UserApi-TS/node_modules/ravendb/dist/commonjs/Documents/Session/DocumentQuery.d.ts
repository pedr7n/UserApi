import { AbstractDocumentQuery } from "./AbstractDocumentQuery.js";
import { IDocumentQuery } from "./IDocumentQuery.js";
import { DocumentType } from "../DocumentAbstractions.js";
import { InMemoryDocumentSessionOperations } from "./InMemoryDocumentSessionOperations.js";
import { DeclareToken } from "./Tokens/DeclareToken.js";
import { LoadToken } from "./Tokens/LoadToken.js";
import { QueryData } from "../Queries/QueryData.js";
import { OrderingType } from "./OrderingType.js";
import { SearchOperator } from "../Queries/SearchOperator.js";
import { QueryStatistics } from "./QueryStatistics.js";
import { QueryOperator } from "../Queries/QueryOperator.js";
import { MethodCall } from "./MethodCall.js";
import { WhereParams } from "./WhereParams.js";
import { IGroupByDocumentQuery } from "./IGroupByDocumentQuery.js";
import { GroupBy } from "../Queries/GroupBy.js";
import { SpatialCriteriaFactory } from "../Queries/Spatial/SpatialCriteriaFactory.js";
import { SpatialCriteria } from "../Queries/Spatial/SpatialCriteria.js";
import { DynamicSpatialField } from "../Queries/Spatial/DynamicSpatialField.js";
import { SpatialRelation, SpatialUnits } from "../Indexes/Spatial.js";
import { IFacetBuilder } from "../Queries/Facets/IFacetBuilder.js";
import { IAggregationDocumentQuery } from "../Queries/Facets/IAggregationDocumentQuery.js";
import { FacetBase } from "../Queries/Facets/FacetBase.js";
import { MoreLikeThisBase } from "../Queries/MoreLikeThis/MoreLikeThisBase.js";
import { IMoreLikeThisBuilderForDocumentQuery } from "../Queries/MoreLikeThis/IMoreLikeThisBuilderForDocumentQuery.js";
import { SuggestionBase } from "../Queries/Suggestions/SuggestionBase.js";
import { ISuggestionDocumentQuery } from "../Queries/Suggestions/ISuggestionDocumentQuery.js";
import { ISuggestionBuilder } from "../Queries/Suggestions/ISuggestionBuilder.js";
import { ValueCallback } from "../../Types/Callbacks.js";
import { QueryTimings } from "../Queries/Timings/QueryTimings.js";
import { Explanations } from "../Queries/Explanation/Explanations.js";
import { ExplanationOptions } from "../Queries/Explanation/ExplanationOptions.js";
import { Highlightings } from "../Queries/Highlighting/Hightlightings.js";
import { HighlightingParameters } from "../Queries/Highlighting/HighlightingParameters.js";
import { IQueryIncludeBuilder } from "./Loaders/IQueryIncludeBuilder.js";
import { ITimeSeriesQueryBuilder } from "../Queries/TimeSeries/ITimeSeriesQueryBuilder.js";
import { TimeSeriesAggregationResult } from "../Queries/TimeSeries/TimeSeriesAggregationResult.js";
import { TimeSeriesRawResult } from "../Queries/TimeSeries/TimeSeriesRawResult.js";
import { Field } from "../../Types/index.js";
import { IAbstractDocumentQueryImpl } from "./IAbstractDocumentQueryImpl.js";
import { ProjectionBehavior } from "../Queries/ProjectionBehavior.js";
import { IFilterFactory } from "../Queries/IFilterFactory.js";
import { IQueryShardedContextBuilder } from "./Querying/Sharding/IQueryShardedContextBuilder.js";
import { IVectorOptions } from "../Queries/VectorSearch/VectorSearchOptions.js";
import { IVectorEmbeddingField, IVectorEmbeddingTextField, IVectorField, IVectorFieldFactory, IVectorFieldValueFactory } from "./VectorFieldFactory.js";
export declare const NESTED_OBJECT_TYPES_PROJECTION_FIELD = "__PROJECTED_NESTED_OBJECT_TYPES__";
export declare class DocumentQuery<T extends object> extends AbstractDocumentQuery<T, DocumentQuery<T>> implements IDocumentQuery<T>, IAbstractDocumentQueryImpl<T> {
    constructor(documentType: DocumentType<T>, session: InMemoryDocumentSessionOperations, indexName: string, collectionName: string, isGroupBy: boolean);
    constructor(documentType: DocumentType<T>, session: InMemoryDocumentSessionOperations, indexName: string, collectionName: string, isGroupBy: boolean, declareTokens: DeclareToken[], loadTokens: LoadToken[], fromAlias: string);
    constructor(documentType: DocumentType<T>, session: InMemoryDocumentSessionOperations, indexName: string, collectionName: string, isGroupBy: boolean, declareTokens: DeclareToken[], loadTokens: LoadToken[], fromAlias: string, isProjectInto: boolean);
    selectFields<TProjection extends Object>(property: string): IDocumentQuery<TProjection>;
    selectFields<TProjection extends object>(properties: string[]): IDocumentQuery<TProjection>;
    selectFields<TProjection extends object>(queryData: QueryData, projectionType: DocumentType<TProjection>): IDocumentQuery<TProjection>;
    selectFields<TProjection extends object>(property: string, projectionType: DocumentType<TProjection>): IDocumentQuery<TProjection>;
    selectFields<TProjection extends object>(properties: string[], projectionType: DocumentType<TProjection>): IDocumentQuery<TProjection>;
    selectFields<TProjection extends object>(property: string, projectionType: DocumentType<TProjection>, projectionBehavior: ProjectionBehavior): IDocumentQuery<TProjection>;
    selectFields<TProjection extends object>(properties: string[], projectionType: DocumentType<TProjection>, projectionBehavior: ProjectionBehavior): IDocumentQuery<TProjection>;
    private _selectFieldsByProjectionType;
    selectTimeSeries(timeSeriesQuery: (builder: ITimeSeriesQueryBuilder) => void, projectionClass: DocumentType<TimeSeriesAggregationResult>): IDocumentQuery<TimeSeriesAggregationResult>;
    selectTimeSeries(timeSeriesQuery: (builder: ITimeSeriesQueryBuilder) => void, projectionClass: DocumentType<TimeSeriesRawResult>): IDocumentQuery<TimeSeriesRawResult>;
    distinct(): IDocumentQuery<T>;
    orderByScore(): IDocumentQuery<T>;
    orderByScoreDescending(): IDocumentQuery<T>;
    includeExplanations(explanationsCallback: ValueCallback<Explanations>): IDocumentQuery<T>;
    includeExplanations(options: ExplanationOptions, explanationsCallback?: ValueCallback<Explanations>): IDocumentQuery<T>;
    timings(timings: ValueCallback<QueryTimings>): IDocumentQuery<T>;
    waitForNonStaleResults(): IDocumentQuery<T>;
    waitForNonStaleResults(waitTimeout: number): IDocumentQuery<T>;
    addParameter(name: string, value: any): IDocumentQuery<T>;
    addOrder(fieldName: Field<T>, descending: boolean): IDocumentQuery<T>;
    addOrder(fieldName: Field<T>, descending: boolean, ordering: OrderingType): IDocumentQuery<T>;
    openSubclause(): IDocumentQuery<T>;
    closeSubclause(): IDocumentQuery<T>;
    negateNext(): IDocumentQuery<T>;
    search(fieldName: Field<T>, searchTerms: string): IDocumentQuery<T>;
    search(fieldName: Field<T>, searchTerms: string, operator: SearchOperator): IDocumentQuery<T>;
    intersect(): IDocumentQuery<T>;
    containsAny(fieldName: Field<T>, values: any[]): IDocumentQuery<T>;
    containsAll(fieldName: Field<T>, values: any): IDocumentQuery<T>;
    statistics(stats: (stats: QueryStatistics) => void): IDocumentQuery<T>;
    usingDefaultOperator(queryOperator: QueryOperator): IDocumentQuery<T>;
    noTracking(): IDocumentQuery<T>;
    noCaching(): IDocumentQuery<T>;
    include(path: string): IDocumentQuery<T>;
    include(includes: (includeBuilder: IQueryIncludeBuilder) => void): IDocumentQuery<T>;
    not(): IDocumentQuery<T>;
    take(count: number): IDocumentQuery<T>;
    skip(count: number): IDocumentQuery<T>;
    whereLucene(fieldName: Field<T>, whereClause: string): IDocumentQuery<T>;
    whereLucene(fieldName: Field<T>, whereClause: string, exact: boolean): IDocumentQuery<T>;
    whereEquals(fieldName: Field<T>, method: MethodCall): IDocumentQuery<T>;
    whereEquals(fieldName: Field<T>, method: MethodCall, exact: boolean): IDocumentQuery<T>;
    whereEquals(fieldName: Field<T>, value: any): void;
    whereEquals(fieldName: Field<T>, value: any, exact: boolean): IDocumentQuery<T>;
    whereEquals(whereParams: WhereParams): IDocumentQuery<T>;
    whereNotEquals(fieldName: Field<T>, method: MethodCall): IDocumentQuery<T>;
    whereNotEquals(fieldName: Field<T>, method: MethodCall, exact: boolean): IDocumentQuery<T>;
    whereNotEquals(fieldName: Field<T>, value: any): void;
    whereNotEquals(fieldName: Field<T>, value: any, exact: boolean): IDocumentQuery<T>;
    whereNotEquals(whereParams: WhereParams): IDocumentQuery<T>;
    whereIn(fieldName: Field<T>, values: any[]): IDocumentQuery<T>;
    whereIn(fieldName: Field<T>, values: any[], exact: boolean): IDocumentQuery<T>;
    whereStartsWith(fieldName: Field<T>, value: any): IDocumentQuery<T>;
    whereStartsWith(fieldName: Field<T>, value: any, exact: boolean): IDocumentQuery<T>;
    whereEndsWith(fieldName: Field<T>, value: any): IDocumentQuery<T>;
    whereEndsWith(fieldName: Field<T>, value: any, exact: boolean): IDocumentQuery<T>;
    whereBetween(fieldName: Field<T>, start: any, end: any): IDocumentQuery<T>;
    whereBetween(fieldName: Field<T>, start: any, end: any, exact: boolean): IDocumentQuery<T>;
    whereGreaterThan(fieldName: Field<T>, value: any): IDocumentQuery<T>;
    whereGreaterThan(fieldName: Field<T>, value: any, exact: boolean): IDocumentQuery<T>;
    whereGreaterThanOrEqual(fieldName: Field<T>, value: any): IDocumentQuery<T>;
    whereGreaterThanOrEqual(fieldName: Field<T>, value: any, exact: boolean): IDocumentQuery<T>;
    whereLessThan(fieldName: Field<T>, value: any): IDocumentQuery<T>;
    whereLessThan(fieldName: Field<T>, value: any, exact: boolean): IDocumentQuery<T>;
    whereLessThanOrEqual(fieldName: Field<T>, value: any): IDocumentQuery<T>;
    whereLessThanOrEqual(fieldName: Field<T>, value: any, exact: boolean): IDocumentQuery<T>;
    whereExists(fieldName: Field<T>): IDocumentQuery<T>;
    whereRegex(fieldName: Field<T>, pattern: string): IDocumentQuery<T>;
    andAlso(): IDocumentQuery<T>;
    andAlso(wrapPreviousQueryClauses: boolean): IDocumentQuery<T>;
    orElse(): IDocumentQuery<T>;
    boost(boost: number): IDocumentQuery<T>;
    fuzzy(fuzzy: number): IDocumentQuery<T>;
    proximity(proximity: number): IDocumentQuery<T>;
    randomOrdering(): IDocumentQuery<T>;
    randomOrdering(seed: string): IDocumentQuery<T>;
    groupBy(fieldName: Field<T>, ...fieldNames: string[]): IGroupByDocumentQuery<T>;
    groupBy(field: GroupBy, ...fields: GroupBy[]): IGroupByDocumentQuery<T>;
    ofType<TResult extends object>(tResultClass: DocumentType<TResult>): IDocumentQuery<TResult>;
    orderBy(field: Field<T>): IDocumentQuery<T>;
    orderBy(field: Field<T>, ordering: OrderingType): IDocumentQuery<T>;
    orderBy(field: Field<T>, options: {
        sorterName: string;
    }): IDocumentQuery<T>;
    orderByDescending(field: Field<T>): IDocumentQuery<T>;
    orderByDescending(field: Field<T>, ordering: OrderingType): IDocumentQuery<T>;
    orderByDescending(field: Field<T>, options: {
        sorterName: string;
    }): IDocumentQuery<T>;
    createDocumentQueryInternal<TResult extends object>(resultClass: DocumentType<TResult>): DocumentQuery<TResult>;
    createDocumentQueryInternal<TResult extends object>(resultClass: DocumentType<TResult>, queryData: QueryData): DocumentQuery<TResult>;
    aggregateBy(builder: (facetBuilder: IFacetBuilder<T>) => void): IAggregationDocumentQuery<T>;
    aggregateBy(facet: FacetBase): IAggregationDocumentQuery<T>;
    aggregateBy(...facets: FacetBase[]): IAggregationDocumentQuery<T>;
    aggregateUsing(facetSetupDocumentId: string): IAggregationDocumentQuery<T>;
    highlight(parameters: HighlightingParameters, hightlightingsCallback: ValueCallback<Highlightings>): IDocumentQuery<T>;
    spatial(fieldName: Field<T>, clause: (factory: SpatialCriteriaFactory) => SpatialCriteria): IDocumentQuery<T>;
    spatial(field: DynamicSpatialField, clause: (factory: SpatialCriteriaFactory) => SpatialCriteria): IDocumentQuery<T>;
    /**
     * Filter matches to be inside the specified radius
     */
    withinRadiusOf(fieldName: Field<T>, radius: number, latitude: number, longitude: number): IDocumentQuery<T>;
    /**
     * Filter matches to be inside the specified radius
     */
    withinRadiusOf(fieldName: Field<T>, radius: number, latitude: number, longitude: number, radiusUnits: SpatialUnits): IDocumentQuery<T>;
    /**
     * Filter matches to be inside the specified radius
     */
    withinRadiusOf(fieldName: Field<T>, radius: number, latitude: number, longitude: number, radiusUnits: SpatialUnits, distanceErrorPct: number): IDocumentQuery<T>;
    relatesToShape(fieldName: Field<T>, shapeWkt: string, relation: SpatialRelation): IDocumentQuery<T>;
    relatesToShape(fieldName: Field<T>, shapeWkt: string, relation: SpatialRelation, distanceErrorPct: number): IDocumentQuery<T>;
    relatesToShape(fieldName: Field<T>, shapeWkt: string, relation: SpatialRelation, units: SpatialUnits, distanceErrorPct: number): IDocumentQuery<T>;
    orderByDistance(field: DynamicSpatialField, latitude: number, longitude: number): IDocumentQuery<T>;
    orderByDistance(field: DynamicSpatialField, shapeWkt: string): IDocumentQuery<T>;
    orderByDistance(fieldName: Field<T>, latitude: number, longitude: number): IDocumentQuery<T>;
    orderByDistance(fieldName: Field<T>, latitude: number, longitude: number, roundFactor: number): IDocumentQuery<T>;
    orderByDistance(fieldName: Field<T>, shapeWkt: string): IDocumentQuery<T>;
    orderByDistanceDescending(field: DynamicSpatialField, latitude: number, longitude: number): IDocumentQuery<T>;
    orderByDistanceDescending(field: DynamicSpatialField, shapeWkt: string): IDocumentQuery<T>;
    orderByDistanceDescending(fieldName: Field<T>, latitude: number, longitude: number): IDocumentQuery<T>;
    orderByDistanceDescending(fieldName: Field<T>, latitude: number, longitude: number, roundFactor: number): IDocumentQuery<T>;
    orderByDistanceDescending(fieldName: Field<T>, shapeWkt: string): IDocumentQuery<T>;
    moreLikeThis(builder: (moreLikeThisBuilder: IMoreLikeThisBuilderForDocumentQuery<T>) => void): IDocumentQuery<T>;
    moreLikeThis(moreLikeThis: MoreLikeThisBase): IDocumentQuery<T>;
    suggestUsing(suggestion: SuggestionBase): ISuggestionDocumentQuery<T>;
    suggestUsing(action: (builder: ISuggestionBuilder<T>) => void): ISuggestionDocumentQuery<T>;
    filter(builder: (factory: IFilterFactory<T>) => void, limit?: number): IDocumentQuery<T>;
    shardContext(action: (builder: IQueryShardedContextBuilder) => void): IDocumentQuery<T>;
    /**
     * Performs a vector similarity search using the specified field and embedding vector.
     * @param fieldName Field containing vector values or a function that returns a field using the vector factory
     * @param valueFactory The vector to compare against as a function, array of numbers, or string
     * @param options Additional vector search options
     */
    vectorSearch(fieldName: Field<T> | ((factory: IVectorFieldFactory<T>) => IVectorField | IVectorEmbeddingField | IVectorEmbeddingTextField), valueFactory: number[] | string | ((factory: IVectorFieldValueFactory) => void), options?: IVectorOptions): IDocumentQuery<T>;
}
//# sourceMappingURL=DocumentQuery.d.ts.map