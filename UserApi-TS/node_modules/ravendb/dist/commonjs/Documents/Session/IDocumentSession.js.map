{"version":3,"file":"IDocumentSession.js","sourceRoot":"","sources":["../../../../src/Documents/Session/IDocumentSession.ts"],"names":[],"mappings":";;;AAgBA,wDAAuD;AACvD,+DAAyD;AAEzD,oEAA8D;AAO9D,6CAAqC;AAErC,MAAa,WAAW;IACZ,MAAM,CAAC,uBAAuB,GAAW,CAAC,CAAC;IAE3C,UAAU,CAAS;IACnB,cAAc,CAAU;IACf,wBAAwB,CAAS;IAC1C,0BAA0B,CAAU;IAC3B,QAAQ,CAAoC;IAEtD,2BAA2B,CAAS;IACpC,SAAS,CAAU;IAE1B,YAAmB,OAA0C,EAAE,OAAuB,EAAE,aAAgC;QACpH,IAAI,CAAC,aAAa,EAAE,CAAC;YACjB,IAAA,qBAAU,EAAC,0BAA0B,EAAE,8BAA8B,CAAC,CAAC;QAC3E,CAAC;QAED,IAAI,CAAC,OAAO,EAAE,CAAC;YACX,IAAA,qBAAU,EAAC,0BAA0B,EAAE,wBAAwB,CAAC,CAAC;QACrE,CAAC;QAED,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC;QACxB,IAAI,CAAC,wBAAwB,GAAG,OAAO,CAAC,eAAe,CAAC,WAAW,CAAC,uBAAuB,CAAC;QAC5F,IAAI,CAAC,0BAA0B,GAAG,OAAO,CAAC,WAAW,CAAC,mBAAmB,KAAK,mBAAmB;eAC1F,CAAC,CAAC,OAAO,CAAC,WAAW,CAAC,qCAAqC,CAAC;QAEnE,IAAI,CAAC,2BAA2B,GAAG,aAAa,CAAC,uBAAuB,CAAC,OAAO,CAAC,YAAY,CAAC,CAAC;QAE/F,IAAI,CAAC,SAAS,GAAG,OAAO,CAAC,SAAS,CAAC;IACvC,CAAC;IAEM,qBAAqB;QACxB,IAAI,CAAC,QAAQ,CAAC,qBAAqB,EAAE,CAAC;IAC1C,CAAC;IAEM,UAAU,CAAC,UAAkB;QAChC,IAAI,0BAAU,CAAC,kBAAkB,CAAC,UAAU,CAAC,EAAE,CAAC;YAC5C,IAAA,qBAAU,EAAC,0BAA0B,EAAE,2CAA2C,CAAC,CAAC;QACxF,CAAC;QAED,IAAI,CAAC,mBAAmB,CAAC,UAAU,CAAC,CAAC;QAErC,IAAI,CAAC,0BAA0B,GAAG,IAAI,CAAC,0BAA0B;eAC1D,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC,mBAAmB,KAAK,mBAAmB,CAAC;IAEjF,CAAC;IAEO,mBAAmB,CAAC,UAAkB;QAC1C,IAAI,IAAI,CAAC,cAAc,EAAE,CAAC;YACtB,IAAA,qBAAU,EAAC,2BAA2B,EAClC,oEAAoE;gBACpE,iEAAiE,CAAC,CAAC;QAC3E,CAAC;QAED,IAAI,CAAC,UAAU,EAAE,CAAC;YACd,IAAI,CAAC,UAAU,GAAG,EAAE,WAAW,CAAC,uBAAuB,CAAC;QAC5D,CAAC;aAAM,CAAC;YACJ,MAAM,IAAI,GAAG,IAAI,kCAAc,EAAE,CAAC;YAClC,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC;YACvB,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,wBAAwB,CAAC,CAAC;YAC1C,MAAM,MAAM,GAAG,oBAAM,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC,CAAC;YAC3C,IAAI,CAAC,UAAU,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;QACvE,CAAC;IACL,CAAC;IAEM,KAAK,CAAC,qBAAqB,CAAC,eAAgC;QAC/D,IAAI,MAA2B,CAAC;QAEhC,IAAI,eAAe,CAAC,WAAW,CAAC,mBAAmB,KAAK,mBAAmB,EAAE,CAAC;YAC1E,IAAI,IAAI,CAAC,0BAA0B,EAAE,CAAC;gBAClC,MAAM,GAAG,MAAM,eAAe,CAAC,kBAAkB,CAAC,IAAI,CAAC,YAAY,EAAE,CAAC,CAAC;YAC3E,CAAC;QACL,CAAC;QAED,QAAQ,eAAe,CAAC,WAAW,CAAC,mBAAmB,EAAE,CAAC;YACtD,KAAK,MAAM,CAAC,CAAC,CAAC;gBACV,MAAM,GAAG,MAAM,eAAe,CAAC,gBAAgB,EAAE,CAAC;gBAClD,MAAM;YACV,CAAC;YACD,KAAK,YAAY,CAAC,CAAC,CAAC;gBAChB,MAAM,GAAG,MAAM,eAAe,CAAC,kBAAkB,CAAC,IAAI,CAAC,YAAY,EAAE,CAAC,CAAC;gBACvE,MAAM;YACV,CAAC;YACD,KAAK,aAAa,CAAC,CAAC,CAAC;gBACjB,MAAM,GAAG,MAAM,eAAe,CAAC,cAAc,EAAE,CAAC;gBAChD,MAAM;YACV,CAAC;YACD,OAAO,CAAC,CAAC,CAAC;gBACN,IAAA,qBAAU,EAAC,0BAA0B,EAAE,eAAe,CAAC,WAAW,CAAC,mBAAmB,CAAC,CAAC;YAC5F,CAAC;QACL,CAAC;QAED,OAAO,MAAM,CAAC,WAAW,CAAC;IAC9B,CAAC;IAEM,YAAY;QACf,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE,CAAC;YACnB,IAAI,OAAe,CAAC;YACpB,MAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC,qCAAqC,CAAC;YACjF,IAAI,QAAQ,EAAE,CAAC;gBACX,OAAO,GAAG,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC,CAAC;YACnD,CAAC;YAED,IAAI,CAAC,mBAAmB,CAAC,OAAO,CAAC,CAAC;QACtC,CAAC;QAED,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC;QAC3B,OAAO,IAAI,CAAC,UAAU,CAAC;IAC3B,CAAC;IAEM,yBAAyB;QAC5B,OAAO,IAAI,CAAC,0BAA0B,CAAC;IAC3C,CAAC;;AAhHL,kCAiHC","sourcesContent":["import { Lazy } from \"../Lazy.js\";\r\nimport { DocumentConventions } from \"../Conventions/DocumentConventions.js\";\r\nimport { IDisposable } from \"../../Types/Contracts.js\";\r\nimport { DocumentType } from \"../DocumentAbstractions.js\";\r\nimport { ClassConstructor, EntitiesCollectionObject, ObjectTypeDescriptor } from \"../../Types/index.js\";\r\nimport { IAdvancedSessionOperations } from \"./IAdvancedSessionOperations.js\";\r\nimport { ILoaderWithInclude } from \"./Loaders/ILoaderWithInclude.js\";\r\nimport { DocumentQueryOptions } from \"./QueryOptions.js\";\r\nimport { IDocumentQuery } from \"./IDocumentQuery.js\";\r\nimport { IIncludeBuilder } from \"./Loaders/IIncludeBuilder.js\";\r\nimport { ISessionDocumentCounters } from \"./ISessionDocumentCounters.js\";\r\nimport { ISessionDocumentTimeSeries } from \"./ISessionDocumentTimeSeries.js\";\r\nimport { ISessionDocumentTypedTimeSeries } from \"./ISessionDocumentTypedTimeSeries.js\";\r\nimport { ISessionDocumentRollupTypedTimeSeries } from \"./ISessionDocumentRollupTypedTimeSeries.js\";\r\nimport { InMemoryDocumentSessionOperations } from \"./InMemoryDocumentSessionOperations.js\";\r\nimport { SessionOptions } from \"./SessionOptions.js\";\r\nimport { throwError } from \"../../Exceptions/index.js\";\r\nimport { StringUtil } from \"../../Utility/StringUtil.js\";\r\nimport CurrentIndexAndNode from \"../../Http/CurrentIndexAndNode.js\";\r\nimport { HashCalculator } from \"../Queries/HashCalculator.js\";\r\nimport { DocumentStoreBase } from \"../DocumentStoreBase.js\";\r\nimport { RequestExecutor } from \"../../Http/RequestExecutor.js\";\r\nimport { AbstractCommonApiForIndexes } from \"../Indexes/AbstractCommonApiForIndexes.js\";\r\nimport { AbstractTimeSeriesRange } from \"../Operations/TimeSeries/AbstractTimeSeriesRange.js\";\r\nimport { ISessionDocumentTypedIncrementalTimeSeries } from \"./ISessionDocumentTypedIncrementalTimeSeries.js\";\r\nimport { ISessionDocumentIncrementalTimeSeries } from \"./ISessionDocumentIncrementalTimeSeries.js\";\r\nimport { Buffer } from \"node:buffer\";\r\n\r\nexport class SessionInfo {\r\n    private static _clientSessionIdCounter: number = 0;\r\n\r\n    private _sessionId: number;\r\n    private _sessionIdUsed: boolean;\r\n    private readonly _loadBalancerContextSeed: number;\r\n    private _canUseLoadBalanceBehavior: boolean;\r\n    private readonly _session: InMemoryDocumentSessionOperations;\r\n\r\n    public lastClusterTransactionIndex: number;\r\n    public noCaching: boolean;\r\n\r\n    public constructor(session: InMemoryDocumentSessionOperations, options: SessionOptions, documentStore: DocumentStoreBase) {\r\n        if (!documentStore) {\r\n            throwError(\"InvalidArgumentException\", \"DocumentStore cannot be null\");\r\n        }\r\n\r\n        if (!session) {\r\n            throwError(\"InvalidArgumentException\", \"Session cannot be null\");\r\n        }\r\n\r\n        this._session = session;\r\n        this._loadBalancerContextSeed = session.requestExecutor.conventions.loadBalancerContextSeed;\r\n        this._canUseLoadBalanceBehavior = session.conventions.loadBalanceBehavior === \"UseSessionContext\"\r\n            && !!session.conventions.loadBalancerPerSessionContextSelector;\r\n\r\n        this.lastClusterTransactionIndex = documentStore.getLastTransactionIndex(session.databaseName);\r\n\r\n        this.noCaching = options.noCaching;\r\n    }\r\n\r\n    public incrementRequestCount(): void {\r\n        this._session.incrementRequestCount();\r\n    }\r\n\r\n    public setContext(sessionKey: string) {\r\n        if (StringUtil.isNullOrWhitespace(sessionKey)) {\r\n            throwError(\"InvalidArgumentException\", \"Session key cannot be null or whitespace.\");\r\n        }\r\n\r\n        this._setContextInternal(sessionKey);\r\n\r\n        this._canUseLoadBalanceBehavior = this._canUseLoadBalanceBehavior\r\n            || this._session.conventions.loadBalanceBehavior === \"UseSessionContext\";\r\n\r\n    }\r\n\r\n    private _setContextInternal(sessionKey: string) {\r\n        if (this._sessionIdUsed) {\r\n            throwError(\"InvalidOperationException\",\r\n                \"Unable to set the session context after it has already been used. \" +\r\n                \"The session context can only be modified before it is utilized.\");\r\n        }\r\n\r\n        if (!sessionKey) {\r\n            this._sessionId = ++SessionInfo._clientSessionIdCounter;\r\n        } else {\r\n            const hash = new HashCalculator();\r\n            hash.write(sessionKey);\r\n            hash.write(this._loadBalancerContextSeed);\r\n            const buffer = Buffer.from(hash.getHash());\r\n            this._sessionId = (buffer[0] << 16) + (buffer[1] << 8) + buffer[2];\r\n        }\r\n    }\r\n\r\n    public async getCurrentSessionNode(requestExecutor: RequestExecutor) {\r\n        let result: CurrentIndexAndNode;\r\n\r\n        if (requestExecutor.conventions.loadBalanceBehavior === \"UseSessionContext\") {\r\n            if (this._canUseLoadBalanceBehavior) {\r\n                result = await requestExecutor.getNodeBySessionId(this.getSessionId());\r\n            }\r\n        }\r\n\r\n        switch (requestExecutor.conventions.readBalanceBehavior) {\r\n            case \"None\": {\r\n                result = await requestExecutor.getPreferredNode();\r\n                break;\r\n            }\r\n            case \"RoundRobin\": {\r\n                result = await requestExecutor.getNodeBySessionId(this.getSessionId());\r\n                break;\r\n            }\r\n            case \"FastestNode\": {\r\n                result = await requestExecutor.getFastestNode();\r\n                break;\r\n            }\r\n            default: {\r\n                throwError(\"InvalidArgumentException\", requestExecutor.conventions.readBalanceBehavior);\r\n            }\r\n        }\r\n\r\n        return result.currentNode;\r\n    }\r\n\r\n    public getSessionId(): number {\r\n        if (!this._sessionId) {\r\n            let context: string;\r\n            const selector = this._session.conventions.loadBalancerPerSessionContextSelector;\r\n            if (selector) {\r\n                context = selector(this._session.databaseName);\r\n            }\r\n\r\n            this._setContextInternal(context);\r\n        }\r\n\r\n        this._sessionIdUsed = true;\r\n        return this._sessionId;\r\n    }\r\n\r\n    public canUseLoadBalanceBehavior() {\r\n        return this._canUseLoadBalanceBehavior;\r\n    }\r\n}\r\n\r\nexport type ConcurrencyCheckMode = \"Auto\" | \"Forced\" | \"Disabled\";\r\n\r\nexport interface IDocumentSession extends IDisposable {\r\n\r\n    /**\r\n     * Get the accessor for advanced operations\r\n     *\r\n     * Those operations are rarely needed, and have been moved to a separate\r\n     * property to avoid cluttering the API\r\n     */\r\n    advanced: IAdvancedSessionOperations;\r\n\r\n    /**\r\n     * Loads entity with the specified id.\r\n     */\r\n    load<TEntity extends object>(id: string): Promise<TEntity | null>;\r\n\r\n    /**\r\n     * Loads the entity with the specified id.\r\n     */\r\n    load<TEntity extends object>(id: string, documentType?: DocumentType<TEntity>): Promise<TEntity | null>;\r\n\r\n    /**\r\n     * Loads the entity with the specified id.\r\n     */\r\n    load<TEntity extends object>(id: string, options?: LoadOptions<TEntity>): Promise<TEntity | null>;\r\n\r\n    /**\r\n     * Loads multiple entities with the specified ids.\r\n     */\r\n    load<TEntity extends object>(ids: string[]): Promise<EntitiesCollectionObject<TEntity>>;\r\n\r\n    /**\r\n     * Loads multiple entities with the specified ids.\r\n     */\r\n    load<TEntity extends object>(ids: string[], documentType?: DocumentType<TEntity>):\r\n        Promise<EntitiesCollectionObject<TEntity>>;\r\n\r\n    /**\r\n     * Loads multiple entities with the specified ids.\r\n     */\r\n    load<TEntity extends object>(ids: string[], options?: LoadOptions<TEntity>):\r\n        Promise<EntitiesCollectionObject<TEntity>>;\r\n\r\n    /**\r\n     * Marks the specified entity for deletion. The entity will be deleted when DocumentSession.saveChanges is called.\r\n     * WARNING: This method will not emit beforeDelete event!\r\n     */\r\n    delete<TEntity extends object>(\r\n        id: string): Promise<void>;\r\n\r\n    /**\r\n     * Marks the specified entity for deletion. The entity will be deleted when DocumentSession.saveChanges is called.\r\n     * WARNING: This method will not emit beforeDelete event!\r\n     */\r\n    delete<TEntity extends object>(\r\n        id: string, expectedChangeVector: string): Promise<void>;\r\n\r\n    /**\r\n     * Marks the specified entity for deletion. The entity will be deleted when IDocumentSession.saveChanges is called.\r\n     */\r\n    delete<TEntity extends object>(\r\n        entity: TEntity): Promise<void>;\r\n\r\n    /**\r\n     * Stores entity in session, extracts Id from entity using Conventions or generates new one if it is not available.\r\n     * Forces concurrency check if the Id is not available during extraction.\r\n     */\r\n    store<TEntity extends object>(document: TEntity): Promise<void>;\r\n\r\n    /**\r\n     * Stores the specified dynamic entity, under the specified id.\r\n     */\r\n    store<TEntity extends object>(document: TEntity, id?: string): Promise<void>;\r\n\r\n    /**\r\n     * Stores the specified dynamic entity, under the specified id.\r\n     */\r\n    store<TEntity extends object>(document: TEntity, id?: string, documentType?: DocumentType<TEntity>): Promise<void>;\r\n\r\n    /**\r\n     * Stores entity in session with given id and forces concurrency check with given change-vector (see options).\r\n     */\r\n    store<TEntity extends object>(document: TEntity, id?: string, options?: StoreOptions<TEntity>): Promise<void>;\r\n\r\n    /**\r\n     * Begin a load while including the specified path\r\n     * Path in documents in which server should look for a 'referenced' documents.\r\n     */\r\n    include(path: string): ILoaderWithInclude;\r\n\r\n    /**\r\n     * Saves all the pending changes to the server.\r\n     */\r\n    saveChanges(): Promise<void>;\r\n\r\n    /**\r\n     * Queries collection or index.\r\n     */\r\n    query<T extends object>(opts: DocumentQueryOptions<T>): IDocumentQuery<T>;\r\n\r\n    /**\r\n     * Queries collection. Collection name is determined from documentType using document store conventions.\r\n     */\r\n    query<T extends object>(documentType: DocumentType<T>): IDocumentQuery<T>;\r\n\r\n    query<T extends object>(documentType: DocumentType<T>, index: new () => AbstractCommonApiForIndexes): IDocumentQuery<T>;\r\n\r\n    countersFor(documentId: string): ISessionDocumentCounters;\r\n\r\n    countersFor(entity: object): ISessionDocumentCounters;\r\n\r\n\r\n    timeSeriesFor(documentId: string, name: string): ISessionDocumentTimeSeries;\r\n    timeSeriesFor(entity:any, name: string): ISessionDocumentTimeSeries;\r\n\r\n    timeSeriesFor<T extends object>(documentId: string, clazz: ObjectTypeDescriptor<T>): ISessionDocumentTypedTimeSeries<T>;\r\n    timeSeriesFor<T extends object>(documentId: string, name: string, clazz: ObjectTypeDescriptor<T>): ISessionDocumentTypedTimeSeries<T>;\r\n    timeSeriesFor<T extends object>(entity: object, clazz: ObjectTypeDescriptor<T>): ISessionDocumentTypedTimeSeries<T>;\r\n    timeSeriesFor<T extends object>(entity: object, name: string, clazz: ObjectTypeDescriptor<T>): ISessionDocumentTypedTimeSeries<T>;\r\n\r\n    timeSeriesRollupFor<T extends object>(entity: object, policy: string, clazz: ClassConstructor<T>): ISessionDocumentRollupTypedTimeSeries<T>;\r\n    timeSeriesRollupFor<T extends object>(entity: object, policy: string, raw: string, clazz: ClassConstructor<T>): ISessionDocumentRollupTypedTimeSeries<T>;\r\n    timeSeriesRollupFor<T extends object>(documentId: string, policy: string, clazz: ClassConstructor<T>): ISessionDocumentRollupTypedTimeSeries<T>;\r\n    timeSeriesRollupFor<T extends object>(documentId: string, policy: string, raw: string, clazz: ClassConstructor<T>): ISessionDocumentRollupTypedTimeSeries<T>;\r\n\r\n    incrementalTimeSeriesFor(documentId: string, name: string): ISessionDocumentIncrementalTimeSeries;\r\n    incrementalTimeSeriesFor(entity: object, name: string): ISessionDocumentIncrementalTimeSeries;\r\n\r\n    incrementalTimeSeriesFor<T extends object>(documentId: string, clazz: ObjectTypeDescriptor<T>): ISessionDocumentTypedIncrementalTimeSeries<T>;\r\n    incrementalTimeSeriesFor<T extends object>(documentId: string, name: string, clazz: ObjectTypeDescriptor<T>): ISessionDocumentTypedIncrementalTimeSeries<T>;\r\n    incrementalTimeSeriesFor<T extends object>(entity: object, clazz: ObjectTypeDescriptor<T>): ISessionDocumentTypedIncrementalTimeSeries<T>;\r\n    incrementalTimeSeriesFor<T extends object>(entity: object, name: string, clazz: ObjectTypeDescriptor<T>): ISessionDocumentTypedIncrementalTimeSeries<T>;\r\n}\r\n\r\n/**\r\n * session.store() options\r\n */\r\nexport interface StoreOptions<T extends object> {\r\n    /**\r\n     * Type of document being stored\r\n     */\r\n    documentType?: DocumentType<T>;\r\n\r\n    /**\r\n     * Change vector used for forcing concurrency check.\r\n     */\r\n    changeVector?: string;\r\n}\r\n\r\n/**\r\n * session.load() options\r\n */\r\nexport interface LoadOptions<T extends object> {\r\n    /**\r\n     * Type of document to load\r\n     */\r\n    documentType?: DocumentType<T>;\r\n\r\n    /**\r\n     * Ids of included documents\r\n     */\r\n    includes?: string[] | ((includesBuilder: IIncludeBuilder) => void);\r\n\r\n    /**\r\n     * Expected change vector\r\n     */\r\n    expectedChangeVector?: string;\r\n}\r\n\r\nexport interface SessionLoadStartingWithOptions<T extends object> extends StartingWithOptions {\r\n    matches?: string;\r\n    start?: number;\r\n    pageSize?: number;\r\n    exclude?: string;\r\n    startAfter?: string;\r\n    documentType?: DocumentType<T>;\r\n    streamResults?: boolean;\r\n}\r\n\r\nexport interface StartingWithOptions {\r\n    matches?: string;\r\n    start?: number;\r\n    pageSize?: number;\r\n    exclude?: string;\r\n    startAfter?: string;\r\n}\r\n\r\nexport interface SessionLoadInternalParameters<TResult extends object> {\r\n    includes?: string[];\r\n    documentType?: DocumentType<TResult>;\r\n    counterIncludes?: string[];\r\n    includeAllCounters?: boolean;\r\n    timeSeriesIncludes?: AbstractTimeSeriesRange[];\r\n    compareExchangeValueIncludes?: string[];\r\n    revisionIncludesByChangeVector?: string[];\r\n    revisionsToIncludeByDateTime?: Date;\r\n}\r\n\r\nexport interface IDocumentSessionImpl extends IDocumentSession {\r\n\r\n    conventions: DocumentConventions;\r\n\r\n    loadInternal<TResult extends object>(\r\n        ids: string[], opts: SessionLoadInternalParameters<TResult>):\r\n        Promise<EntitiesCollectionObject<TResult>>;\r\n\r\n    lazyLoadInternal<TResult extends object>(\r\n        ids: string[],\r\n        includes: string[],\r\n        clazz: ObjectTypeDescriptor<TResult>): Lazy<EntitiesCollectionObject<TResult>>;\r\n}\r\n"]}