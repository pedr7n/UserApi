import { Lazy } from "../Lazy.js";
import { QueryOperation } from "./Operations/QueryOperation.js";
import { HighlightingToken } from "./Tokens/HighlightingToken.js";
import { FieldsToFetchToken } from "./Tokens/FieldsToFetchToken.js";
import { DeclareToken } from "./Tokens/DeclareToken.js";
import { LoadToken } from "./Tokens/LoadToken.js";
import { FromToken } from "./Tokens/FromToken.js";
import { InMemoryDocumentSessionOperations } from "./InMemoryDocumentSessionOperations.js";
import { QueryStatistics } from "./QueryStatistics.js";
import { IDocumentSession } from "./IDocumentSession.js";
import { QueryOperator } from "../Queries/QueryOperator.js";
import { IndexQuery } from "../Queries/IndexQuery.js";
import { IAbstractDocumentQuery } from "./IAbstractDocumentQuery.js";
import { GroupBy } from "../Queries/GroupBy.js";
import { ExplanationToken } from "../Session/Tokens/ExplanationToken.js";
import { QueryToken } from "./Tokens/QueryToken.js";
import { WhereParams } from "./WhereParams.js";
import { MethodCall } from "./MethodCall.js";
import { CounterIncludesToken } from "./Tokens/CounterIncludesToken.js";
import { QueryResult } from "../Queries/QueryResult.js";
import { DocumentType } from "../DocumentAbstractions.js";
import { QueryEventsEmitter } from "./QueryEvents.js";
import { EventEmitter } from "node:events";
import { DocumentConventions } from "../Conventions/DocumentConventions.js";
import { OrderingType } from "./OrderingType.js";
import { SearchOperator } from "../Queries/SearchOperator.js";
import { SpatialRelation, SpatialUnits } from "../Indexes/Spatial.js";
import { DynamicSpatialField } from "../Queries/Spatial/DynamicSpatialField.js";
import { SpatialCriteria } from "../Queries/Spatial/SpatialCriteria.js";
import { ValueCallback } from "../../Types/Callbacks.js";
import { FacetBase } from "../Queries/Facets/FacetBase.js";
import { MoreLikeThisScope } from "../Queries/MoreLikeThis/MoreLikeThisScope.js";
import { LazyQueryOperation } from "../Session/Operations/Lazy/LazyQueryOperation.js";
import { SuggestionBase } from "../Queries/Suggestions/SuggestionBase.js";
import { QueryData } from "../Queries/QueryData.js";
import { QueryTimings } from "../Queries/Timings/QueryTimings.js";
import { Explanations } from "../Queries/Explanation/Explanations.js";
import { Highlightings } from "../Queries/Highlighting/Hightlightings.js";
import { HighlightingParameters } from "../Queries/Highlighting/HighlightingParameters.js";
import { QueryHighlightings } from "../Queries/Highlighting/QueryHighlightings.js";
import { ExplanationOptions } from "../Queries/Explanation/ExplanationOptions.js";
import { CountersByDocId } from "./CounterInternalTypes.js";
import { IncludeBuilderBase } from "./Loaders/IncludeBuilderBase.js";
import { TimeSeriesIncludesToken } from "./Tokens/TimeSeriesIncludesToken.js";
import { CompareExchangeValueIncludesToken } from "./Tokens/CompareExchangeValueIncludesToken.js";
import { ITimeSeriesQueryBuilder } from "../Queries/TimeSeries/ITimeSeriesQueryBuilder.js";
import { ProjectionBehavior } from "../Queries/ProjectionBehavior.js";
import { IAbstractDocumentQueryImpl } from "./IAbstractDocumentQueryImpl.js";
import { RevisionIncludesToken } from "./Tokens/RevisionIncludesToken.js";
import { IDisposable } from "../../Types/Contracts.js";
import { IQueryShardedContextBuilder } from "./Querying/Sharding/IQueryShardedContextBuilder.js";
import { IVectorOptions } from "../Queries/VectorSearch/VectorSearchOptions.js";
import { IVectorEmbeddingField, IVectorEmbeddingTextField, IVectorField, IVectorFieldFactory, IVectorFieldValueFactory } from "./VectorFieldFactory.js";
import { Field } from "../../Types/index.js";
/**
 * A query against a Raven index
 */
export declare abstract class AbstractDocumentQuery<T extends object, TSelf extends AbstractDocumentQuery<T, TSelf>> extends EventEmitter implements QueryEventsEmitter, IAbstractDocumentQuery<T>, IAbstractDocumentQueryImpl<T> {
    protected _clazz: DocumentType<T>;
    private _aliasToGroupByFieldName;
    protected _defaultOperator: QueryOperator;
    protected _rootTypes: Set<DocumentType>;
    /**
     * Whether to negate the next operation
     */
    protected _negate: boolean;
    /**
     * Whether to negate the next operation in Filter
     */
    protected _negateFilter: boolean;
    private readonly _indexName;
    private readonly _collectionName;
    private _currentClauseDepth;
    protected _queryRaw: string;
    get indexName(): string;
    get collectionName(): string;
    protected _filterModeStack: boolean[];
    protected _queryParameters: {
        [key: string]: any;
    };
    protected _isIntersect: boolean;
    protected _isGroupBy: boolean;
    protected _theSession: InMemoryDocumentSessionOperations;
    protected _pageSize: number;
    protected _selectTokens: QueryToken[];
    protected _fromToken: FromToken;
    protected _declareTokens: DeclareToken[];
    protected _loadTokens: LoadToken[];
    fieldsToFetchToken: FieldsToFetchToken;
    _isProjectInto: boolean;
    protected _whereTokens: QueryToken[];
    protected _groupByTokens: QueryToken[];
    protected _orderByTokens: QueryToken[];
    protected _withTokens: QueryToken[];
    protected _filterTokens: QueryToken[];
    protected _start: number;
    private readonly _conventions;
    /**
     * Limits filter clause.
     */
    protected _filterLimit: number;
    protected _timeout: number;
    protected _theWaitForNonStaleResults: boolean;
    protected _documentIncludes: Set<string>;
    private _statsCallback;
    /**
     * Holds the query stats
     */
    protected _queryStats: QueryStatistics;
    protected _disableEntitiesTracking: boolean;
    protected _disableCaching: boolean;
    protected projectionBehavior: ProjectionBehavior;
    private _parameterPrefix;
    private _includesAlias;
    protected _highlightingTokens: HighlightingToken[];
    protected _queryHighlightings: QueryHighlightings;
    protected _queryTimings: QueryTimings;
    protected _explanations: Explanations;
    protected _explanationToken: ExplanationToken;
    protected isFilterActive(): boolean;
    get isDistinct(): boolean;
    get theWaitForNonStaleResults(): boolean;
    get timeout(): number;
    get queryParameters(): {
        [key: string]: any;
    };
    get selectTokens(): QueryToken[];
    get isProjectInto(): boolean;
    set isProjectInto(value: boolean);
    /**
     * Gets the document convention from the query session
     */
    get conventions(): DocumentConventions;
    /**
     * Gets the session associated with this document query
     */
    get session(): IDocumentSession;
    isDynamicMapReduce(): boolean;
    private _isInMoreLikeThis;
    private _getDefaultTimeout;
    protected constructor(clazz: DocumentType<T>, session: InMemoryDocumentSessionOperations, indexName: string, collectionName: string, isGroupBy: boolean, declareTokens: DeclareToken[], loadTokens: LoadToken[]);
    protected constructor(clazz: DocumentType<T>, session: InMemoryDocumentSessionOperations, indexName: string, collectionName: string, isGroupBy: boolean, declareTokens: DeclareToken[], loadTokens: LoadToken[], fromAlias: string, isProjectInto: boolean);
    private _assertMethodIsCurrentlySupported;
    private _getCurrentWhereTokens;
    private _ensureValidFieldName;
    private _appendOperatorIfNeeded;
    private _transformCollection;
    private _negateIfNeeded;
    _usingDefaultOperator(operator: any): void;
    /**
     * Instruct the query to wait for non stale result for the specified wait timeout.
     * This shouldn't be used outside of unit tests unless you are well aware of the implications
     */
    _waitForNonStaleResults(waitTimeout?: number): void;
    protected _getLazyQueryOperation(): LazyQueryOperation<T>;
    initializeQueryOperation(): QueryOperation;
    private _transformValue;
    private _stringifyParameter;
    private _addQueryParameter;
    protected static _getSourceAliasIfExists<TResult extends object>(documentType: DocumentType<TResult>, queryData: QueryData, fields: string[], sourceAlias: (value: string) => void): void;
    protected _createTimeSeriesQueryData(timeSeriesQuery: (builder: ITimeSeriesQueryBuilder) => void): QueryData;
    _addFilterLimit(filterLimit: number): void;
    private _getCurrentOrderByTokens;
    private _getCurrentFilterTokens;
    protected _updateFieldsToFetchToken(fieldsToFetch: FieldsToFetchToken): void;
    getIndexQuery(): IndexQuery;
    /**
     * Gets the fields for projection
     */
    getProjectionFields(): string[];
    /**
     * Order the search results randomly using the specified seed
     * this is useful if you want to have repeatable random queries
     */
    _randomOrdering(): void;
    /**
     * Order the search results randomly using the specified seed
     * this is useful if you want to have repeatable random queries
     */
    _randomOrdering(seed?: string): void;
    _projection(projectionBehavior: ProjectionBehavior): void;
    _shardContext(action: (builder: IQueryShardedContextBuilder) => void): void;
    protected addGroupByAlias(fieldName: string, projectedName: string): void;
    private _assertNoRawQuery;
    addParameter(name: string, value: any): void;
    _groupBy(fieldName: string, ...fieldNames: string[]): void;
    _groupBy(field: GroupBy, ...fields: GroupBy[]): void;
    _groupByKey(fieldName: string): void;
    _groupByKey(fieldName: string, projectedName: string): void;
    _groupBySum(fieldName: string): void;
    _groupBySum(fieldName: string, projectedName: string): void;
    _groupByCount(): void;
    _groupByCount(projectedName: string): void;
    _whereTrue(): void;
    _moreLikeThis(): MoreLikeThisScope;
    /**
     * Includes the specified path in the query, loading the document specified in that path
     */
    _include(path: string): void;
    _include(includes: IncludeBuilderBase): void;
    _take(count: number): void;
    _skip(count: number): void;
    /**
     * Filter the results from the index using the specified where clause.
     */
    _whereLucene(fieldName: string, whereClause: string, exact: boolean): void;
    /**
     * Simplified method for opening a new clause within the query
     */
    _openSubclause(): void;
    /**
     * Simplified method for closing a clause within the query
     */
    _closeSubclause(): void;
    _whereEquals(fieldName: string, method: MethodCall): void;
    _whereEquals(fieldName: string, method: MethodCall, exact: boolean): void;
    _whereEquals(fieldName: string, value: any): void;
    _whereEquals(fieldName: string, value: any, exact: boolean): void;
    _whereEquals(whereParams: WhereParams): void;
    private _ifValueIsMethod;
    _whereNotEquals(fieldName: string, value: any): void;
    _whereNotEquals(fieldName: string, value: any, exact: boolean): void;
    _whereNotEquals(fieldName: string, method: MethodCall): void;
    _whereNotEquals(fieldName: string, method: MethodCall, exact: boolean): void;
    _whereNotEquals(whereParams: WhereParams): void;
    _negateNext(): void;
    /**
     * Check that the field has one of the specified value
     */
    _whereIn(fieldName: string, values: any[]): void;
    /**
     * Check that the field has one of the specified value
     */
    _whereIn(fieldName: string, values: any[], exact: boolean): void;
    _whereStartsWith(fieldName: string, value: any, exact?: boolean): void;
    /**
     * Matches fields which ends with the specified value.
     */
    _whereEndsWith(fieldName: string, value: any, exact?: boolean): void;
    /**
     * Matches fields where the value is between the specified start and end, inclusive
     */
    _whereBetween(fieldName: string, start: any, end: any): void;
    /**
     * Matches fields where the value is between the specified start and end, inclusive
     */
    _whereBetween(fieldName: string, start: any, end: any, exact: boolean): void;
    /**
     * Matches fields where the value is greater than the specified value
     */
    _whereGreaterThan(fieldName: string, value: any): void;
    /**
     * Matches fields where the value is greater than the specified value
     */
    _whereGreaterThan(fieldName: string, value: any, exact: boolean): void;
    /**
     * Matches fields where the value is greater than or equal to the specified value
     */
    _whereGreaterThanOrEqual(fieldName: string, value: any): void;
    /**
     * Matches fields where the value is greater than or equal to the specified value
     */
    _whereGreaterThanOrEqual(fieldName: string, value: any, exact: boolean): void;
    _whereLessThan(fieldName: string, value: any): void;
    _whereLessThan(fieldName: string, value: any, exact: boolean): void;
    _whereLessThanOrEqual(fieldName: string, value: any): void;
    _whereLessThanOrEqual(fieldName: string, value: any, exact: boolean): void;
    /**
     * Matches fields where Regex.IsMatch(filedName, pattern)
     */
    _whereRegex(fieldName: string, pattern: string): void;
    _andAlso(wrapPreviousQueryClauses?: boolean): void;
    /**
     * Add an OR to the query
     */
    _orElse(): void;
    setFilterMode(on: boolean): IDisposable;
    /**
     * Specifies a boost weight to the previous where clause.
     * The higher the boost factor, the more relevant the term will be.
     * <p>
     * boosting factor where 1.0 is default, less than 1.0 is lower weight, greater than 1.0 is higher weight
     * <p>
     * http://lucene.apache.org/java/2_4_0/queryparsersyntax.html#Boosting%20a%20Term
     */
    _boost(boost: number): void;
    /**
     * Specifies a fuzziness factor to the single word term in the last where clause
     * <p>
     * 0.0 to 1.0 where 1.0 means closer match
     * <p>
     * https://lucene.apache.org/core/2_9_4/queryparsersyntax.html#Fuzzy%20Searches
     */
    _fuzzy(fuzzy: number): void;
    /**
     * Specifies a proximity distance for the phrase in the last search clause
     * <p>
     * https://lucene.apache.org/core/2_9_4/queryparsersyntax.html#Proximity%20Searches
     */
    _proximity(proximity: number): void;
    /**
     * Order the results by the specified fields
     * The fields are the names of the fields to sort, defaulting to sorting by ascending.
     * You can prefix a field name with '-' to indicate sorting by descending or '+' to sort by ascending
     */
    _orderBy(field: string): void;
    /**
     * Order the results by the specified fields
     * The fields are the names of the fields to sort, defaulting to sorting by ascending.
     * You can prefix a field name with '-' to indicate sorting by descending or '+' to sort by ascending
     */
    _orderBy(field: string, ordering: OrderingType): void;
    _orderBy(field: string, options: {
        sorterName: string;
    }): any;
    /**
     * Order the results by the specified fields
     * The fields are the names of the fields to sort, defaulting to sorting by descending.
     * You can prefix a field name with '-' to indicate sorting by descending or '+' to sort by ascending
     */
    _orderByDescending(field: string): void;
    /**
     * Order the results by the specified fields
     * The fields are the names of the fields to sort, defaulting to sorting by descending.
     * You can prefix a field name with '-' to indicate sorting by descending or '+' to sort by ascending
     */
    _orderByDescending(field: string, ordering: OrderingType): void;
    _orderByDescending(field: string, options: {
        sorterName: string;
    }): any;
    _orderByScore(): void;
    _orderByScoreDescending(): void;
    /**
     * Provide statistics about the query, such as total count of matching records
     */
    _statistics(statsCallback: (stats: QueryStatistics) => void): void;
    /**
     * Generates the index query.
     */
    protected _generateIndexQuery(query: string): IndexQuery;
    /**
     * Perform a search for documents which fields that match the searchTerms.
     * If there is more than a single term, each of them will be checked independently.
     */
    _search(fieldName: string, searchTerms: string): void;
    /**
     * Perform a search for documents which fields that match the searchTerms.
     * If there is more than a single term, each of them will be checked independently.
     */
    _search(fieldName: string, searchTerms: string, operator: SearchOperator): void;
    toString(compatibilityMode?: boolean): string;
    private _buildPagination;
    private _buildInclude;
    private _writeIncludeTokens;
    _intersect(): void;
    _whereExists(fieldName: string): void;
    _containsAny(fieldName: string, values: any[]): void;
    _containsAll(fieldName: string, values: any[]): void;
    addRootType(clazz: DocumentType): void;
    _distinct(): void;
    private _updateStatsAndHighlightingsAndExplanations;
    private _buildSelect;
    private _buildFrom;
    private _buildDeclare;
    private _buildLoad;
    private _buildWhere;
    private _buildGroupBy;
    private _buildFilter;
    private _buildOrderBy;
    private static _unpackCollection;
    protected _queryOperation: QueryOperation;
    queryOperation(): QueryOperation;
    _noTracking(): void;
    _noCaching(): void;
    _includeTimings(timingsCallback: (timings: QueryTimings) => void): void;
    _highlight(parameters: HighlightingParameters, highlightingsCallback: ValueCallback<Highlightings>): void;
    protected _withinRadiusOf(fieldName: string, radius: number, latitude: number, longitude: number, radiusUnits: SpatialUnits, distErrorPercent: number): void;
    protected _spatialByShapeWkt(fieldName: string, shapeWkt: string, relation: SpatialRelation, units: SpatialUnits, distErrorPercent: number): void;
    _spatial(dynamicField: DynamicSpatialField, criteria: SpatialCriteria): void;
    _spatial(fieldName: string, criteria: SpatialCriteria): void;
    _orderByDistance(field: DynamicSpatialField, latitude: number, longitude: number): void;
    _orderByDistance(field: DynamicSpatialField, shapeWkt: string): void;
    _orderByDistance(fieldName: string, latitude: number, longitude: number): void;
    _orderByDistance(fieldName: string, latitude: number, longitude: number, roundFactor: number): void;
    _orderByDistance(fieldName: string, shapeWkt: string): void;
    _orderByDistance(fieldName: string, shapeWkt: string, roundFactor: number): void;
    _orderByDistanceDescending(field: DynamicSpatialField, latitude: number, longitude: number): void;
    _orderByDistanceDescending(field: DynamicSpatialField, shapeWkt: string): void;
    _orderByDistanceDescending(fieldName: string, latitude: number, longitude: number): void;
    _orderByDistanceDescending(fieldName: string, latitude: number, longitude: number, roundFactor: number): void;
    _orderByDistanceDescending(fieldName: string, shapeWkt: string): void;
    _orderByDistanceDescending(fieldName: string, shapeWkt: string, roundFactor: number): void;
    private _assertIsDynamicQuery;
    protected _initSync(): Promise<void>;
    private _executeActualQuery;
    iterator(): Promise<IterableIterator<T>>;
    all(): Promise<T[]>;
    getQueryResult(): Promise<QueryResult>;
    first(): Promise<T>;
    firstOrNull(): Promise<T | null>;
    single(): Promise<T>;
    singleOrNull(): Promise<T | null>;
    count(): Promise<number>;
    private _executeQueryOperation;
    private _executeQueryOperationInternal;
    longCount(): Promise<number>;
    any(): Promise<boolean>;
    _aggregateBy(facet: FacetBase): void;
    _aggregateUsing(facetSetupDocumentId: string): void;
    lazily(): Lazy<T[]>;
    countLazily(): Lazy<number>;
    _suggestUsing(suggestion: SuggestionBase): void;
    private _getOptionsParameterName;
    private _assertCanSuggest;
    _includeExplanations(options: ExplanationOptions, explanationsCallback: ValueCallback<Explanations>): void;
    protected _timeSeriesIncludesTokens: TimeSeriesIncludesToken[];
    protected _counterIncludesTokens: CounterIncludesToken[];
    protected _compareExchangeValueIncludesTokens: CompareExchangeValueIncludesToken[];
    protected _revisionsIncludesTokens: RevisionIncludesToken[];
    protected _includeCounters(alias: string, counterToIncludeByDocId: CountersByDocId): void;
    private _includeTimeSeries;
    getQueryType(): DocumentType<T>;
    addFromAliasToWhereTokens(fromAlias: string): void;
    addFromAliasToOrderByTokens(fromAlias: string): void;
    addFromAliasToFilterTokens(fromAlias: string): void;
    private _addFromAliasToTokens;
    addAliasToIncludesTokens(fromAlias: string): string;
    private _includeRevisionsByDate;
    private _includeRevisionsByChangeVector;
    get parameterPrefix(): string;
    set parameterPrefix(prefix: string);
    /**
     * Performs a vector similarity search against a field containing vector embeddings
     * @param fieldName The field containing vector values or a field expression
     * @param valueOrFactory The query vector or a function that configures how to provide the vector value
     * @param options Additional vector search options
     */
    protected _vectorSearch(fieldName: Field<T> | ((factory: IVectorFieldFactory<T>) => IVectorField | IVectorEmbeddingField | IVectorEmbeddingTextField), valueOrFactory: number[] | string | ((factory: IVectorFieldValueFactory) => void), options?: IVectorOptions): void;
    private _resolveVectorSearchFieldAccessor;
    private _resolveVectorSearchValueFactory;
}
//# sourceMappingURL=AbstractDocumentQuery.d.ts.map