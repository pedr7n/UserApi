import { Lazy } from "../Lazy.js";
import { DocumentConventions } from "../Conventions/DocumentConventions.js";
import { IDisposable } from "../../Types/Contracts.js";
import { DocumentType } from "../DocumentAbstractions.js";
import { ClassConstructor, EntitiesCollectionObject, ObjectTypeDescriptor } from "../../Types/index.js";
import { IAdvancedSessionOperations } from "./IAdvancedSessionOperations.js";
import { ILoaderWithInclude } from "./Loaders/ILoaderWithInclude.js";
import { DocumentQueryOptions } from "./QueryOptions.js";
import { IDocumentQuery } from "./IDocumentQuery.js";
import { IIncludeBuilder } from "./Loaders/IIncludeBuilder.js";
import { ISessionDocumentCounters } from "./ISessionDocumentCounters.js";
import { ISessionDocumentTimeSeries } from "./ISessionDocumentTimeSeries.js";
import { ISessionDocumentTypedTimeSeries } from "./ISessionDocumentTypedTimeSeries.js";
import { ISessionDocumentRollupTypedTimeSeries } from "./ISessionDocumentRollupTypedTimeSeries.js";
import { InMemoryDocumentSessionOperations } from "./InMemoryDocumentSessionOperations.js";
import { SessionOptions } from "./SessionOptions.js";
import { DocumentStoreBase } from "../DocumentStoreBase.js";
import { RequestExecutor } from "../../Http/RequestExecutor.js";
import { AbstractCommonApiForIndexes } from "../Indexes/AbstractCommonApiForIndexes.js";
import { AbstractTimeSeriesRange } from "../Operations/TimeSeries/AbstractTimeSeriesRange.js";
import { ISessionDocumentTypedIncrementalTimeSeries } from "./ISessionDocumentTypedIncrementalTimeSeries.js";
import { ISessionDocumentIncrementalTimeSeries } from "./ISessionDocumentIncrementalTimeSeries.js";
export declare class SessionInfo {
    private static _clientSessionIdCounter;
    private _sessionId;
    private _sessionIdUsed;
    private readonly _loadBalancerContextSeed;
    private _canUseLoadBalanceBehavior;
    private readonly _session;
    lastClusterTransactionIndex: number;
    noCaching: boolean;
    constructor(session: InMemoryDocumentSessionOperations, options: SessionOptions, documentStore: DocumentStoreBase);
    incrementRequestCount(): void;
    setContext(sessionKey: string): void;
    private _setContextInternal;
    getCurrentSessionNode(requestExecutor: RequestExecutor): Promise<import("../../index.js").ServerNode>;
    getSessionId(): number;
    canUseLoadBalanceBehavior(): boolean;
}
export type ConcurrencyCheckMode = "Auto" | "Forced" | "Disabled";
export interface IDocumentSession extends IDisposable {
    /**
     * Get the accessor for advanced operations
     *
     * Those operations are rarely needed, and have been moved to a separate
     * property to avoid cluttering the API
     */
    advanced: IAdvancedSessionOperations;
    /**
     * Loads entity with the specified id.
     */
    load<TEntity extends object>(id: string): Promise<TEntity | null>;
    /**
     * Loads the entity with the specified id.
     */
    load<TEntity extends object>(id: string, documentType?: DocumentType<TEntity>): Promise<TEntity | null>;
    /**
     * Loads the entity with the specified id.
     */
    load<TEntity extends object>(id: string, options?: LoadOptions<TEntity>): Promise<TEntity | null>;
    /**
     * Loads multiple entities with the specified ids.
     */
    load<TEntity extends object>(ids: string[]): Promise<EntitiesCollectionObject<TEntity>>;
    /**
     * Loads multiple entities with the specified ids.
     */
    load<TEntity extends object>(ids: string[], documentType?: DocumentType<TEntity>): Promise<EntitiesCollectionObject<TEntity>>;
    /**
     * Loads multiple entities with the specified ids.
     */
    load<TEntity extends object>(ids: string[], options?: LoadOptions<TEntity>): Promise<EntitiesCollectionObject<TEntity>>;
    /**
     * Marks the specified entity for deletion. The entity will be deleted when DocumentSession.saveChanges is called.
     * WARNING: This method will not emit beforeDelete event!
     */
    delete<TEntity extends object>(id: string): Promise<void>;
    /**
     * Marks the specified entity for deletion. The entity will be deleted when DocumentSession.saveChanges is called.
     * WARNING: This method will not emit beforeDelete event!
     */
    delete<TEntity extends object>(id: string, expectedChangeVector: string): Promise<void>;
    /**
     * Marks the specified entity for deletion. The entity will be deleted when IDocumentSession.saveChanges is called.
     */
    delete<TEntity extends object>(entity: TEntity): Promise<void>;
    /**
     * Stores entity in session, extracts Id from entity using Conventions or generates new one if it is not available.
     * Forces concurrency check if the Id is not available during extraction.
     */
    store<TEntity extends object>(document: TEntity): Promise<void>;
    /**
     * Stores the specified dynamic entity, under the specified id.
     */
    store<TEntity extends object>(document: TEntity, id?: string): Promise<void>;
    /**
     * Stores the specified dynamic entity, under the specified id.
     */
    store<TEntity extends object>(document: TEntity, id?: string, documentType?: DocumentType<TEntity>): Promise<void>;
    /**
     * Stores entity in session with given id and forces concurrency check with given change-vector (see options).
     */
    store<TEntity extends object>(document: TEntity, id?: string, options?: StoreOptions<TEntity>): Promise<void>;
    /**
     * Begin a load while including the specified path
     * Path in documents in which server should look for a 'referenced' documents.
     */
    include(path: string): ILoaderWithInclude;
    /**
     * Saves all the pending changes to the server.
     */
    saveChanges(): Promise<void>;
    /**
     * Queries collection or index.
     */
    query<T extends object>(opts: DocumentQueryOptions<T>): IDocumentQuery<T>;
    /**
     * Queries collection. Collection name is determined from documentType using document store conventions.
     */
    query<T extends object>(documentType: DocumentType<T>): IDocumentQuery<T>;
    query<T extends object>(documentType: DocumentType<T>, index: new () => AbstractCommonApiForIndexes): IDocumentQuery<T>;
    countersFor(documentId: string): ISessionDocumentCounters;
    countersFor(entity: object): ISessionDocumentCounters;
    timeSeriesFor(documentId: string, name: string): ISessionDocumentTimeSeries;
    timeSeriesFor(entity: any, name: string): ISessionDocumentTimeSeries;
    timeSeriesFor<T extends object>(documentId: string, clazz: ObjectTypeDescriptor<T>): ISessionDocumentTypedTimeSeries<T>;
    timeSeriesFor<T extends object>(documentId: string, name: string, clazz: ObjectTypeDescriptor<T>): ISessionDocumentTypedTimeSeries<T>;
    timeSeriesFor<T extends object>(entity: object, clazz: ObjectTypeDescriptor<T>): ISessionDocumentTypedTimeSeries<T>;
    timeSeriesFor<T extends object>(entity: object, name: string, clazz: ObjectTypeDescriptor<T>): ISessionDocumentTypedTimeSeries<T>;
    timeSeriesRollupFor<T extends object>(entity: object, policy: string, clazz: ClassConstructor<T>): ISessionDocumentRollupTypedTimeSeries<T>;
    timeSeriesRollupFor<T extends object>(entity: object, policy: string, raw: string, clazz: ClassConstructor<T>): ISessionDocumentRollupTypedTimeSeries<T>;
    timeSeriesRollupFor<T extends object>(documentId: string, policy: string, clazz: ClassConstructor<T>): ISessionDocumentRollupTypedTimeSeries<T>;
    timeSeriesRollupFor<T extends object>(documentId: string, policy: string, raw: string, clazz: ClassConstructor<T>): ISessionDocumentRollupTypedTimeSeries<T>;
    incrementalTimeSeriesFor(documentId: string, name: string): ISessionDocumentIncrementalTimeSeries;
    incrementalTimeSeriesFor(entity: object, name: string): ISessionDocumentIncrementalTimeSeries;
    incrementalTimeSeriesFor<T extends object>(documentId: string, clazz: ObjectTypeDescriptor<T>): ISessionDocumentTypedIncrementalTimeSeries<T>;
    incrementalTimeSeriesFor<T extends object>(documentId: string, name: string, clazz: ObjectTypeDescriptor<T>): ISessionDocumentTypedIncrementalTimeSeries<T>;
    incrementalTimeSeriesFor<T extends object>(entity: object, clazz: ObjectTypeDescriptor<T>): ISessionDocumentTypedIncrementalTimeSeries<T>;
    incrementalTimeSeriesFor<T extends object>(entity: object, name: string, clazz: ObjectTypeDescriptor<T>): ISessionDocumentTypedIncrementalTimeSeries<T>;
}
/**
 * session.store() options
 */
export interface StoreOptions<T extends object> {
    /**
     * Type of document being stored
     */
    documentType?: DocumentType<T>;
    /**
     * Change vector used for forcing concurrency check.
     */
    changeVector?: string;
}
/**
 * session.load() options
 */
export interface LoadOptions<T extends object> {
    /**
     * Type of document to load
     */
    documentType?: DocumentType<T>;
    /**
     * Ids of included documents
     */
    includes?: string[] | ((includesBuilder: IIncludeBuilder) => void);
    /**
     * Expected change vector
     */
    expectedChangeVector?: string;
}
export interface SessionLoadStartingWithOptions<T extends object> extends StartingWithOptions {
    matches?: string;
    start?: number;
    pageSize?: number;
    exclude?: string;
    startAfter?: string;
    documentType?: DocumentType<T>;
    streamResults?: boolean;
}
export interface StartingWithOptions {
    matches?: string;
    start?: number;
    pageSize?: number;
    exclude?: string;
    startAfter?: string;
}
export interface SessionLoadInternalParameters<TResult extends object> {
    includes?: string[];
    documentType?: DocumentType<TResult>;
    counterIncludes?: string[];
    includeAllCounters?: boolean;
    timeSeriesIncludes?: AbstractTimeSeriesRange[];
    compareExchangeValueIncludes?: string[];
    revisionIncludesByChangeVector?: string[];
    revisionsToIncludeByDateTime?: Date;
}
export interface IDocumentSessionImpl extends IDocumentSession {
    conventions: DocumentConventions;
    loadInternal<TResult extends object>(ids: string[], opts: SessionLoadInternalParameters<TResult>): Promise<EntitiesCollectionObject<TResult>>;
    lazyLoadInternal<TResult extends object>(ids: string[], includes: string[], clazz: ObjectTypeDescriptor<TResult>): Lazy<EntitiesCollectionObject<TResult>>;
}
//# sourceMappingURL=IDocumentSession.d.ts.map