"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SessionDocumentTimeSeries = void 0;
const SessionTimeSeriesBase_js_1 = require("./SessionTimeSeriesBase.js");
const TypeUtil_js_1 = require("../../Utility/TypeUtil.js");
class SessionDocumentTimeSeries extends SessionTimeSeriesBase_js_1.SessionTimeSeriesBase {
    constructor(session, documentIdOrEntity, name) {
        super(session, documentIdOrEntity, name);
    }
    get(startOrFrom, toOrPageSize, startOrIncludes, startOrPageSize, pageSize) {
        if (TypeUtil_js_1.TypeUtil.isFunction(startOrIncludes)) {
            return this._getInternal(startOrFrom, toOrPageSize, startOrIncludes, startOrPageSize, pageSize);
        }
        else if (TypeUtil_js_1.TypeUtil.isNumber(startOrIncludes)) {
            return this._getInternal(startOrFrom, toOrPageSize, null, startOrPageSize, pageSize);
        }
        else if (TypeUtil_js_1.TypeUtil.isNumber(startOrFrom)) {
            // get(start: number, pageSize: number)
            return this._getInternal(null, null, null, startOrFrom, toOrPageSize);
        }
        else {
            return this._getInternal(startOrFrom, toOrPageSize, null, 0, TypeUtil_js_1.TypeUtil.MAX_INT32);
        }
    }
    async _getInternal(from, to, includes, start, pageSize) {
        if (this._notInCache(from, to)) {
            return this.getTimeSeriesAndIncludes(from, to, includes, start, pageSize);
        }
        const resultsToUser = await this._serveFromCache(from, to, start, pageSize, includes);
        if (!resultsToUser) {
            return null;
        }
        return resultsToUser.slice(0, pageSize);
    }
    append(timestamp, valueOrValues, tag) {
        return this._appendInternal(timestamp, valueOrValues, tag);
    }
    increment(timestampOrValuesOrValue, valueOrValues) {
        if (TypeUtil_js_1.TypeUtil.isDate(timestampOrValuesOrValue)) {
            const values = TypeUtil_js_1.TypeUtil.isArray(valueOrValues) ? valueOrValues : [valueOrValues];
            return this._incrementInternal(timestampOrValuesOrValue, values);
        }
        const values = TypeUtil_js_1.TypeUtil.isArray(timestampOrValuesOrValue) ? timestampOrValuesOrValue : [timestampOrValuesOrValue];
        return this._incrementInternal(new Date(), values);
    }
}
exports.SessionDocumentTimeSeries = SessionDocumentTimeSeries;
//# sourceMappingURL=SessionDocumentTimeSeries.js.map