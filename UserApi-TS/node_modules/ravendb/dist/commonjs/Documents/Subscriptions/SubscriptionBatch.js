"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SubscriptionBatch = void 0;
const SubscriptionBatchBase_js_1 = require("./SubscriptionBatchBase.js");
const GenerateEntityIdOnTheClient_js_1 = require("../Identity/GenerateEntityIdOnTheClient.js");
const index_js_1 = require("../../Exceptions/index.js");
const DocumentInfo_js_1 = require("../Session/DocumentInfo.js");
class SubscriptionBatch extends SubscriptionBatchBase_js_1.SubscriptionBatchBase {
    _store;
    _generateEntityIdOnTheClient;
    _sessionOpened = false;
    constructor(documentType, revisions, requestExecutor, store, dbName) {
        super(documentType, revisions, requestExecutor, dbName);
        this._store = store;
        this._generateEntityIdOnTheClient = new GenerateEntityIdOnTheClient_js_1.GenerateEntityIdOnTheClient(this._requestExecutor.conventions, () => (0, index_js_1.throwError)("InvalidOperationException", "Shouldn't be generating new ids here"));
    }
    initialize(batch) {
        this._sessionOpened = false;
        super.initialize(batch);
    }
    openSession(options) {
        if (options) {
            SubscriptionBatch._validateSessionOptions(options);
        }
        options = options || {};
        options.database = this._dbName;
        options.requestExecutor = this._requestExecutor;
        return this._openSessionInternal(options);
    }
    _openSessionInternal(options) {
        if (this._sessionOpened) {
            this.throwSessionCanBeOpenedOnlyOnce();
        }
        this._sessionOpened = true;
        const s = this._store.openSession(options);
        this._loadDataToSession(s);
        return s;
    }
    throwSessionCanBeOpenedOnlyOnce() {
        (0, index_js_1.throwError)("InvalidOperationException", "Session can only be opened once per each Subscription batch");
    }
    static _validateSessionOptions(options) {
        if (options.database) {
            (0, index_js_1.throwError)("InvalidOperationException", "Cannot set Database when session is opened in subscription.");
        }
        if (options.requestExecutor) {
            (0, index_js_1.throwError)("InvalidOperationException", "Cannot set RequestExecutor when session is opened in subscription.");
        }
        if (options.transactionMode !== "SingleNode") {
            (0, index_js_1.throwError)("InvalidOperationException", "Cannot set TransactionMode when session is opened in subscription. Only 'SingleNode' is supported.");
        }
    }
    _loadDataToSession(session) {
        if (session.noTracking) {
            return;
        }
        if (this._includes && this._includes.length) {
            for (const item of this._includes) {
                session.registerIncludes(item);
            }
        }
        if (this._counterIncludes && this._counterIncludes.length) {
            for (const item of this._counterIncludes) {
                session.registerCounters(item.includes, item.counterIncludes);
            }
        }
        if (this._timeSeriesIncludes && this._timeSeriesIncludes.length > 0) {
            for (const item of this._timeSeriesIncludes) {
                session.registerTimeSeries(item);
            }
        }
        for (const item of this.items) {
            if (item.projection || item.revision) {
                continue;
            }
            const documentInfo = new DocumentInfo_js_1.DocumentInfo();
            documentInfo.id = item.id;
            documentInfo.document = item.rawResult;
            documentInfo.metadata = item.rawMetadata;
            documentInfo.metadataInstance = item.metadata;
            documentInfo.changeVector = item.changeVector;
            documentInfo.entity = item.result;
            documentInfo.newDocument = false;
            session.registerExternalLoadedIntoTheSession(documentInfo);
        }
    }
    ensureDocumentId(item, id) {
        this._generateEntityIdOnTheClient.trySetIdentity(item, id);
    }
}
exports.SubscriptionBatch = SubscriptionBatch;
//# sourceMappingURL=SubscriptionBatch.js.map