import { IDisposable } from "../../Types/Contracts.js";
import { DocumentStore } from "../DocumentStore.js";
import { SubscriptionCreationOptions } from "./SubscriptionCreationOptions.js";
import { DocumentType } from "../DocumentAbstractions.js";
import { SubscriptionWorkerOptions } from "./SubscriptionWorkerOptions.js";
import { Revision } from "./Revision.js";
import { SubscriptionState } from "./SubscriptionState.js";
import { SubscriptionWorker } from "./SubscriptionWorker.js";
import { SubscriptionUpdateOptions } from "./SubscriptionUpdateOptions.js";
export declare class DocumentSubscriptions implements IDisposable {
    private readonly _store;
    private readonly _subscriptions;
    constructor(store: DocumentStore);
    /**
     * Creates a data subscription in a database. The subscription will expose all
     * documents that match the specified subscription options for a given type.
     */
    create(options: SubscriptionCreationOptions): Promise<string>;
    /**
     * Creates a data subscription in a database. The subscription will expose all
     * documents that match the specified subscription options for a given type.
     */
    create(options: SubscriptionCreationOptions, database: string): Promise<string>;
    /**
     * Creates a data subscription in a database. The subscription will expose all
     * documents that match the specified subscription options for a given type.
     */
    create(documentType: DocumentType): Promise<string>;
    /**
     * Creates a data subscription in a database. The subscription will expose all documents
     * that match the specified subscription options for a given type.
     */
    createForRevisions(options: SubscriptionCreationOptions): Promise<string>;
    /**
     * Creates a data subscription in a database. The subscription will expose all documents
     * that match the specified subscription options for a given type.
     */
    createForRevisions(options: SubscriptionCreationOptions, database: string): Promise<string>;
    private _ensureCriteria;
    /**
     * It opens a subscription and starts pulling documents since a last processed document for that subscription.
     * The connection options determine client and server cooperation rules like document batch sizes
     * or a timeout in a matter of which a client needs to acknowledge that batch has been processed.
     * The acknowledgment is sent after all documents are processed by subscription's handlers.
     *
     * There can be only a single client that is connected to a subscription.
     */
    getSubscriptionWorker<T extends object>(options: SubscriptionWorkerOptions<T>): SubscriptionWorker<T>;
    /**
     * It opens a subscription and starts pulling documents since a last processed document for that subscription.
     * The connection options determine client and server cooperation rules like document batch sizes
     * or a timeout in a matter of which a client needs to acknowledge that batch has been processed.
     * The acknowledgment is sent after all documents are processed by subscription's handlers.
     *
     * There can be only a single client that is connected to a subscription.
     */
    getSubscriptionWorker<T extends object>(options: SubscriptionWorkerOptions<T>, database: string): SubscriptionWorker<T>;
    /**
     * It opens a subscription and starts pulling documents since a last processed document for that subscription.
     * The connection options determine client and server cooperation rules like document batch sizes
     * or a timeout in a matter of which a client needs to acknowledge that batch has been processed.
     * The acknowledgment is sent after all documents are processed by subscription's handlers.
     *
     * There can be only a single client that is connected to a subscription.
     */
    getSubscriptionWorker<T extends object>(subscriptionName: string): SubscriptionWorker<T>;
    /**
     * It opens a subscription and starts pulling documents since a last processed document for that subscription.
     * The connection options determine client and server cooperation rules like document batch sizes
     * or a timeout in a matter of which a client needs to acknowledge that batch has been processed.
     * The acknowledgment is sent after all documents are processed by subscription's handlers.
     *
     * There can be only a single client that is connected to a subscription.
     */
    getSubscriptionWorker<T extends object>(subscriptionName: string, database: string): SubscriptionWorker<T>;
    /**
     * It opens a subscription and starts pulling documents since a last processed document for that subscription.
     * The connection options determine client and server cooperation rules like document batch sizes
     * or a timeout in a matter of which a client needs to acknowledge that batch has been processed.
     * The acknowledgment is sent after all documents are processed by subscription's handlers.
     *
     * There can be only a single client that is connected to a subscription.
     */
    getSubscriptionWorkerForRevisions<T extends object>(options: SubscriptionWorkerOptions<T>): SubscriptionWorker<Revision<T>>;
    /**
     * It opens a subscription and starts pulling documents since a last processed document for that subscription.
     * The connection options determine client and server cooperation rules like document batch sizes
     * or a timeout in a matter of which a client needs to acknowledge that batch has been processed.
     * The acknowledgment is sent after all documents are processed by subscription's handlers.
     *
     * There can be only a single client that is connected to a subscription.
     */
    getSubscriptionWorkerForRevisions<T extends object>(options: SubscriptionWorkerOptions<T>, database: string): SubscriptionWorker<Revision<T>>;
    /**
     * It downloads a list of all existing subscriptions in a database.
     */
    getSubscriptions(start: number, take: number): Promise<SubscriptionState[]>;
    /**
     * It downloads a list of all existing subscriptions in a database.
     */
    getSubscriptions(start: number, take: number, database: string): Promise<SubscriptionState[]>;
    /**
     * Delete a subscription.
     */
    delete(name: string): Promise<void>;
    /**
     * Delete a subscription.
     */
    delete(name: string, database: string): Promise<void>;
    /**
     * Returns subscription definition and it's current state
     */
    getSubscriptionState(subscriptionName: string): Promise<SubscriptionState>;
    /**
     * Returns subscription definition and it's current state
     */
    getSubscriptionState(subscriptionName: string, database: string): Promise<SubscriptionState>;
    dispose(): void;
    dropSubscriptionWorker<T extends object>(worker: SubscriptionWorker<T>, database?: string): Promise<void>;
    /**
     * Force server to close all current client subscription connections to the server
     */
    dropConnection(name: string): Promise<void>;
    /**
     * Force server to close all current client subscription connections to the server
     */
    dropConnection(name: string, database: string): Promise<void>;
    enable(name: string): any;
    enable(name: string, database: string): any;
    disable(name: string): any;
    disable(name: string, database: string): any;
    update(options: SubscriptionUpdateOptions): Promise<string>;
    update(options: SubscriptionUpdateOptions, database: string): Promise<string>;
}
//# sourceMappingURL=DocumentSubscriptions.d.ts.map