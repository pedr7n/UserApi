import { DocumentType } from "../DocumentAbstractions.js";
import { SubscriptionWorkerOptions } from "./SubscriptionWorkerOptions.js";
import { EventEmitter } from "node:events";
import { IRequestExecutorOptions, RequestExecutor } from "../../Http/RequestExecutor.js";
import { SubscriptionBatchBase } from "./SubscriptionBatchBase.js";
import { EmptyCallback } from "../../Types/Callbacks.js";
import { SubscriptionWorker } from "./SubscriptionWorker.js";
export declare abstract class AbstractSubscriptionWorker<TBatch extends SubscriptionBatchBase<TType>, TType extends object> {
    protected readonly _documentType: DocumentType<TType>;
    protected readonly _revisions: boolean;
    protected readonly _logger: import("../../Utility/LogUtil.js").ILogger;
    protected readonly _dbName: string;
    protected _processingCanceled: boolean;
    protected readonly _options: SubscriptionWorkerOptions<TType>;
    private _tcpClient;
    private _parser;
    protected _disposed: boolean;
    protected _subscriptionTask: Promise<void>;
    protected _forcedTopologyUpdateAttempts: number;
    protected _emitter: EventEmitter<[never]>;
    constructor(options: SubscriptionWorkerOptions<TType>, withRevisions: boolean, dbName: string);
    getWorkerId(): string;
    on(event: "batch", handler: (value: TBatch, callback: EmptyCallback) => void): this;
    on(event: "error", handler: (error?: Error) => void): this;
    on(event: "end", handler: (error?: Error) => void): this;
    on(event: "unexpectedSubscriptionError", handler: (error?: Error) => void): this;
    on(event: "onEstablishedSubscriptionConnection", handler: (value: SubscriptionWorker<any>) => void): this;
    on(event: "afterAcknowledgment", handler: (value: TBatch, callback: EmptyCallback) => void): this;
    on(event: "connectionRetry", handler: (error?: Error) => void): this;
    off(event: "batch", handler: (value: TBatch, callback: EmptyCallback) => void): this;
    off(event: "error", handler: (error?: Error) => void): this;
    off(event: "unexpectedSubscriptionError", handler: (error?: Error) => void): this;
    off(event: "onEstablishedSubscriptionConnection", handler: (value: SubscriptionWorker<any>) => void): this;
    off(event: "end", handler: (error?: Error) => void): this;
    off(event: "afterAcknowledgment", handler: (value: TBatch, callback: EmptyCallback) => void): this;
    off(event: "connectionRetry", handler: (error?: Error) => void): this;
    removeListener(event: "batch", handler: (value: TBatch, callback: EmptyCallback) => void): this;
    removeListener(event: "error", handler: (error?: Error) => void): this;
    removeListener(event: "unexpectedSubscriptionError", handler: (error?: Error) => void): this;
    removeListener(event: "onEstablishedSubscriptionConnection", handler: (value: SubscriptionWorker<any>) => void): this;
    removeListener(event: "end", handler: (error?: Error) => void): this;
    removeListener(event: "afterAcknowledgment", handler: (value: TBatch, callback: EmptyCallback) => void): this;
    removeListener(event: "connectionRetry", handler: (error?: Error) => void): this;
    dispose(): void;
    private _redirectNode;
    protected _subscriptionLocalRequestExecutor: RequestExecutor;
    protected subscriptionTcpVersion: number;
    get currentNodeTag(): string;
    get subscriptionName(): string;
    protected _shouldUseCompression(): boolean;
    private _connectToServer;
    private _negotiateProtocolVersionForSubscription;
    private _legacyTryGetTcpInfo;
    private _sendOptions;
    private _ensureParser;
    private _readServerResponseAndGetVersion;
    private _sendDropMessage;
    private _assertConnectionState;
    private _processSubscription;
    private _processSubscriptionInternal;
    private _prepareBatch;
    private _emitBatchAndWaitForProcessing;
    private _readSingleSubscriptionBatchFromServer;
    private _throwInvalidServerResponse;
    private _throwSubscriptionError;
    private _readNextObject;
    private _sendAck;
    private _runSubscriptionAsync;
    private _lastConnectionFailure;
    private _supportedFeatures;
    private _assertLastConnectionFailure;
    private _shouldTryToReconnect;
    private _closeTcpClient;
    protected abstract getRequestExecutor(): RequestExecutor;
    protected abstract setLocalRequestExecutor(url: string, opts: IRequestExecutorOptions): void;
    protected abstract createEmptyBatch(): TBatch;
    protected abstract trySetRedirectNodeOnConnectToServer(): void;
    private static _mapToLocalObject;
}
//# sourceMappingURL=AbstractSubscriptionWorker.d.ts.map