"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Item = exports.SubscriptionBatchBase = void 0;
const LogUtil_js_1 = require("../../Utility/LogUtil.js");
const index_js_1 = require("../../Exceptions/index.js");
const Constants_js_1 = require("../../Constants.js");
const StringUtil_js_1 = require("../../Utility/StringUtil.js");
const MetadataAsDictionary_js_1 = require("../../Mapping/MetadataAsDictionary.js");
const EntityToJson_js_1 = require("../Session/EntityToJson.js");
const OsUtil_js_1 = require("../../Utility/OsUtil.js");
class SubscriptionBatchBase {
    _documentType;
    _revisions;
    lastSentChangeVectorInBatch;
    _requestExecutor;
    _dbName;
    _logger = (0, LogUtil_js_1.getLogger)({ module: "SubscriptionBatch" });
    _items = [];
    _includes;
    _counterIncludes;
    _timeSeriesIncludes;
    get items() {
        return this._items;
    }
    getNumberOfItemsInBatch() {
        return this._items ? this._items.length : 0;
    }
    getNumberOfIncludes() {
        return this._includes ? this._includes.length : 0;
    }
    constructor(documentType, revisions, requestExecutor, dbName) {
        this._documentType = documentType;
        this._revisions = revisions;
        this._requestExecutor = requestExecutor;
        this._dbName = dbName;
    }
    initialize(batch) {
        this._includes = batch.includes;
        this._counterIncludes = batch.counterIncludes;
        this._timeSeriesIncludes = batch.timeSeriesIncludes;
        this._items.length = 0;
        let lastReceivedChangeVector;
        for (const item of batch.messages) {
            const curDoc = item.data;
            const metadata = curDoc[Constants_js_1.CONSTANTS.Documents.Metadata.KEY];
            if (!metadata) {
                SubscriptionBatchBase._throwRequired("@metadata field");
            }
            const id = metadata[Constants_js_1.CONSTANTS.Documents.Metadata.ID];
            if (!id) {
                SubscriptionBatchBase._throwRequired("@id field");
            }
            const changeVector = metadata[Constants_js_1.CONSTANTS.Documents.Metadata.CHANGE_VECTOR];
            if (!changeVector) {
                SubscriptionBatchBase._throwRequired("@change-vector field");
            }
            lastReceivedChangeVector = changeVector;
            const projection = metadata[Constants_js_1.CONSTANTS.Documents.Metadata.PROJECTION] ?? false;
            this._logger.info("Got " + id + " (change vector: [" + lastReceivedChangeVector + "]");
            let instance = null;
            if (!item.exception) {
                instance = EntityToJson_js_1.EntityToJson.convertToEntity(this._documentType, id, curDoc, this._requestExecutor.conventions);
                if (!StringUtil_js_1.StringUtil.isNullOrEmpty(id)) {
                    this.ensureDocumentId(instance, id);
                }
                // TODO: check if something's missing here
                // https://github.com/ravendb/ravendb-jvm-client/blob/v4.1/src/main/java/net/ravendb/client/documents/subscriptions/SubscriptionBatch.java#L222
            }
            const itemToAdd = new Item();
            itemToAdd.changeVector = changeVector;
            itemToAdd.id = id;
            itemToAdd.rawResult = curDoc;
            itemToAdd.rawMetadata = metadata;
            itemToAdd.result = instance;
            itemToAdd.exceptionMessage = item.exception;
            itemToAdd.projection = projection;
            itemToAdd.revision = this._revisions;
            itemToAdd.metadata = (0, MetadataAsDictionary_js_1.createMetadataDictionary)({ raw: metadata });
            this._items.push(itemToAdd);
        }
    }
    static _throwRequired(name) {
        (0, index_js_1.throwError)("InvalidOperationException", "Document must have a " + name);
    }
}
exports.SubscriptionBatchBase = SubscriptionBatchBase;
/**
 * Represents a single item in a subscription batch results.
 */
class Item {
    _result;
    exceptionMessage;
    id;
    changeVector;
    projection;
    revision;
    metadata;
    _throwItemProcessError() {
        (0, index_js_1.throwError)("InvalidOperationException", "Failed to process document " + this.id + " with Change Vector "
            + this.changeVector + " because: " + OsUtil_js_1.EOL + this.exceptionMessage);
    }
    get result() {
        if (this.exceptionMessage) {
            this._throwItemProcessError();
        }
        return this._result;
    }
    set result(result) {
        this._result = result;
    }
    rawResult;
    rawMetadata;
}
exports.Item = Item;
//# sourceMappingURL=SubscriptionBatchBase.js.map