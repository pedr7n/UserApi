{"version":3,"file":"DocumentSubscriptions.js","sourceRoot":"","sources":["../../../../src/Documents/Subscriptions/DocumentSubscriptions.ts"],"names":[],"mappings":"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","sourcesContent":["import { IDisposable } from \"../../Types/Contracts.js\";\r\nimport { DocumentStore } from \"../DocumentStore.js\";\r\nimport { SubscriptionCreationOptions } from \"./SubscriptionCreationOptions.js\";\r\nimport { DocumentType } from \"../DocumentAbstractions.js\";\r\nimport { TypeUtil } from \"../../Utility/TypeUtil.js\";\r\nimport { throwError } from \"../../Exceptions/index.js\";\r\nimport { CreateSubscriptionCommand } from \"../Commands/CreateSubscriptionCommand.js\";\r\nimport { SubscriptionWorkerOptions } from \"./SubscriptionWorkerOptions.js\";\r\nimport { Revision } from \"./Revision.js\";\r\nimport { SubscriptionState } from \"./SubscriptionState.js\";\r\nimport { SubscriptionWorker } from \"./SubscriptionWorker.js\";\r\nimport { DeleteSubscriptionCommand } from \"../Commands/DeleteSubscriptionCommand.js\";\r\nimport { StringUtil } from \"../../Utility/StringUtil.js\";\r\nimport { GetSubscriptionStateCommand } from \"../Commands/GetSubscriptionStateCommand.js\";\r\nimport { DropSubscriptionConnectionCommand } from \"../Commands/DropSubscriptionConnectionCommand.js\";\r\nimport { GetSubscriptionsCommand } from \"../Commands/GetSubscriptionsCommand.js\";\r\nimport { ToggleOngoingTaskStateOperation } from \"../Operations/OngoingTasks/ToggleOngoingTaskStateOperation.js\";\r\nimport { SubscriptionIncludeBuilder } from \"../Session/Loaders/SubscriptionIncludeBuilder.js\";\r\nimport { IncludesUtil } from \"../Session/IncludesUtil.js\";\r\nimport { StringBuilder } from \"../../Utility/StringBuilder.js\";\r\nimport { SubscriptionUpdateOptions } from \"./SubscriptionUpdateOptions.js\";\r\nimport { UpdateSubscriptionCommand } from \"../Commands/UpdateSubscriptionCommand.js\";\r\nimport { CounterIncludesToken } from \"../Session/Tokens/CounterIncludesToken.js\";\r\nimport { TimeSeriesIncludesToken } from \"../Session/Tokens/TimeSeriesIncludesToken.js\";\r\nimport { QueryToken } from \"../Session/Tokens/QueryToken.js\";\r\nimport { EOL } from \"../../Utility/OsUtil.js\";\r\n\r\nconst INCLUDE_REVISIONS_RQL = \" (Revisions = true)\";\r\n\r\nexport class DocumentSubscriptions implements IDisposable {\r\n    private readonly _store: DocumentStore;\r\n    private readonly _subscriptions: Map<IDisposable, boolean> = new Map();\r\n\r\n    public constructor(store: DocumentStore) {\r\n        this._store = store;\r\n    }\r\n\r\n    /**\r\n     * Creates a data subscription in a database. The subscription will expose all\r\n     * documents that match the specified subscription options for a given type.\r\n     */\r\n    public async create(options: SubscriptionCreationOptions): Promise<string>;\r\n\r\n    /**\r\n     * Creates a data subscription in a database. The subscription will expose all\r\n     * documents that match the specified subscription options for a given type.\r\n     */\r\n    public async create(options: SubscriptionCreationOptions, database: string): Promise<string>;\r\n\r\n    /**\r\n     * Creates a data subscription in a database. The subscription will expose all\r\n     * documents that match the specified subscription options for a given type.\r\n     */\r\n    public async create(documentType: DocumentType): Promise<string>;\r\n\r\n    /**\r\n     * Creates a data subscription in a database. The subscription will expose all\r\n     * documents that match the specified subscription options for a given type.\r\n     */\r\n    public async create(optionsOrDocumentType: SubscriptionCreationOptions | DocumentType,\r\n                        database?: string): Promise<string> {\r\n\r\n        let options: SubscriptionCreationOptions = null;\r\n        if (TypeUtil.isDocumentType(optionsOrDocumentType)) {\r\n            options = {\r\n                documentType: optionsOrDocumentType as DocumentType<any>\r\n            };\r\n            return this.create(this._ensureCriteria(options, false), database);\r\n        } else {\r\n            options = this._ensureCriteria(optionsOrDocumentType as SubscriptionCreationOptions, false);\r\n        }\r\n\r\n        if (!options) {\r\n            throwError(\"InvalidArgumentException\", \"Cannot create a subscription if options are null\");\r\n        }\r\n\r\n        if (!options.query) {\r\n            throwError(\"InvalidArgumentException\", \"Cannot create a subscription if the script is null\");\r\n        }\r\n\r\n        const requestExecutor = this._store.getRequestExecutor(this._store.getEffectiveDatabase(database));\r\n\r\n        const command = new CreateSubscriptionCommand(options);\r\n        await requestExecutor.execute(command);\r\n\r\n        return command.result.name;\r\n    }\r\n\r\n    /**\r\n     * Creates a data subscription in a database. The subscription will expose all documents\r\n     * that match the specified subscription options for a given type.\r\n     */\r\n    public createForRevisions(options: SubscriptionCreationOptions): Promise<string>;\r\n\r\n    /**\r\n     * Creates a data subscription in a database. The subscription will expose all documents\r\n     * that match the specified subscription options for a given type.\r\n     */\r\n    public createForRevisions(options: SubscriptionCreationOptions, database: string): Promise<string>;\r\n\r\n    /**\r\n     * Creates a data subscription in a database. The subscription will expose all documents\r\n     * that match the specified subscription options for a given type.\r\n     */\r\n    public createForRevisions(options: SubscriptionCreationOptions, database?: string): Promise<string> {\r\n        options = options || {} as SubscriptionCreationOptions;\r\n\r\n        return this.create(this._ensureCriteria(options, true), database);\r\n    }\r\n\r\n    private _ensureCriteria<T extends object>(\r\n        criteria: SubscriptionCreationOptions, revisions: boolean) {\r\n        if (!criteria) {\r\n            criteria = {} as SubscriptionCreationOptions;\r\n        }\r\n\r\n        const objectDescriptor = this._store.conventions.getJsTypeByDocumentType(criteria.documentType);\r\n        const collectionName = this._store.conventions.getCollectionNameForType(objectDescriptor);\r\n        let queryBuilder: StringBuilder;\r\n\r\n        if (criteria.query) {\r\n            queryBuilder = new StringBuilder(criteria.query);\r\n        } else {\r\n            queryBuilder = new StringBuilder(\"from '\");\r\n            StringUtil.escapeString(queryBuilder, collectionName);\r\n            queryBuilder.append(\"'\");\r\n\r\n            if (revisions) {\r\n                queryBuilder.append(INCLUDE_REVISIONS_RQL);\r\n            }\r\n\r\n            queryBuilder.append(\" as doc\");\r\n        }\r\n\r\n        if (criteria.includes) {\r\n            const builder = new SubscriptionIncludeBuilder(this._store.conventions);\r\n            criteria.includes(builder);\r\n\r\n            let numberOfIncludesAdded = 0;\r\n\r\n            if (builder.documentsToInclude && builder.documentsToInclude.size) {\r\n                queryBuilder.append(EOL + \"include \");\r\n\r\n                for (const inc of builder.documentsToInclude) {\r\n                    const include = \"doc.\" + inc;\r\n                    if (numberOfIncludesAdded > 0) {\r\n                        queryBuilder.append(\",\");\r\n                    }\r\n\r\n                    let escapedInclude: string;\r\n                    if (IncludesUtil.requiresQuotes(include, x => escapedInclude = x)) {\r\n                        queryBuilder\r\n                            .append(\"'\")\r\n                            .append(escapedInclude)\r\n                            .append(\"'\");\r\n                    } else {\r\n                        queryBuilder\r\n                            .append(QueryToken.isKeyword(include) ? \"'\" + include + \"'\" : include);\r\n                    }\r\n\r\n                    numberOfIncludesAdded++;\r\n                }\r\n            }\r\n\r\n            if (builder.isAllCounters) {\r\n                if (!numberOfIncludesAdded) {\r\n                    queryBuilder\r\n                        .append(EOL)\r\n                        .append(\"include \");\r\n                }\r\n\r\n                const token = CounterIncludesToken.all(\"\");\r\n                token.writeTo(queryBuilder);\r\n                numberOfIncludesAdded++;\r\n            } else if (builder.countersToInclude && builder.countersToInclude.size) {\r\n                if (!numberOfIncludesAdded) {\r\n                    queryBuilder\r\n                        .append(EOL)\r\n                        .append(\"include \");\r\n                }\r\n\r\n                for (const counterName of builder.countersToInclude) {\r\n                    if (numberOfIncludesAdded > 0) {\r\n                        queryBuilder.append(\",\");\r\n                    }\r\n\r\n                    const token = CounterIncludesToken.create(\"\", counterName);\r\n                    token.writeTo(queryBuilder);\r\n\r\n                    numberOfIncludesAdded++;\r\n                }\r\n            }\r\n\r\n            if (builder.timeSeriesToInclude) {\r\n                for (const timeSeriesRange of builder.timeSeriesToInclude) {\r\n                    if (numberOfIncludesAdded === 0) {\r\n                        queryBuilder\r\n                            .append(EOL)\r\n                            .append(\"include \");\r\n                    }\r\n\r\n                    if (numberOfIncludesAdded > 0) {\r\n                        queryBuilder.append(\",\");\r\n                    }\r\n\r\n                    const token = TimeSeriesIncludesToken.create(\"\", timeSeriesRange)\r\n                    token.writeTo(queryBuilder);\r\n\r\n                    numberOfIncludesAdded++;\r\n                }\r\n            }\r\n        }\r\n\r\n        criteria.query = queryBuilder.toString();\r\n\r\n        return criteria;\r\n    }\r\n\r\n    /**\r\n     * It opens a subscription and starts pulling documents since a last processed document for that subscription.\r\n     * The connection options determine client and server cooperation rules like document batch sizes\r\n     * or a timeout in a matter of which a client needs to acknowledge that batch has been processed.\r\n     * The acknowledgment is sent after all documents are processed by subscription's handlers.\r\n     *\r\n     * There can be only a single client that is connected to a subscription.\r\n     */\r\n    public getSubscriptionWorker<T extends object>(\r\n        options: SubscriptionWorkerOptions<T>): SubscriptionWorker<T>;\r\n\r\n    /**\r\n     * It opens a subscription and starts pulling documents since a last processed document for that subscription.\r\n     * The connection options determine client and server cooperation rules like document batch sizes\r\n     * or a timeout in a matter of which a client needs to acknowledge that batch has been processed.\r\n     * The acknowledgment is sent after all documents are processed by subscription's handlers.\r\n     *\r\n     * There can be only a single client that is connected to a subscription.\r\n     */\r\n    public getSubscriptionWorker<T extends object>(\r\n        options: SubscriptionWorkerOptions<T>, database: string): SubscriptionWorker<T>;\r\n\r\n    /**\r\n     * It opens a subscription and starts pulling documents since a last processed document for that subscription.\r\n     * The connection options determine client and server cooperation rules like document batch sizes\r\n     * or a timeout in a matter of which a client needs to acknowledge that batch has been processed.\r\n     * The acknowledgment is sent after all documents are processed by subscription's handlers.\r\n     *\r\n     * There can be only a single client that is connected to a subscription.\r\n     */\r\n    public getSubscriptionWorker<T extends object>(\r\n        subscriptionName: string): SubscriptionWorker<T>;\r\n\r\n    /**\r\n     * It opens a subscription and starts pulling documents since a last processed document for that subscription.\r\n     * The connection options determine client and server cooperation rules like document batch sizes\r\n     * or a timeout in a matter of which a client needs to acknowledge that batch has been processed.\r\n     * The acknowledgment is sent after all documents are processed by subscription's handlers.\r\n     *\r\n     * There can be only a single client that is connected to a subscription.\r\n     */\r\n    public getSubscriptionWorker<T extends object>(\r\n        subscriptionName: string, database: string): SubscriptionWorker<T>;\r\n\r\n    /**\r\n     * It opens a subscription and starts pulling documents since a last processed document for that subscription.\r\n     * The connection options determine client and server cooperation rules like document batch sizes\r\n     * or a timeout in a matter of which a client needs to acknowledge that batch has been processed.\r\n     * The acknowledgment is sent after all documents are processed by subscription's handlers.\r\n     *\r\n     * There can be only a single client that is connected to a subscription.\r\n     */\r\n    public getSubscriptionWorker<T extends object>(\r\n        optionsOrSubscriptionName: SubscriptionWorkerOptions<T> | string,\r\n        database?: string): SubscriptionWorker<T> {\r\n\r\n        if (TypeUtil.isString(optionsOrSubscriptionName)) {\r\n            return this.getSubscriptionWorker({\r\n                subscriptionName: optionsOrSubscriptionName\r\n            }, database);\r\n        }\r\n\r\n        const options: SubscriptionWorkerOptions<T> = optionsOrSubscriptionName;\r\n        this._store.assertInitialized();\r\n\r\n        if (!options) {\r\n            throwError(\"InvalidArgumentException\", \"Cannot open a subscription if options are null\");\r\n        }\r\n\r\n        const subscription = new SubscriptionWorker(options, false, this._store, database);\r\n        subscription.on(\"end\", () => this._subscriptions.delete(subscription));\r\n        this._subscriptions.set(subscription, true);\r\n\r\n        return subscription;\r\n    }\r\n\r\n    /**\r\n     * It opens a subscription and starts pulling documents since a last processed document for that subscription.\r\n     * The connection options determine client and server cooperation rules like document batch sizes\r\n     * or a timeout in a matter of which a client needs to acknowledge that batch has been processed.\r\n     * The acknowledgment is sent after all documents are processed by subscription's handlers.\r\n     *\r\n     * There can be only a single client that is connected to a subscription.\r\n     */\r\n    public getSubscriptionWorkerForRevisions<T extends object>(\r\n        options: SubscriptionWorkerOptions<T>): SubscriptionWorker<Revision<T>>;\r\n\r\n    /**\r\n     * It opens a subscription and starts pulling documents since a last processed document for that subscription.\r\n     * The connection options determine client and server cooperation rules like document batch sizes\r\n     * or a timeout in a matter of which a client needs to acknowledge that batch has been processed.\r\n     * The acknowledgment is sent after all documents are processed by subscription's handlers.\r\n     *\r\n     * There can be only a single client that is connected to a subscription.\r\n     */\r\n    public getSubscriptionWorkerForRevisions<T extends object>(\r\n        options: SubscriptionWorkerOptions<T>, database: string): SubscriptionWorker<Revision<T>>;\r\n\r\n    /**\r\n     * It opens a subscription and starts pulling documents since a last processed document for that subscription.\r\n     * The connection options determine client and server cooperation rules like document batch sizes\r\n     * or a timeout in a matter of which a client needs to acknowledge that batch has been processed.\r\n     * The acknowledgment is sent after all documents are processed by subscription's handlers.\r\n     *\r\n     * There can be only a single client that is connected to a subscription.\r\n     */\r\n    public getSubscriptionWorkerForRevisions<T extends object>(\r\n        optionsOrSubscriptionName: SubscriptionWorkerOptions<T> | string,\r\n        database?: string): SubscriptionWorker<Revision<T>> {\r\n\r\n        if (TypeUtil.isString(optionsOrSubscriptionName)) {\r\n            return this.getSubscriptionWorkerForRevisions({\r\n                subscriptionName: optionsOrSubscriptionName,\r\n            } as SubscriptionWorkerOptions<T>, database);\r\n        }\r\n\r\n        const options: SubscriptionWorkerOptions<T> = optionsOrSubscriptionName;\r\n        const subscription = new SubscriptionWorker<Revision<T>>(\r\n            options as any as SubscriptionWorkerOptions<Revision<T>>, true, this._store, database);\r\n\r\n        subscription.on(\"end\", () => this._subscriptions.delete(subscription));\r\n        this._subscriptions.set(subscription, true);\r\n\r\n        return subscription;\r\n    }\r\n\r\n    /**\r\n     * It downloads a list of all existing subscriptions in a database.\r\n     */\r\n    public async getSubscriptions(start: number, take: number): Promise<SubscriptionState[]>;\r\n\r\n    /**\r\n     * It downloads a list of all existing subscriptions in a database.\r\n     */\r\n    public async getSubscriptions(start: number, take: number, database: string): Promise<SubscriptionState[]>;\r\n\r\n    /**\r\n     * It downloads a list of all existing subscriptions in a database.\r\n     */\r\n    public async getSubscriptions(start: number, take: number, database?: string): Promise<SubscriptionState[]> {\r\n        const requestExecutor = this._store.getRequestExecutor(this._store.getEffectiveDatabase(database));\r\n\r\n        const command = new GetSubscriptionsCommand(start, take);\r\n        await requestExecutor.execute(command);\r\n\r\n        return command.result;\r\n    }\r\n\r\n    /**\r\n     * Delete a subscription.\r\n     */\r\n    public async delete(name: string): Promise<void>;\r\n\r\n    /**\r\n     * Delete a subscription.\r\n     */\r\n    public async delete(name: string, database: string): Promise<void>;\r\n\r\n    /**\r\n     * Delete a subscription.\r\n     */\r\n    public async delete(name: string, database?: string): Promise<void> {\r\n        const requestExecutor = this._store.getRequestExecutor(this._store.getEffectiveDatabase(database));\r\n\r\n        const command = new DeleteSubscriptionCommand(name);\r\n        return requestExecutor.execute(command);\r\n    }\r\n\r\n    /**\r\n     * Returns subscription definition and it's current state\r\n     */\r\n    public async getSubscriptionState(subscriptionName: string): Promise<SubscriptionState>;\r\n\r\n    /**\r\n     * Returns subscription definition and it's current state\r\n     */\r\n    public async getSubscriptionState(subscriptionName: string, database: string): Promise<SubscriptionState>;\r\n\r\n    /**\r\n     * Returns subscription definition and it's current state\r\n     */\r\n    public async getSubscriptionState(subscriptionName: string, database?: string): Promise<SubscriptionState> {\r\n        if (StringUtil.isNullOrEmpty(subscriptionName)) {\r\n            throwError(\"InvalidArgumentException\", \"SubscriptionName cannot be null\");\r\n        }\r\n\r\n        const requestExecutor = this._store.getRequestExecutor(this._store.getEffectiveDatabase(database));\r\n\r\n        const command = new GetSubscriptionStateCommand(subscriptionName);\r\n        await requestExecutor.execute(command);\r\n        return command.result;\r\n    }\r\n\r\n    public dispose(): void {\r\n        if (!this._subscriptions.size) {\r\n            return;\r\n        }\r\n\r\n        for (const [key, value] of this._subscriptions.entries()) key.dispose();\r\n    }\r\n\r\n    public async dropSubscriptionWorker<T extends object>(worker: SubscriptionWorker<T>, database: string = null) {\r\n        database ??= this._store.database;\r\n\r\n        const requestExecutor = this._store.getRequestExecutor(database);\r\n        const command = new DropSubscriptionConnectionCommand(worker.subscriptionName, worker.getWorkerId());\r\n\r\n        await requestExecutor.execute(command);\r\n    }\r\n\r\n    /**\r\n     * Force server to close all current client subscription connections to the server\r\n     */\r\n    public async dropConnection(name: string): Promise<void>;\r\n\r\n    /**\r\n     * Force server to close all current client subscription connections to the server\r\n     */\r\n    public async dropConnection(name: string, database: string): Promise<void>;\r\n\r\n    /**\r\n     * Force server to close all current client subscription connections to the server\r\n     */\r\n    public async dropConnection(name: string, database?: string): Promise<void> {\r\n        const requestExecutor = this._store.getRequestExecutor(this._store.getEffectiveDatabase(database));\r\n\r\n        const command = new DropSubscriptionConnectionCommand(name);\r\n        return requestExecutor.execute(command);\r\n    }\r\n\r\n    public async enable(name: string)\r\n    public async enable(name: string, database: string)\r\n    public async enable(name: string, database?: string) {\r\n        const operation = new ToggleOngoingTaskStateOperation(name, \"Subscription\", false);\r\n        await this._store.maintenance.forDatabase(this._store.getEffectiveDatabase(database))\r\n            .send(operation);\r\n    }\r\n\r\n    public async disable(name: string)\r\n    public async disable(name: string, database: string)\r\n    public async disable(name: string, database?: string) {\r\n        const operation = new ToggleOngoingTaskStateOperation(name, \"Subscription\", true);\r\n        await this._store.maintenance.forDatabase(this._store.getEffectiveDatabase(database))\r\n            .send(operation);\r\n    }\r\n\r\n    public async update(options: SubscriptionUpdateOptions): Promise<string>;\r\n    public async update(options: SubscriptionUpdateOptions, database: string): Promise<string>;\r\n    public async update(options: SubscriptionUpdateOptions, database?: string): Promise<string> {\r\n        if (!options) {\r\n            throwError(\"InvalidArgumentException\", \"Cannot update a subscription if options is null\");\r\n        }\r\n\r\n        if (StringUtil.isNullOrEmpty(options.name) && !options.id) {\r\n            throwError(\"InvalidArgumentException\", \"Cannot update a subscription if both options.name and options.if are null\");\r\n        }\r\n\r\n        const requestExecutor = this._store.getRequestExecutor(database);\r\n        const command = new UpdateSubscriptionCommand(options);\r\n        await requestExecutor.execute(command, null);\r\n\r\n        return command.result.name;\r\n    }\r\n}\r\n"]}