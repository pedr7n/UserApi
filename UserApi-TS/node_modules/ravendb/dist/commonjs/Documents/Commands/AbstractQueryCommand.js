"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbstractQueryCommand = void 0;
const RavenCommand_js_1 = require("../../Http/RavenCommand.js");
const StringBuilder_js_1 = require("../../Utility/StringBuilder.js");
class AbstractQueryCommand extends RavenCommand_js_1.RavenCommand {
    _metadataOnly;
    _indexEntriesOnly;
    _ignoreLimit;
    constructor(indexQuery, canCache, metadataOnly, indexEntriesOnly, ignoreLimit) {
        super();
        this._metadataOnly = metadataOnly;
        this._indexEntriesOnly = indexEntriesOnly;
        this._ignoreLimit = ignoreLimit;
        this._canCache = canCache;
        // we won't allow aggressive caching of queries with WaitForNonStaleResults
        this._canCacheAggressively = canCache && !indexQuery.waitForNonStaleResults;
    }
    get isReadRequest() {
        return true;
    }
    createRequest(node) {
        const path = new StringBuilder_js_1.StringBuilder(node.url)
            .append("/databases/")
            .append(node.database)
            .append("/queries?queryHash=")
            // we need to add a query hash because we are using POST queries
            // so we need to unique parameter per query so the query cache will
            // work properly
            .append(this.getQueryHash());
        if (this._metadataOnly) {
            path.append("&metadataOnly=true");
        }
        if (this._indexEntriesOnly) {
            path.append("&debug=entries");
        }
        if (this._ignoreLimit) {
            path.append("&ignoreLimit=true");
        }
        path.append("&addTimeSeriesNames=true");
        const uri = path.toString();
        const body = this._getContent();
        const headers = this._headers().typeAppJson().build();
        return {
            method: "POST",
            uri,
            headers,
            body
        };
    }
}
exports.AbstractQueryCommand = AbstractQueryCommand;
//# sourceMappingURL=AbstractQueryCommand.js.map