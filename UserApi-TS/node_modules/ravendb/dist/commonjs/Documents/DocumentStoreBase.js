"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DocumentStoreBase = void 0;
const node_events_1 = require("node:events");
const index_js_1 = require("../Exceptions/index.js");
const UriUtil_js_1 = require("../Utility/UriUtil.js");
const DocumentConventions_js_1 = require("./Conventions/DocumentConventions.js");
const IndexCreation_js_1 = require("./Indexes/IndexCreation.js");
const PutIndexesOperation_js_1 = require("./Operations/Indexes/PutIndexesOperation.js");
const DocumentSubscriptions_js_1 = require("./Subscriptions/DocumentSubscriptions.js");
const TypeUtil_js_1 = require("../Utility/TypeUtil.js");
const CaseInsensitiveKeysMap_js_1 = require("../Primitives/CaseInsensitiveKeysMap.js");
const TimeSeriesOperations_js_1 = require("./TimeSeries/TimeSeriesOperations.js");
const StringUtil_js_1 = require("../Utility/StringUtil.js");
const AiOperations_js_1 = require("./Operations/AI/AiOperations.js");
class DocumentStoreBase extends node_events_1.EventEmitter {
    /* TBD 4.1
    public abstract disableAggressiveCaching(): IDisposable;
    public abstract disableAggressiveCaching(database: string): IDisposable;
    */
    constructor() {
        super();
        this._subscriptions = new DocumentSubscriptions_js_1.DocumentSubscriptions(this);
    }
    _disposed;
    isDisposed() {
        return this._disposed;
    }
    executeIndex(task, database) {
        this.assertInitialized();
        return task.execute(this, this.conventions, database);
    }
    async executeIndexes(tasks, database) {
        this.assertInitialized();
        const indexesToAdd = IndexCreation_js_1.IndexCreation.createIndexesToAdd(tasks, this.conventions);
        await this.maintenance
            .forDatabase(this.getEffectiveDatabase(database))
            .send(new PutIndexesOperation_js_1.PutIndexesOperation(...indexesToAdd));
    }
    _timeSeriesOperation;
    get timeSeries() {
        if (!this._timeSeriesOperation) {
            this._timeSeriesOperation = new TimeSeriesOperations_js_1.TimeSeriesOperations(this);
        }
        return this._timeSeriesOperation;
    }
    _conventions;
    _aiOperations;
    get ai() {
        if (!this._aiOperations) {
            this._aiOperations = new AiOperations_js_1.AiOperations(this);
        }
        return this._aiOperations;
    }
    get conventions() {
        if (!this._conventions) {
            this._conventions = new DocumentConventions_js_1.DocumentConventions();
        }
        return this._conventions;
    }
    set conventions(value) {
        this._assertNotInitialized("conventions");
        this._conventions = value;
    }
    _urls = [];
    get urls() {
        return this._urls;
    }
    set urls(value) {
        this._assertNotInitialized("urls");
        if (!value || !Array.isArray(value)) {
            (0, index_js_1.throwError)("InvalidArgumentException", `Invalid urls array passed: ${value.toString()}.`);
        }
        for (let i = 0; i < value.length; i++) {
            if (!value[i]) {
                (0, index_js_1.throwError)("InvalidArgumentException", `Url cannot be null or undefined - url index: ${i}`);
            }
            (0, UriUtil_js_1.validateUri)(value[i]);
            value[i] = value[i].replace(/\/$/, "");
        }
        this._urls = value;
    }
    _initialized;
    _authOptions;
    _subscriptions;
    get subscriptions() {
        return this._subscriptions;
    }
    _lastRaftIndexPerDatabase = CaseInsensitiveKeysMap_js_1.CaseInsensitiveKeysMap.create();
    getLastTransactionIndex(database) {
        const index = this._lastRaftIndexPerDatabase.get(database);
        if (!index) {
            return null;
        }
        return index;
    }
    setLastTransactionIndex(database, index) {
        if (!index) {
            return;
        }
        const initialValue = this._lastRaftIndexPerDatabase.get(database);
        const result = TypeUtil_js_1.TypeUtil.isUndefined(initialValue)
            ? index
            : Math.max(initialValue, index);
        this._lastRaftIndexPerDatabase.set(database, result);
    }
    _ensureNotDisposed() {
        if (this._disposed) {
            (0, index_js_1.throwError)("InvalidOperationException", "The document store has already been disposed and cannot be used");
        }
    }
    assertInitialized() {
        if (!this._initialized) {
            (0, index_js_1.throwError)("InvalidOperationException", "You cannot open a session or access the database commands before initializing the document store. "
                + "Did you forget calling initialize()?");
        }
    }
    _assertNotInitialized(property) {
        if (this._initialized) {
            (0, index_js_1.throwError)("InvalidOperationException", "You cannot set '" + property + "' after the document store has been initialized.");
        }
    }
    _database;
    get database() {
        return this._database;
    }
    set database(value) {
        this._assertNotInitialized("database");
        this._database = value;
    }
    get authOptions() {
        return this._authOptions;
    }
    set authOptions(value) {
        this._assertNotInitialized("authOptions");
        this._authOptions = value;
    }
    // TBD public IDisposable AggressivelyCache(string database = null)
    _eventHandlers = [];
    addSessionListener(eventName, eventHandler) {
        this._eventHandlers.push([eventName, eventHandler]);
        return this;
    }
    removeSessionListener(eventName, eventHandler) {
        const toRemove = this._eventHandlers
            .find(x => x[0] === eventName && x[1] === eventHandler);
        if (toRemove) {
            this._eventHandlers.splice(this._eventHandlers.indexOf(toRemove), 1);
        }
    }
    registerEvents(requestExecutorOrSession) {
        for (const [eventName, eventHandler] of this._eventHandlers) {
            if (eventName === "failedRequest"
                || eventName === "topologyUpdated"
                || eventName === "beforeRequest"
                || eventName === "succeedRequest") {
                requestExecutorOrSession.on(eventName, eventHandler);
            }
            else {
                requestExecutorOrSession.on(eventName, eventHandler);
            }
        }
    }
    _assertValidConfiguration() {
        this.conventions.validate();
    }
    getEffectiveDatabase(database) {
        return DocumentStoreBase.getEffectiveDatabase(this, database);
    }
    static getEffectiveDatabase(store, database) {
        if (!database) {
            database = store.database;
        }
        if (!StringUtil_js_1.StringUtil.isNullOrWhitespace(database)) {
            return database;
        }
        (0, index_js_1.throwError)("InvalidArgumentException", "Cannot determine database to operate on. " +
            "Please either specify 'database' directly as an action parameter " +
            "or set the default database to operate on using 'DocumentStore.database' property. " +
            "Did you forget to pass 'database' parameter?");
    }
}
exports.DocumentStoreBase = DocumentStoreBase;
//# sourceMappingURL=DocumentStoreBase.js.map