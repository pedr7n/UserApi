"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbstractGenericIndexCreationTask = void 0;
const AbstractIndexCreationTaskBase_js_1 = require("./AbstractIndexCreationTaskBase.js");
const Spatial_js_1 = require("./Spatial.js");
const Constants_js_1 = require("../../Constants.js");
const index_js_1 = require("../../Exceptions/index.js");
/**
 * Base class for creating indexes
 */
class AbstractGenericIndexCreationTask extends AbstractIndexCreationTaskBase_js_1.AbstractIndexCreationTaskBase {
    storesStrings;
    indexesStrings;
    analyzersStrings;
    indexSuggestions;
    termVectorsStrings;
    spatialOptionsStrings;
    vectorOptionsStrings;
    outputReduceToCollection;
    patternForOutputReduceToCollectionReferences;
    patternReferencesCollectionName;
    constructor() {
        super();
        this.storesStrings = {};
        this.indexesStrings = {};
        this.analyzersStrings = {};
        this.indexSuggestions = new Set();
        this.termVectorsStrings = {};
        this.spatialOptionsStrings = {};
        this.vectorOptionsStrings = {};
    }
    /**
     * Register a field to be indexed
     */
    index(field, indexing) {
        this.indexesStrings[field] = indexing;
    }
    /**
     * Register a field to be spatially indexed
     */
    spatial(field, indexing) {
        this.spatialOptionsStrings[field] = indexing(new Spatial_js_1.SpatialOptionsFactory());
    }
    // TBD protected void Store(Expression<Func<TReduceResult, object>> field, FieldStorage storage)
    storeAllFields(storage) {
        this.storesStrings[Constants_js_1.CONSTANTS.Documents.Indexing.Fields.ALL_FIELDS] = storage;
    }
    /**
     * Register a field to be stored
     */
    store(field, storage) {
        this.storesStrings[field] = storage;
    }
    /**
     * Register a field to be analyzed
     */
    analyze(field, analyzer) {
        this.analyzersStrings[field] = analyzer;
    }
    /**
     * Register a field to have term vectors
     */
    termVector(field, termVector) {
        this.termVectorsStrings[field] = termVector;
    }
    suggestion(field) {
        this.indexSuggestions.add(field);
    }
    addAssembly(assembly) {
        if (!assembly) {
            (0, index_js_1.throwError)("InvalidArgumentException", "Assembly cannot be null");
        }
        if (!this.additionalAssemblies) {
            this.additionalAssemblies = [];
        }
        this.additionalAssemblies.push(assembly);
    }
    vectorField(field, vector) {
        this.vectorOptionsStrings[field] = vector;
    }
}
exports.AbstractGenericIndexCreationTask = AbstractGenericIndexCreationTask;
//# sourceMappingURL=AbstractGenericIndexCreationTask.js.map