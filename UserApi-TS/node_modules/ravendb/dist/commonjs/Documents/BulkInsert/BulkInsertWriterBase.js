"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RequestBodyStream = exports.BulkInsertStream = exports.BulkInsertWriterBase = void 0;
const node_buffer_1 = require("node:buffer");
const node_stream_1 = require("node:stream");
const node_util_1 = require("node:util");
const TypeUtil_js_1 = require("../../Utility/TypeUtil.js");
class BulkInsertWriterBase {
    _maxSizeInBuffer = 1024 * 1024;
    _asyncWrite = Promise.resolve();
    _asyncWriteDone = true;
    _currentWriter;
    _backgroundWriter;
    _isInitialWrite = true;
    lastFlushToStream;
    requestBodyStream;
    requestBodyStreamFinished = false;
    compressedStream;
    constructor() {
        this.requestBodyStream = new RequestBodyStream();
        this._currentWriter = new BulkInsertStream();
        this._backgroundWriter = new BulkInsertStream();
        this._updateFlushTime();
    }
    async dispose() {
        if (this.requestBodyStreamFinished) {
            return;
        }
        try {
            if (this.requestBodyStream) {
                this._currentWriter.push("]");
                await this._asyncWrite;
                await this.writeToStream(this._currentWriter.toBuffer());
                await this.requestBodyStream.flush();
            }
        }
        finally {
            this.requestBodyStreamFinished = true;
        }
    }
    initialize() {
        this.onCurrentWriteStreamSet(this._currentWriter);
    }
    isFlushNeeded() {
        return this._currentWriter.length > this._maxSizeInBuffer || this._asyncWriteDone;
    }
    async flushIfNeeded(force = false) {
        if (this.isFlushNeeded()) {
            await this._asyncWrite;
            const tmp = this._currentWriter;
            this._currentWriter = this._backgroundWriter;
            this._backgroundWriter = tmp;
            this._currentWriter = new BulkInsertStream();
            const buffer = this._backgroundWriter.toBuffer();
            force = true; // original version: force || this.isHeartbeatIntervalExceeded() || ; in node.js we need to force flush to use backpressure in steams
            this._asyncWriteDone = false;
            this._asyncWrite = this.writeToStream(buffer, force);
        }
    }
    _updateFlushTime() {
        this.lastFlushToStream = new Date();
    }
    onCurrentWriteStreamSet(currentWriteStream) {
        // empty by design
    }
    async writeToStream(buffer, forceDstFlush = false) {
        try {
            this.requestBodyStream.write(buffer);
            if (forceDstFlush) {
                this._updateFlushTime();
                await this.requestBodyStream.flush();
            }
            if (this.compressedStream) {
                const flush = (0, node_util_1.promisify)(this.compressedStream.flush);
                await flush.call(this.compressedStream);
            }
        }
        finally {
            this._asyncWriteDone = true;
        }
    }
    async ensureStream(compression) {
        if (compression === "Gzip") {
            const { createGzip } = await import("node:zlib");
            this.compressedStream = createGzip();
            (0, node_stream_1.pipeline)(this.requestBodyStream, this.compressedStream, TypeUtil_js_1.TypeUtil.NOOP);
        }
        this._currentWriter.push("[");
    }
}
exports.BulkInsertWriterBase = BulkInsertWriterBase;
class BulkInsertStream {
    _items = [];
    totalLength = 0;
    push(data) {
        this._items.push(data);
        this.totalLength += node_buffer_1.Buffer.isBuffer(data) ? data.length : node_buffer_1.Buffer.byteLength(data);
    }
    toBuffer() {
        const result = node_buffer_1.Buffer.allocUnsafe(this.totalLength);
        let idx = 0;
        for (const inputElement of this._items) {
            if (node_buffer_1.Buffer.isBuffer(inputElement)) {
                inputElement.copy(result, idx);
                idx += inputElement.length;
            }
            else {
                result.write(inputElement, idx);
                idx += node_buffer_1.Buffer.byteLength(inputElement);
            }
        }
        return result;
    }
    get length() {
        return this.totalLength;
    }
}
exports.BulkInsertStream = BulkInsertStream;
class RequestBodyStream extends node_stream_1.Readable {
    constructor() {
        super({
            highWaterMark: 1024 * 1024
        });
    }
    _pending;
    _resume;
    _read(size) {
        this._resume?.();
    }
    write(data) {
        const canConsumeMore = this.push(data);
        if (!canConsumeMore) {
            this._pending = new Promise(resolve => {
                this._resume = () => {
                    this._resume = null;
                    resolve();
                };
            });
        }
    }
    async flush() {
        await this._pending;
    }
}
exports.RequestBodyStream = RequestBodyStream;
//# sourceMappingURL=BulkInsertWriterBase.js.map