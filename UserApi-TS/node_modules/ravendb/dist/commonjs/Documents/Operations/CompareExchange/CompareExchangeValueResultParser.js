"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CompareExchangeValueResultParser = exports.ObjectNodeMarker = void 0;
const CompareExchangeValue_js_1 = require("./CompareExchangeValue.js");
const index_js_1 = require("../../../Exceptions/index.js");
const TypeUtil_js_1 = require("../../../Utility/TypeUtil.js");
const ObjectUtil_js_1 = require("../../../Utility/ObjectUtil.js");
const Constants_js_1 = require("../../../Constants.js");
const MetadataAsDictionary_js_1 = require("../../../Mapping/MetadataAsDictionary.js");
exports.ObjectNodeMarker = Symbol("ObjectNodeMarker");
class CompareExchangeValueResultParser {
    static getValues(responseObj, materializeMetadata, conventions, clazz) {
        const items = responseObj.results;
        if (!items) {
            (0, index_js_1.throwError)("InvalidOperationException", "Response is invalid. Results is missing.");
        }
        const results = {};
        for (const item of items) {
            if (!item) {
                (0, index_js_1.throwError)("InvalidOperationException", "Response is invalid. Item is null");
            }
            const value = CompareExchangeValueResultParser.getSingleValue(item, materializeMetadata, conventions, clazz);
            results[value.key] = value;
        }
        return results;
    }
    static getValue(response, materializeMetadata, conventions, clazz) {
        if (!response) {
            return null;
        }
        const values = CompareExchangeValueResultParser.getValues(response, materializeMetadata, conventions, clazz);
        const itemsKeys = Object.keys(values);
        if (!values || !itemsKeys.length) {
            return null;
        }
        return Object.values(values)[0];
    }
    static getSingleValue(item, materializeMetadata, conventions, clazz) {
        if (!item) {
            return null;
        }
        const key = item.key || (0, index_js_1.throwError)("InvalidOperationException", "Response is invalid. Key is missing.");
        const index = item.index;
        if (TypeUtil_js_1.TypeUtil.isNullOrUndefined(index)) {
            (0, index_js_1.throwError)("InvalidOperationException", `Response is invalid. Index is ${item.index}.`);
        }
        const raw = item.value;
        const cv = item.changeVector;
        if (TypeUtil_js_1.TypeUtil.isNullOrUndefined(raw)) {
            return new CompareExchangeValue_js_1.CompareExchangeValue(key, index, null, cv, null);
        }
        let metadata;
        const metadataRaw = raw[Constants_js_1.CONSTANTS.Documents.Metadata.KEY];
        if (metadataRaw && TypeUtil_js_1.TypeUtil.isObject(metadataRaw)) {
            metadata = !materializeMetadata ? MetadataAsDictionary_js_1.MetadataDictionary.create(metadataRaw) : MetadataAsDictionary_js_1.MetadataDictionary.materializeFromJson(metadataRaw);
        }
        const value = CompareExchangeValueResultParser.deserializeObject(raw, conventions, clazz);
        return new CompareExchangeValue_js_1.CompareExchangeValue(key, index, value, cv, metadata);
    }
    static deserializeObject(raw, conventions, clazz) {
        if (TypeUtil_js_1.TypeUtil.isNullOrUndefined(raw)) {
            return null;
        }
        const rawValue = raw[Constants_js_1.COMPARE_EXCHANGE.OBJECT_FIELD_NAME];
        if (clazz && TypeUtil_js_1.TypeUtil.isPrimitiveType(clazz)) {
            return rawValue;
        }
        if (clazz === exports.ObjectNodeMarker) {
            if (TypeUtil_js_1.TypeUtil.isNullOrUndefined(rawValue)) {
                return null;
            }
            return TypeUtil_js_1.TypeUtil.isObject(rawValue) ? rawValue : raw;
        }
        if (TypeUtil_js_1.TypeUtil.isPrimitive(rawValue)) {
            return rawValue;
        }
        if (TypeUtil_js_1.TypeUtil.isArray(rawValue)) {
            return ObjectUtil_js_1.ObjectUtil.deepJsonClone(rawValue);
        }
        let value = (TypeUtil_js_1.TypeUtil.isObject(raw) && Constants_js_1.COMPARE_EXCHANGE.OBJECT_FIELD_NAME in raw) ? rawValue : raw;
        const entityType = conventions.getJsTypeByDocumentType(clazz);
        if (conventions.serverToLocalFieldNameConverter) {
            value = ObjectUtil_js_1.ObjectUtil.transformObjectKeys(value, {
                defaultTransform: conventions.serverToLocalFieldNameConverter,
                recursive: true,
                arrayRecursive: true
            });
        }
        const entity = conventions.deserializeEntityFromJson(entityType, value);
        return entity;
    }
}
exports.CompareExchangeValueResultParser = CompareExchangeValueResultParser;
//# sourceMappingURL=CompareExchangeValueResultParser.js.map