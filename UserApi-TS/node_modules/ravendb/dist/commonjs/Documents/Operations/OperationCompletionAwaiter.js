"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OperationCompletionAwaiter = void 0;
const GetOperationStateOperation_js_1 = require("./GetOperationStateOperation.js");
const index_js_1 = require("../../Exceptions/index.js");
const index_js_2 = require("../../Exceptions/index.js");
const PromiseUtil_js_1 = require("../../Utility/PromiseUtil.js");
const KillOperationCommand_js_1 = require("../Commands/KillOperationCommand.js");
class OperationCompletionAwaiter {
    _requestExecutor;
    _conventions;
    _id;
    _nodeTag;
    get id() {
        return this._id;
    }
    constructor(requestExecutor, conventions, id, nodeTag) {
        this._requestExecutor = requestExecutor;
        this._conventions = conventions;
        this._id = id;
        this._nodeTag = nodeTag;
    }
    async _fetchOperationStatus() {
        const command = this._getOperationStateCommand(this._conventions, this._id, this._nodeTag);
        await this._requestExecutor.execute(command);
        return command.result;
    }
    _getOperationStateCommand(conventions, id, nodeTag) {
        return new GetOperationStateOperation_js_1.GetOperationStateCommand(this._id, nodeTag);
    }
    get nodeTag() {
        return this._nodeTag;
    }
    set nodeTag(nodeTag) {
        this._nodeTag = nodeTag;
    }
    waitForCompletion() {
        const operationStatusPolling = () => {
            return Promise.resolve()
                .then(() => this._fetchOperationStatus())
                .then((operationStatusResult) => {
                const operationStatus = operationStatusResult.status;
                switch (operationStatus) {
                    case "Completed": {
                        return;
                    }
                    case "Canceled": {
                        (0, index_js_1.throwError)("OperationCanceledException", `Operation of ID ${this._id} has been canceled.`);
                        break;
                    }
                    case "Faulted": {
                        const faultResult = operationStatusResult.result;
                        const errorSchema = Object.assign({}, faultResult, { url: this._requestExecutor.getUrl() });
                        throw index_js_2.ExceptionDispatcher.get(errorSchema, faultResult.statusCode);
                    }
                }
                return (0, PromiseUtil_js_1.delay)(500)
                    .then(() => operationStatusPolling());
            });
        };
        return Promise.resolve(operationStatusPolling());
    }
    _getKillOperationCommand(id, nodeTag) {
        return new KillOperationCommand_js_1.KillOperationCommand(id, nodeTag);
    }
    async kill() {
        const command = this._getKillOperationCommand(this._id, this.nodeTag);
        await this._requestExecutor.execute(command);
    }
}
exports.OperationCompletionAwaiter = OperationCompletionAwaiter;
//# sourceMappingURL=OperationCompletionAwaiter.js.map