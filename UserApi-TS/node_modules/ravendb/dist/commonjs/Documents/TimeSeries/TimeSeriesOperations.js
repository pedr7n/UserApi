"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TimeSeriesOperations = void 0;
const TypeUtil_js_1 = require("../../Utility/TypeUtil.js");
const ConfigureTimeSeriesValueNamesOperation_js_1 = require("../Operations/TimeSeries/ConfigureTimeSeriesValueNamesOperation.js");
const index_js_1 = require("../../Exceptions/index.js");
const TimeSeriesPolicy_js_1 = require("../Operations/TimeSeries/TimeSeriesPolicy.js");
const ConfigureTimeSeriesPolicyOperation_js_1 = require("../Operations/TimeSeries/ConfigureTimeSeriesPolicyOperation.js");
const StringUtil_js_1 = require("../../Utility/StringUtil.js");
const RawTimeSeriesPolicy_js_1 = require("../Operations/TimeSeries/RawTimeSeriesPolicy.js");
const ConfigureRawTimeSeriesPolicyOperation_js_1 = require("../Operations/TimeSeries/ConfigureRawTimeSeriesPolicyOperation.js");
const RemoveTimeSeriesPolicyOperation_js_1 = require("../Operations/TimeSeries/RemoveTimeSeriesPolicyOperation.js");
const TimeSeriesValuesHelper_js_1 = require("../Session/TimeSeries/TimeSeriesValuesHelper.js");
class TimeSeriesOperations {
    _store;
    _database;
    _executor;
    constructor(store, database) {
        this._store = store;
        this._database = database || store.database;
        this._executor = this._store.maintenance.forDatabase(database);
    }
    async register(collectionClassOrCollection, timeSeriesEntryClassOrName, nameOrValuesName) {
        if (TypeUtil_js_1.TypeUtil.isString(collectionClassOrCollection)) {
            return this._registerInternal(collectionClassOrCollection, timeSeriesEntryClassOrName, nameOrValuesName);
        }
        else {
            const collectionClass = collectionClassOrCollection;
            if (TypeUtil_js_1.TypeUtil.isString(timeSeriesEntryClassOrName)) {
                const collection = this._store.conventions.findCollectionName(collectionClass);
                await this._registerInternal(collection, timeSeriesEntryClassOrName, nameOrValuesName);
            }
            else { // [ClassConstructor<TCollection>, ClassConstructor<TTimeSeriesEntry>, string?]
                let name = nameOrValuesName;
                if (!name) {
                    name = TimeSeriesOperations.getTimeSeriesName(timeSeriesEntryClassOrName, this._store.conventions);
                }
                const mapping = TimeSeriesValuesHelper_js_1.TimeSeriesValuesHelper.getFieldsMapping(timeSeriesEntryClassOrName);
                if (!mapping) {
                    (0, index_js_1.throwError)("InvalidOperationException", TimeSeriesOperations.getTimeSeriesName(timeSeriesEntryClassOrName, this._store.conventions) + " must contain valid mapping");
                }
                const collection = this._store.conventions.findCollectionName(collectionClass);
                const valueNames = mapping.map(x => x.name);
                await this._registerInternal(collection, name, valueNames);
            }
        }
    }
    async _registerInternal(collection, name, valueNames) {
        const parameters = {
            collection,
            timeSeries: name,
            valueNames,
            update: true
        };
        const command = new ConfigureTimeSeriesValueNamesOperation_js_1.ConfigureTimeSeriesValueNamesOperation(parameters);
        await this._executor.send(command);
    }
    async setPolicy(collectionNameOrClass, name, aggregation, retention) {
        const collection = TypeUtil_js_1.TypeUtil.isString(collectionNameOrClass) ? collectionNameOrClass : this._store.conventions.findCollectionName(collectionNameOrClass);
        const p = new TimeSeriesPolicy_js_1.TimeSeriesPolicy(name, aggregation, retention);
        await this._executor.send(new ConfigureTimeSeriesPolicyOperation_js_1.ConfigureTimeSeriesPolicyOperation(collection, p));
    }
    async setRawPolicy(collectionOrClass, retention) {
        const collection = TypeUtil_js_1.TypeUtil.isString(collectionOrClass) ? collectionOrClass : this._store.conventions.findCollectionName(collectionOrClass);
        const p = new RawTimeSeriesPolicy_js_1.RawTimeSeriesPolicy(retention);
        await this._executor.send(new ConfigureRawTimeSeriesPolicyOperation_js_1.ConfigureRawTimeSeriesPolicyOperation(collection, p));
    }
    async removePolicy(clazzOrCollection, name) {
        const collection = TypeUtil_js_1.TypeUtil.isString(clazzOrCollection) ? clazzOrCollection : this._store.conventions.findCollectionName(clazzOrCollection);
        await this._executor.send(new RemoveTimeSeriesPolicyOperation_js_1.RemoveTimeSeriesPolicyOperation(collection, name));
    }
    static getTimeSeriesName(clazz, conventions) {
        return conventions.findCollectionName(clazz);
    }
    forDatabase(database) {
        if (StringUtil_js_1.StringUtil.equalsIgnoreCase(database, this._database)) {
            return this;
        }
        return new TimeSeriesOperations(this._store, database);
    }
}
exports.TimeSeriesOperations = TimeSeriesOperations;
//# sourceMappingURL=TimeSeriesOperations.js.map