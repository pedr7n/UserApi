import { HiloIdGenerator } from "./HiloIdGenerator.js";
import { acquireSemaphore } from "../../Utility/SemaphoreUtil.js";
import { Semaphore } from "../../Utility/Semaphore.js";
export class MultiTypeHiLoIdGenerator {
    _sem;
    _idGeneratorsByTag = {};
    _store;
    _dbName;
    _conventions;
    _identityPartsSeparator;
    constructor(store, dbName) {
        this._store = store;
        this._dbName = dbName;
        this._sem = new Semaphore();
        this._conventions = store.getRequestExecutor(dbName).conventions;
        this._identityPartsSeparator = this._conventions.identityPartsSeparator;
    }
    async generateDocumentId(entity, documentType) {
        const identityPartsSeparator = this._conventions.identityPartsSeparator;
        if (this._identityPartsSeparator !== identityPartsSeparator) {
            await this._maybeRefresh(identityPartsSeparator);
        }
        const entityType = this._conventions.getJsTypeByDocumentType(documentType);
        const typeTagName = entityType
            ? this._conventions.getCollectionNameForType(entityType)
            : this._conventions.getCollectionNameForEntity(entity);
        if (!typeTagName) {
            return null;
        }
        const tag = this._conventions.transformClassCollectionNameToDocumentIdPrefix(typeTagName);
        let value = this._idGeneratorsByTag[tag];
        if (value) {
            return await value.generateDocumentId(entity);
        }
        const acquiredSem = acquireSemaphore(this._sem);
        await acquiredSem.promise;
        try {
            value = this._idGeneratorsByTag[tag];
            if (value) {
                return value.generateDocumentId(entity);
            }
            value = this._createGeneratorFor(tag);
            this._idGeneratorsByTag[tag] = value;
        }
        finally {
            acquiredSem.dispose();
        }
        return value.generateDocumentId(entity);
    }
    async _maybeRefresh(identityPartsSeparator) {
        let idGenerators;
        const acquiredSem = acquireSemaphore(this._sem);
        try {
            await acquiredSem.promise;
            if (this._identityPartsSeparator === identityPartsSeparator) {
                return;
            }
            idGenerators = Object.entries(this._idGeneratorsByTag).map(x => x[1]);
            this._idGeneratorsByTag = {};
            this._identityPartsSeparator = identityPartsSeparator;
        }
        finally {
            acquiredSem.dispose();
        }
        if (idGenerators) {
            try {
                await MultiTypeHiLoIdGenerator._returnUnusedRange(idGenerators);
            }
            catch {
                // ignore
            }
        }
    }
    async generateNextIdFor(collectionName) {
        let value = this._idGeneratorsByTag[collectionName];
        if (value) {
            const nextId = await value.getNextId();
            return nextId.id;
        }
        const acquiredSem = acquireSemaphore(this._sem);
        try {
            await acquiredSem.promise;
            value = this._idGeneratorsByTag[collectionName];
            if (value) {
                const nextId = await value.getNextId();
                return nextId.id;
            }
            value = this._createGeneratorFor(collectionName);
            this._idGeneratorsByTag[collectionName] = value;
        }
        finally {
            acquiredSem.dispose();
        }
        const nextId = await value.getNextId();
        return nextId.id;
    }
    _createGeneratorFor(tag) {
        return new HiloIdGenerator(tag, this._store, this._dbName, this._identityPartsSeparator);
    }
    async returnUnusedRange() {
        await MultiTypeHiLoIdGenerator._returnUnusedRange(Object.values(this._idGeneratorsByTag));
    }
    static async _returnUnusedRange(generators) {
        for (const generator of generators) {
            await generator.returnUnusedRange();
        }
    }
}
//# sourceMappingURL=MultiTypeHiLoIdGenerator.js.map