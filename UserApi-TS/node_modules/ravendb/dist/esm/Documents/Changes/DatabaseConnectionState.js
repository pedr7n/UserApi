import { EventEmitter } from "node:events";
import { getError } from "../../Exceptions/index.js";
import { defer } from "../../Utility/PromiseUtil.js";
import { TypeUtil } from "../../Utility/TypeUtil.js";
export class DatabaseConnectionState {
    static ERROR_EVENT = "error";
    _emitter = new EventEmitter();
    addOnError(handler) {
        this._emitter.addListener(DatabaseConnectionState.ERROR_EVENT, handler);
    }
    removeOnError(handler) {
        this._emitter.removeListener(DatabaseConnectionState.ERROR_EVENT, handler);
    }
    _onDisconnect;
    onConnect;
    _value = 0;
    lastError;
    _firstSet;
    _connected;
    set(connection) {
        if (!this._firstSet.isFulfilled) {
            connection
                .then(() => {
                this._firstSet.resolve(undefined);
            })
                .catch(error => {
                this._firstSet.reject(error);
            });
        }
        else {
            connection.catch(TypeUtil.NOOP);
        }
        this._connected = connection;
    }
    inc() {
        this._value++;
    }
    dec() {
        this._value--;
        if (!this._value) {
            this.set(this._onDisconnect());
        }
    }
    error(e) {
        this.set(Promise.reject(e));
        this.lastError = e;
        this._emitter.emit(DatabaseConnectionState.ERROR_EVENT, e);
    }
    ensureSubscribedNow() {
        return this._connected || Promise.resolve(this._firstSet.promise);
    }
    dispose() {
        this.set(Promise.reject(getError("InvalidOperationException", "Object was disposed")));
        this._emitter.removeAllListeners("Document");
        this._emitter.removeAllListeners("Index");
        this._emitter.removeAllListeners("Operation");
        this._emitter.removeAllListeners("Counter");
        this._emitter.removeAllListeners("TimeSeries");
        this._emitter.removeAllListeners(DatabaseConnectionState.ERROR_EVENT);
    }
    constructor(onConnect, onDisconnect) {
        this.onConnect = onConnect;
        this._onDisconnect = onDisconnect;
        this._value = 0;
        this._emitter.setMaxListeners(50);
        this._firstSet = defer();
    }
    addOnChangeNotification(type, handler) {
        this._emitter.addListener(type, handler);
    }
    removeOnChangeNotification(type, handler) {
        this._emitter.removeListener(type, handler);
    }
    send(type, change) {
        this._emitter.emit(type, change);
    }
}
//# sourceMappingURL=DatabaseConnectionState.js.map