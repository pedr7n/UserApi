import { RevisionsResult } from "./RevisionsResult.js";
import { RavenCommand } from "../../../Http/RavenCommand.js";
import { GetRevisionsCommand } from "../../Commands/GetRevisionsCommand.js";
export class GetRevisionsOperation {
    _parameters;
    _id;
    constructor(id, parameters = {}) {
        this._id = id;
        this._parameters = parameters;
    }
    get resultType() {
        return "CommandResult";
    }
    getCommand(store, conventions, httpCache) {
        return new GetRevisionsResultCommand(this._id, this._parameters, conventions);
    }
}
class GetRevisionsResultCommand extends RavenCommand {
    _parameters;
    conventions;
    _id;
    _cmd;
    constructor(id, parameters, conventions) {
        super();
        this.conventions = conventions;
        this._id = id;
        this._parameters = parameters;
        this._cmd = new GetRevisionsCommand(conventions, id, parameters.start || 0, parameters.pageSize);
    }
    get isReadRequest() {
        return true;
    }
    createRequest(node) {
        return this._cmd.createRequest(node);
    }
    async setResponseAsync(bodyStream, fromCache) {
        if (!bodyStream) {
            return;
        }
        let body;
        const responseNode = await this._pipeline()
            .parseJsonSync()
            .collectBody(b => body = b)
            .process(bodyStream);
        if (!responseNode.Results) {
            return body;
        }
        const revisions = responseNode.Results;
        const total = responseNode.TotalResults;
        const result = new RevisionsResult();
        result.totalResults = total;
        result.results = revisions.filter(x => x).map(x => {
            const entityType = this.conventions.getJsTypeByDocumentType(this._parameters.documentType);
            return this.conventions.deserializeEntityFromJson(entityType, x);
        });
        this.result = result;
    }
}
//# sourceMappingURL=GetRevisionsOperation.js.map