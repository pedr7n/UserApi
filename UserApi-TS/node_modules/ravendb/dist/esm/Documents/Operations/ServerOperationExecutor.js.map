{"version":3,"file":"ServerOperationExecutor.js","sourceRoot":"","sources":["../../../../src/Documents/Operations/ServerOperationExecutor.ts"],"names":[],"mappings":"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","sourcesContent":["import { IDisposable } from \"../../Types/Contracts.js\";\r\nimport { DocumentStoreBase } from \"../DocumentStoreBase.js\";\r\nimport { IServerOperation, AwaitableServerOperation, OperationIdResult } from \"./OperationAbstractions.js\";\r\nimport { ClusterRequestExecutor } from \"../../Http/ClusterRequestExecutor.js\";\r\nimport { RavenCommand } from \"../../Http/RavenCommand.js\";\r\nimport { ServerWideOperationCompletionAwaiter } from \"../../ServerWide/Operations/ServerWideOperationCompletionAwaiter.js\";\r\nimport { getLogger } from \"../../Utility/LogUtil.js\";\r\nimport { throwError } from \"../../Exceptions/index.js\";\r\nimport { StringUtil } from \"../../Utility/StringUtil.js\";\r\nimport { Topology } from \"../../Http/Topology.js\";\r\nimport { GetBuildNumberOperation } from \"../../ServerWide/Operations/GetBuildNumberOperation.js\";\r\nimport { IRequestExecutorOptions } from \"../../Http/RequestExecutor.js\";\r\n\r\nconst log = getLogger({ module: \"ServerOperationExecutor\" });\r\n\r\nexport class ServerOperationExecutor implements IDisposable {\r\n\r\n    private readonly _cache: Map<string, ServerOperationExecutor>;\r\n    private readonly _nodeTag: string;\r\n    private readonly _store: DocumentStoreBase;\r\n    private readonly _requestExecutor: ClusterRequestExecutor;\r\n    private readonly _initialRequestExecutor: ClusterRequestExecutor;\r\n\r\n    public constructor(store: DocumentStoreBase);\r\n    public constructor(store: DocumentStoreBase,\r\n                       requestExecutor: ClusterRequestExecutor,\r\n                       initialRequestExecutor: ClusterRequestExecutor,\r\n                       cache: Map<string, ServerOperationExecutor>,\r\n                       nodeTag: string);\r\n    public constructor(store: DocumentStoreBase,\r\n                       requestExecutor?: ClusterRequestExecutor,\r\n                       initialRequestExecutor?: ClusterRequestExecutor,\r\n                       cache?: Map<string, ServerOperationExecutor>,\r\n                       nodeTag?: string) {\r\n        requestExecutor = requestExecutor || ServerOperationExecutor._createRequestExecutor(store);\r\n        cache = cache || new Map<string, ServerOperationExecutor>();\r\n\r\n        if (!store) {\r\n            throwError(\"InvalidArgumentException\", \"Store cannot be null\");\r\n        }\r\n\r\n        if (!requestExecutor) {\r\n            throwError(\"InvalidArgumentException\", \"RequestExecutor cannot be null\");\r\n        }\r\n\r\n        this._store = store;\r\n        this._requestExecutor = requestExecutor;\r\n        this._initialRequestExecutor = initialRequestExecutor;\r\n        this._nodeTag = nodeTag;\r\n        this._cache = cache;\r\n\r\n        store.registerEvents(this._requestExecutor);\r\n\r\n        if (!nodeTag) {\r\n            store.once(\"afterDispose\",\r\n                (callback) => {\r\n                    log.info(\"Dispose request executor.\");\r\n                    this._requestExecutor.dispose();\r\n                    callback();\r\n                });\r\n        }\r\n    }\r\n\r\n    public async forNode(nodeTag: string): Promise<ServerOperationExecutor> {\r\n        if (StringUtil.isNullOrWhitespace(nodeTag)) {\r\n            throwError(\"InvalidArgumentException\", \"Value cannot be null or whitespace.\");\r\n        }\r\n\r\n        if ((!nodeTag && !this._nodeTag) || StringUtil.equalsIgnoreCase(this._nodeTag, nodeTag)) {\r\n            return this;\r\n        }\r\n\r\n        if (this._store.conventions.disableTopologyUpdates) {\r\n            throwError(\"InvalidOperationException\", \"Cannot switch server operation executor, because conventions.disableTopologyUpdates is set to 'true'\");\r\n        }\r\n\r\n        const existingValue = this._cache.get(nodeTag.toLowerCase());\r\n        if (existingValue) {\r\n            return existingValue;\r\n        }\r\n\r\n        const requestExecutor = this._initialRequestExecutor || this._requestExecutor;\r\n        const topology: Topology = await this._getTopology(requestExecutor);\r\n\r\n        const node = topology.nodes\r\n            .find(x => StringUtil.equalsIgnoreCase(x.clusterTag, nodeTag));\r\n\r\n        if (!node) {\r\n            const availableNodes = topology\r\n                .nodes\r\n                .map(x => x.clusterTag)\r\n                .join(\", \");\r\n\r\n            throwError(\"InvalidOperationException\",\r\n                \"Could not find node '\" + nodeTag + \"' in the topology. Available nodes: \" + availableNodes);\r\n        }\r\n\r\n        const clusterExecutor = ClusterRequestExecutor.createForSingleNode(node.url, {\r\n            authOptions: this._store.authOptions\r\n        });\r\n\r\n        return new ServerOperationExecutor(this._store, clusterExecutor, requestExecutor, this._cache, node.clusterTag);\r\n    }\r\n\r\n    public async send(operation: AwaitableServerOperation): Promise<ServerWideOperationCompletionAwaiter>;\r\n    public async send<TResult>(operation: IServerOperation<TResult>): Promise<TResult>;\r\n    public async send<TResult>(operation: AwaitableServerOperation | IServerOperation<TResult>)\r\n        : Promise<ServerWideOperationCompletionAwaiter | TResult> {\r\n\r\n        const command = operation.getCommand(this._requestExecutor.conventions);\r\n\r\n        await this._requestExecutor.execute(command as RavenCommand<TResult>);\r\n\r\n        if (operation.resultType === \"OperationId\") {\r\n            const idResult = command.result as OperationIdResult;\r\n            return new ServerWideOperationCompletionAwaiter(\r\n                this._requestExecutor, this._requestExecutor.conventions, idResult.operationId,\r\n                command.selectedNodeTag || idResult.operationNodeTag\r\n            );\r\n        }\r\n\r\n        return command.result as TResult;\r\n    }\r\n\r\n    public dispose(): void {\r\n        if (this._nodeTag) {\r\n            return;\r\n        }\r\n\r\n        if (this._requestExecutor) {\r\n            this._requestExecutor.dispose();\r\n        }\r\n\r\n        if (this._cache) {\r\n            for (const [key, value] of this._cache.entries()) {\r\n                const requestExecutor = value._requestExecutor;\r\n                if (requestExecutor) {\r\n                    requestExecutor.dispose();\r\n                }\r\n            }\r\n\r\n            this._cache.clear();\r\n        }\r\n    }\r\n\r\n    private async _getTopology(requestExecutor: ClusterRequestExecutor): Promise<Topology> {\r\n        let topology: Topology = null;\r\n        try {\r\n            topology = requestExecutor.getTopology();\r\n            if (!topology) {\r\n                // a bit rude way to make sure that topology has been refreshed\r\n                // but it handles a case when first topology update failed\r\n\r\n                const operation  = new GetBuildNumberOperation();\r\n                const command = operation.getCommand(requestExecutor.conventions);\r\n                await requestExecutor.execute(command);\r\n                topology = requestExecutor.getTopology();\r\n            }\r\n        } catch {\r\n            // ignored\r\n        }\r\n\r\n        if (!topology) {\r\n            throwError(\"InvalidOperationException\", \"Could not fetch the topology\");\r\n        }\r\n\r\n        return topology;\r\n    }\r\n\r\n    private static _createRequestExecutor(store: DocumentStoreBase): ClusterRequestExecutor {\r\n        const args: IRequestExecutorOptions = {\r\n            authOptions: store.authOptions,\r\n            documentConventions: store.conventions\r\n        };\r\n        return store.conventions.disableTopologyUpdates\r\n            ? ClusterRequestExecutor.createForSingleNode(store.urls[0], args)\r\n            : ClusterRequestExecutor.create(store.urls, args);\r\n    }\r\n}\r\n"]}