import { CompareExchangeValue } from "./CompareExchangeValue.js";
import { throwError } from "../../../Exceptions/index.js";
import { TypeUtil } from "../../../Utility/TypeUtil.js";
import { CompareExchangeValueJsonConverter } from "./CompareExchangeValueJsonConverter.js";
import { COMPARE_EXCHANGE, CONSTANTS } from "../../../Constants.js";
import { StringUtil } from "../../../Utility/StringUtil.js";
import { EntityToJson } from "../../Session/EntityToJson.js";
import { PutCompareExchangeCommandData } from "../../Commands/Batches/PutCompareExchangeCommandData.js";
import { DeleteCompareExchangeCommandData } from "../../Commands/Batches/DeleteCompareExchangeCommandData.js";
import { CompareExchangeValueResultParser } from "./CompareExchangeValueResultParser.js";
export class CompareExchangeSessionValue {
    _key;
    _index;
    _originalValue;
    _value;
    _state;
    constructor(keyOrValue, index, state) {
        if (!keyOrValue) {
            throwError("InvalidArgumentException", "Key cannot be null");
        }
        if (TypeUtil.isString(keyOrValue)) {
            this._key = keyOrValue;
            this._index = index;
            this._state = state;
        }
        else {
            this._key = keyOrValue.key;
            this._index = keyOrValue.index;
            this._state = keyOrValue.index >= 0 ? "None" : "Missing";
            if (keyOrValue.index > 0) {
                this._originalValue = keyOrValue;
            }
        }
    }
    getValue(clazz, conventions) {
        switch (this._state) {
            case "None":
            case "Created": {
                if (this._value instanceof CompareExchangeValue) {
                    return this._value;
                }
                if (this._value) {
                    throwError("InvalidOperationException", "Value cannot be null");
                }
                let entity;
                if (this._originalValue && !TypeUtil.isNullOrUndefined(this._originalValue.value)) {
                    entity = CompareExchangeValueResultParser.deserializeObject(this._originalValue.value, conventions, clazz);
                }
                const value = new CompareExchangeValue(this._key, this._index, entity, null);
                this._value = value;
                return value;
            }
            case "Missing":
            case "Deleted": {
                return null;
            }
            default: {
                throwError("NotSupportedException", "Not supported state: " + this._state);
            }
        }
    }
    create(item) {
        this._assertState();
        if (this._value) {
            throwError("InvalidOperationException", "The compare exchange value with key '" + this._key + "' is already tracked.");
        }
        this._index = 0;
        const value = new CompareExchangeValue(this._key, this._index, item, null);
        this._value = value;
        this._state = "Created";
        return value;
    }
    delete(index) {
        this._assertState();
        this._index = index;
        this._state = "Deleted";
    }
    _assertState() {
        switch (this._state) {
            case "None":
            case "Missing": {
                return;
            }
            case "Created": {
                throwError("InvalidOperationException", "The compare exchange value with key '" + this._key + "' was already stored.");
                break;
            }
            case "Deleted": {
                throwError("InvalidOperationException", "The compare exchange value with key '" + this._key + "' was already deleted.");
            }
        }
    }
    getCommand(conventions) {
        switch (this._state) {
            case "None":
            case "Created": {
                if (!this._value) {
                    return null;
                }
                const entity = CompareExchangeValueJsonConverter.convertToJson(this._value.value, conventions);
                let entityJson = TypeUtil.isObject(entity) ? entity : null;
                let metadata;
                if (this._value.hasMetadata() && Object.keys(this._value.metadata)) {
                    metadata = CompareExchangeSessionValue.prepareMetadataForPut(this._key, this._value.metadata, conventions);
                }
                let entityToInsert = null;
                if (TypeUtil.isNullOrUndefined(entityJson)) {
                    entityJson = entityToInsert = this._convertEntity(this._key, entity, conventions.objectMapper, metadata);
                }
                const newValue = new CompareExchangeValue(this._key, this._index, entityJson, null);
                const hasChanged = TypeUtil.isNullOrUndefined(this._originalValue) || this.hasChanged(this._originalValue, newValue);
                this._originalValue = newValue;
                if (!hasChanged) {
                    return null;
                }
                if (TypeUtil.isNullOrUndefined(entityToInsert)) {
                    entityToInsert = this._convertEntity(this._key, entity, conventions.objectMapper, metadata);
                }
                return new PutCompareExchangeCommandData(newValue.key, entityToInsert, newValue.index);
            }
            case "Deleted": {
                return new DeleteCompareExchangeCommandData(this._key, this._index);
            }
            case "Missing": {
                return null;
            }
            default: {
                throwError("InvalidOperationException", "Not supported state: " + this._state);
            }
        }
    }
    _convertEntity(key, entity, objectMapper, metadata) {
        return {
            [COMPARE_EXCHANGE.OBJECT_FIELD_NAME]: entity,
            [CONSTANTS.Documents.Metadata.KEY]: metadata ?? undefined
        };
    }
    hasChanged(originalValue, newValue) {
        if (originalValue === newValue) {
            return false;
        }
        if (!StringUtil.equalsIgnoreCase(originalValue.key, newValue.key)) {
            throwError("InvalidOperationException", "Keys do not match. Expected '" + originalValue.key + " but was: " + newValue.key);
        }
        if (originalValue.index !== newValue.index) {
            return true;
        }
        return JSON.stringify(originalValue.value) !== JSON.stringify(newValue.value);
    }
    updateState(index) {
        this._index = index;
        this._state = "None";
        if (this._originalValue) {
            this._originalValue.index = index;
        }
        if (this._value) {
            this._value.index = index;
        }
    }
    updateValue(value, mapper) {
        this._index = value.index;
        this._state = value.index >= 0 ? "None" : "Missing";
        this._originalValue = value;
        if (this._value) {
            this._value.index = this._index;
            if (!TypeUtil.isNullOrUndefined(this._value.value)) {
                EntityToJson.populateEntity(this._value.value, value.value, mapper);
            }
        }
    }
    static prepareMetadataForPut(key, metadataDictionary, conventions) {
        if (CONSTANTS.Documents.Metadata.EXPIRES in metadataDictionary) {
            const obj = metadataDictionary[CONSTANTS.Documents.Metadata.EXPIRES];
            if (!obj) {
                CompareExchangeSessionValue._throwInvalidExpiresMetadata("The value of " + CONSTANTS.Documents.Metadata.EXPIRES + " metadata for compare exchange '" + key + " is null.");
            }
            if (!TypeUtil.isDate(obj) && !TypeUtil.isString(obj)) {
                CompareExchangeSessionValue._throwInvalidExpiresMetadata("The class of " + CONSTANTS.Documents.Metadata.EXPIRES + " metadata for compare exchange '" + key + "' is not valid. Use the following type: Date or string");
            }
        }
        return conventions.objectMapper.toObjectLiteral(metadataDictionary);
    }
    static _throwInvalidExpiresMetadata(message) {
        throwError("InvalidArgumentException", message);
    }
}
//# sourceMappingURL=CompareExchangeSessionValue.js.map