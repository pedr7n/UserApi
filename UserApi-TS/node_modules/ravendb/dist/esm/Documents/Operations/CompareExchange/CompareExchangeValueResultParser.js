import { CompareExchangeValue } from "./CompareExchangeValue.js";
import { throwError } from "../../../Exceptions/index.js";
import { TypeUtil } from "../../../Utility/TypeUtil.js";
import { ObjectUtil } from "../../../Utility/ObjectUtil.js";
import { COMPARE_EXCHANGE, CONSTANTS } from "../../../Constants.js";
import { MetadataDictionary } from "../../../Mapping/MetadataAsDictionary.js";
export const ObjectNodeMarker = Symbol("ObjectNodeMarker");
export class CompareExchangeValueResultParser {
    static getValues(responseObj, materializeMetadata, conventions, clazz) {
        const items = responseObj.results;
        if (!items) {
            throwError("InvalidOperationException", "Response is invalid. Results is missing.");
        }
        const results = {};
        for (const item of items) {
            if (!item) {
                throwError("InvalidOperationException", "Response is invalid. Item is null");
            }
            const value = CompareExchangeValueResultParser.getSingleValue(item, materializeMetadata, conventions, clazz);
            results[value.key] = value;
        }
        return results;
    }
    static getValue(response, materializeMetadata, conventions, clazz) {
        if (!response) {
            return null;
        }
        const values = CompareExchangeValueResultParser.getValues(response, materializeMetadata, conventions, clazz);
        const itemsKeys = Object.keys(values);
        if (!values || !itemsKeys.length) {
            return null;
        }
        return Object.values(values)[0];
    }
    static getSingleValue(item, materializeMetadata, conventions, clazz) {
        if (!item) {
            return null;
        }
        const key = item.key || throwError("InvalidOperationException", "Response is invalid. Key is missing.");
        const index = item.index;
        if (TypeUtil.isNullOrUndefined(index)) {
            throwError("InvalidOperationException", `Response is invalid. Index is ${item.index}.`);
        }
        const raw = item.value;
        const cv = item.changeVector;
        if (TypeUtil.isNullOrUndefined(raw)) {
            return new CompareExchangeValue(key, index, null, cv, null);
        }
        let metadata;
        const metadataRaw = raw[CONSTANTS.Documents.Metadata.KEY];
        if (metadataRaw && TypeUtil.isObject(metadataRaw)) {
            metadata = !materializeMetadata ? MetadataDictionary.create(metadataRaw) : MetadataDictionary.materializeFromJson(metadataRaw);
        }
        const value = CompareExchangeValueResultParser.deserializeObject(raw, conventions, clazz);
        return new CompareExchangeValue(key, index, value, cv, metadata);
    }
    static deserializeObject(raw, conventions, clazz) {
        if (TypeUtil.isNullOrUndefined(raw)) {
            return null;
        }
        const rawValue = raw[COMPARE_EXCHANGE.OBJECT_FIELD_NAME];
        if (clazz && TypeUtil.isPrimitiveType(clazz)) {
            return rawValue;
        }
        if (clazz === ObjectNodeMarker) {
            if (TypeUtil.isNullOrUndefined(rawValue)) {
                return null;
            }
            return TypeUtil.isObject(rawValue) ? rawValue : raw;
        }
        if (TypeUtil.isPrimitive(rawValue)) {
            return rawValue;
        }
        if (TypeUtil.isArray(rawValue)) {
            return ObjectUtil.deepJsonClone(rawValue);
        }
        let value = (TypeUtil.isObject(raw) && COMPARE_EXCHANGE.OBJECT_FIELD_NAME in raw) ? rawValue : raw;
        const entityType = conventions.getJsTypeByDocumentType(clazz);
        if (conventions.serverToLocalFieldNameConverter) {
            value = ObjectUtil.transformObjectKeys(value, {
                defaultTransform: conventions.serverToLocalFieldNameConverter,
                recursive: true,
                arrayRecursive: true
            });
        }
        const entity = conventions.deserializeEntityFromJson(entityType, value);
        return entity;
    }
}
//# sourceMappingURL=CompareExchangeValueResultParser.js.map