import { RavenCommand } from "../../../Http/RavenCommand.js";
import { throwError } from "../../../Exceptions/index.js";
import { DocumentCountersOperation } from "./DocumentCountersOperation.js";
import { CounterOperation } from "./CounterOperation.js";
import { CounterBatch } from "./CounterBatch.js";
import { StringBuilder } from "../../../Utility/StringBuilder.js";
export class GetCountersOperation {
    _docId;
    _counters;
    _returnFullResults;
    constructor(docId, counters, returnFullResults = false) {
        this._docId = docId;
        if (counters) {
            this._counters = Array.isArray(counters) ? counters : [counters];
        }
        else {
            this._counters = [];
        }
        this._returnFullResults = returnFullResults;
    }
    getCommand(store, conventions, cache) {
        return new GetCounterValuesCommand(this._docId, this._counters, this._returnFullResults, conventions);
    }
    get resultType() {
        return "CommandResult";
    }
}
export class GetCounterValuesCommand extends RavenCommand {
    _docId;
    _counters;
    _returnFullResults;
    _conventions;
    constructor(docId, counters, returnFullResults, conventions) {
        super();
        if (!docId) {
            throwError("InvalidArgumentException", "DocId cannot be null");
        }
        this._docId = docId;
        this._counters = counters;
        this._returnFullResults = returnFullResults;
        this._conventions = conventions;
    }
    createRequest(node) {
        const pathBuilder = new StringBuilder(node.url);
        pathBuilder.append("/databases/")
            .append(node.database)
            .append("/counters?docId=")
            .append(encodeURIComponent(this._docId));
        let req = { uri: null, method: "GET" };
        if (this._counters.length > 0) {
            if (this._counters && this._counters.length > 1) {
                req = this._prepareRequestWithMultipleCounters(pathBuilder, req);
            }
            else {
                pathBuilder.append("&counter=")
                    .append(encodeURIComponent(this._counters[0]));
            }
        }
        if (this._returnFullResults && req.method === "GET") {
            // if we dropped to Post, _returnFullResults is part of the request content
            pathBuilder.append("&full=true");
        }
        req.uri = pathBuilder.toString();
        return req;
    }
    _prepareRequestWithMultipleCounters(pathBuilder, request) {
        const [uniqueNames, sumLength] = this._getOrderedUniqueNames();
        // if it is too big, we drop to POST (note that means that we can't use the HTTP cache any longer)
        // we are fine with that, such requests are going to be rare
        if (sumLength < 1024) {
            for (const uniqueName of uniqueNames) {
                pathBuilder
                    .append("&counter=")
                    .append(encodeURIComponent(uniqueName || ""));
            }
        }
        else {
            request = { method: "POST" };
            const docOps = new DocumentCountersOperation();
            docOps.documentId = this._docId;
            docOps.operations = [];
            for (const counter of uniqueNames) {
                const counterOperation = new CounterOperation();
                counterOperation.type = "Get";
                counterOperation.counterName = counter;
                docOps.operations.push(counterOperation);
            }
            const batch = new CounterBatch();
            batch.documents = [docOps];
            batch.replyWithAllNodesValues = this._returnFullResults;
            request.body = JSON.stringify(batch.serialize());
            request.headers = this._headers().typeAppJson().build();
        }
        return request;
    }
    _getOrderedUniqueNames() {
        const uniqueNames = new Set();
        const orderedUniqueNames = [];
        let sum = 0;
        for (const counter of this._counters) {
            const containsCounter = uniqueNames.has(counter);
            if (!containsCounter) {
                uniqueNames.add(counter);
                orderedUniqueNames.push(counter);
                sum += counter?.length || 0;
            }
        }
        return [orderedUniqueNames, sum];
    }
    get isReadRequest() {
        return true;
    }
    async setResponseAsync(bodyStream, fromCache) {
        if (!bodyStream) {
            return;
        }
        let body = "";
        this.result = await this._defaultPipeline(_ => body += _).process(bodyStream);
        return body;
    }
}
//# sourceMappingURL=GetCountersOperation.js.map