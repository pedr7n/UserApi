import { GetOperationStateCommand } from "./GetOperationStateOperation.js";
import { throwError } from "../../Exceptions/index.js";
import { ExceptionDispatcher } from "../../Exceptions/index.js";
import { delay } from "../../Utility/PromiseUtil.js";
import { KillOperationCommand } from "../Commands/KillOperationCommand.js";
export class OperationCompletionAwaiter {
    _requestExecutor;
    _conventions;
    _id;
    _nodeTag;
    get id() {
        return this._id;
    }
    constructor(requestExecutor, conventions, id, nodeTag) {
        this._requestExecutor = requestExecutor;
        this._conventions = conventions;
        this._id = id;
        this._nodeTag = nodeTag;
    }
    async _fetchOperationStatus() {
        const command = this._getOperationStateCommand(this._conventions, this._id, this._nodeTag);
        await this._requestExecutor.execute(command);
        return command.result;
    }
    _getOperationStateCommand(conventions, id, nodeTag) {
        return new GetOperationStateCommand(this._id, nodeTag);
    }
    get nodeTag() {
        return this._nodeTag;
    }
    set nodeTag(nodeTag) {
        this._nodeTag = nodeTag;
    }
    waitForCompletion() {
        const operationStatusPolling = () => {
            return Promise.resolve()
                .then(() => this._fetchOperationStatus())
                .then((operationStatusResult) => {
                const operationStatus = operationStatusResult.status;
                switch (operationStatus) {
                    case "Completed": {
                        return;
                    }
                    case "Canceled": {
                        throwError("OperationCanceledException", `Operation of ID ${this._id} has been canceled.`);
                        break;
                    }
                    case "Faulted": {
                        const faultResult = operationStatusResult.result;
                        const errorSchema = Object.assign({}, faultResult, { url: this._requestExecutor.getUrl() });
                        throw ExceptionDispatcher.get(errorSchema, faultResult.statusCode);
                    }
                }
                return delay(500)
                    .then(() => operationStatusPolling());
            });
        };
        return Promise.resolve(operationStatusPolling());
    }
    _getKillOperationCommand(id, nodeTag) {
        return new KillOperationCommand(id, nodeTag);
    }
    async kill() {
        const command = this._getKillOperationCommand(this._id, this.nodeTag);
        await this._requestExecutor.execute(command);
    }
}
//# sourceMappingURL=OperationCompletionAwaiter.js.map