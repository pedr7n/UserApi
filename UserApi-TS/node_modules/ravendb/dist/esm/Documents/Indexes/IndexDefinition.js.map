{"version":3,"file":"IndexDefinition.js","sourceRoot":"","sources":["../../../../src/Documents/Indexes/IndexDefinition.ts"],"names":[],"mappings":"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","sourcesContent":["import { throwError } from \"../../Exceptions/index.js\";\r\nimport { IndexLockMode, IndexType } from \"./Enums.js\";\r\nimport { IndexFieldOptions } from \"./IndexFieldOptions.js\";\r\nimport { DocumentConventions } from \"../Conventions/DocumentConventions.js\";\r\nimport { IndexDefinitionHelper } from \"./IndexDefinitionHelper.js\";\r\nimport { AbstractIndexDefinitionBuilder } from \"./AbstractIndexDefinitionBuilder.js\";\r\nimport { IndexSourceType } from \"./IndexSourceType.js\";\r\nimport { AdditionalAssembly } from \"./AdditionalAssembly.js\";\r\nimport { IndexDeploymentMode } from \"./IndexDeploymentMode.js\";\r\nimport { IndexDefinitionBase } from \"./IndexDefinitionBase.js\";\r\nimport { ArchivedDataProcessingBehavior } from \"../DataArchival/ArchivedDataProcessingBehavior.js\";\r\n\r\nexport interface IndexConfiguration {\r\n    [key: string]: string;\r\n}\r\n\r\nexport class IndexDefinition extends IndexDefinitionBase {\r\n\r\n    /**\r\n     * Index lock mode:\r\n     * - Unlock - all index definition changes acceptable\r\n     * - LockedIgnore - all index definition changes will be ignored, only log entry will be created\r\n     * - LockedError - all index definition changes will raise exception\r\n     */\r\n    public lockMode: IndexLockMode;\r\n    public indexType: IndexType;\r\n    public additionalSources: { [key: string]: string } = {};\r\n    public compoundFields: string[][] = [];\r\n    public additionalAssemblies: AdditionalAssembly[] = [];\r\n    public maps: Set<string> = new Set();\r\n    public reduce: string;\r\n    public fields: { [fieldName: string]: IndexFieldOptions } = {};\r\n    private _indexSourceType: IndexSourceType;\r\n    public archivedDataProcessingBehavior: ArchivedDataProcessingBehavior;\r\n    public configuration: IndexConfiguration = {};\r\n    public outputReduceToCollection: string;\r\n    public reduceOutputIndex: number;\r\n    public patternForOutputReduceToCollectionReferences: string;\r\n    public patternReferencesCollectionName: string;\r\n    public deploymentMode: IndexDeploymentMode;\r\n\r\n    public toString(): string {\r\n        return this.name;\r\n    }\r\n\r\n    public detectStaticIndexSourceType(): IndexSourceType {\r\n        if (!this.maps || !this.maps.size) {\r\n            throwError(\"InvalidArgumentException\", \"Index definition contains no Maps\");\r\n        }\r\n\r\n        let sourceType: IndexSourceType = \"None\";\r\n        for (const map of this.maps) {\r\n            const mapSourceType = IndexDefinitionHelper.detectStaticIndexSourceType(map);\r\n            if (sourceType === \"None\") {\r\n                sourceType = mapSourceType;\r\n                continue;\r\n            }\r\n\r\n            if (sourceType !== mapSourceType) {\r\n                throwError(\"InvalidOperationException\", \"Index definition cannot contain maps with different source types.\");\r\n            }\r\n        }\r\n\r\n        return sourceType;\r\n    }\r\n\r\n    public get sourceType() {\r\n        if (!this._indexSourceType || this._indexSourceType === \"None\") {\r\n            this._indexSourceType = this.detectStaticIndexSourceType();\r\n        }\r\n\r\n        return this._indexSourceType;\r\n    }\r\n\r\n    public set sourceType(value: IndexSourceType) {\r\n        this._indexSourceType = value;\r\n    }\r\n\r\n    public get type(): IndexType {\r\n        if (!this.indexType || this.indexType === \"None\") {\r\n            this.indexType = this.detectStaticIndexType();\r\n        }\r\n\r\n        return this.indexType;\r\n    }\r\n\r\n    public set type(indexType) {\r\n        this.indexType = indexType;\r\n    }\r\n\r\n    public detectStaticIndexType(): IndexType {\r\n        const firstMap = this.maps.values().next().value;\r\n\r\n        if (!firstMap) {\r\n            throwError(\"InvalidArgumentException\", \"Index  definitions contains no Maps\");\r\n        }\r\n\r\n        return IndexDefinitionHelper.detectStaticIndexType(firstMap, this.reduce);\r\n    }\r\n}\r\n\r\nexport class IndexDefinitionBuilder extends AbstractIndexDefinitionBuilder<IndexDefinition>{\r\n\r\n    public map: string;\r\n    public archivedDataProcessingBehavior: ArchivedDataProcessingBehavior;\r\n\r\n    public constructor(indexName?: string) {\r\n        super(indexName);\r\n    }\r\n\r\n    protected _newIndexDefinition(): IndexDefinition {\r\n        return new IndexDefinition();\r\n    }\r\n\r\n    public toIndexDefinition(conventions: DocumentConventions, validateMap: boolean = true) {\r\n        if (!this.map && validateMap) {\r\n            throwError(\"InvalidArgumentException\",\r\n                \"Map is required to generate an index, you cannot create an index without a valid Map property (in index \" + this._indexName + \").\");\r\n        }\r\n\r\n        const indexDefinition = super.toIndexDefinition(conventions, validateMap);\r\n        indexDefinition.archivedDataProcessingBehavior = this.archivedDataProcessingBehavior;\r\n        return indexDefinition;\r\n    }\r\n\r\n    protected _toIndexDefinition(indexDefinition: IndexDefinition, conventions: DocumentConventions) {\r\n        if (!this.map) {\r\n            return;\r\n        }\r\n\r\n        indexDefinition.maps.add(this.map);\r\n    }\r\n}\r\n"]}