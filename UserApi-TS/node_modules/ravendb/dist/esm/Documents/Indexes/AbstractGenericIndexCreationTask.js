import { AbstractIndexCreationTaskBase } from "./AbstractIndexCreationTaskBase.js";
import { SpatialOptionsFactory } from "./Spatial.js";
import { CONSTANTS } from "../../Constants.js";
import { throwError } from "../../Exceptions/index.js";
/**
 * Base class for creating indexes
 */
export class AbstractGenericIndexCreationTask extends AbstractIndexCreationTaskBase {
    storesStrings;
    indexesStrings;
    analyzersStrings;
    indexSuggestions;
    termVectorsStrings;
    spatialOptionsStrings;
    vectorOptionsStrings;
    outputReduceToCollection;
    patternForOutputReduceToCollectionReferences;
    patternReferencesCollectionName;
    constructor() {
        super();
        this.storesStrings = {};
        this.indexesStrings = {};
        this.analyzersStrings = {};
        this.indexSuggestions = new Set();
        this.termVectorsStrings = {};
        this.spatialOptionsStrings = {};
        this.vectorOptionsStrings = {};
    }
    /**
     * Register a field to be indexed
     */
    index(field, indexing) {
        this.indexesStrings[field] = indexing;
    }
    /**
     * Register a field to be spatially indexed
     */
    spatial(field, indexing) {
        this.spatialOptionsStrings[field] = indexing(new SpatialOptionsFactory());
    }
    // TBD protected void Store(Expression<Func<TReduceResult, object>> field, FieldStorage storage)
    storeAllFields(storage) {
        this.storesStrings[CONSTANTS.Documents.Indexing.Fields.ALL_FIELDS] = storage;
    }
    /**
     * Register a field to be stored
     */
    store(field, storage) {
        this.storesStrings[field] = storage;
    }
    /**
     * Register a field to be analyzed
     */
    analyze(field, analyzer) {
        this.analyzersStrings[field] = analyzer;
    }
    /**
     * Register a field to have term vectors
     */
    termVector(field, termVector) {
        this.termVectorsStrings[field] = termVector;
    }
    suggestion(field) {
        this.indexSuggestions.add(field);
    }
    addAssembly(assembly) {
        if (!assembly) {
            throwError("InvalidArgumentException", "Assembly cannot be null");
        }
        if (!this.additionalAssemblies) {
            this.additionalAssemblies = [];
        }
        this.additionalAssemblies.push(assembly);
    }
    vectorField(field, vector) {
        this.vectorOptionsStrings[field] = vector;
    }
}
//# sourceMappingURL=AbstractGenericIndexCreationTask.js.map