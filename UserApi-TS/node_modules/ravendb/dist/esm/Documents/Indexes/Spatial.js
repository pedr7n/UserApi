import { throwError } from "../../Exceptions/index.js";
// about 4.78 meters at equator, should be good enough 
// (see: http://unterbahn.com/2009/11/metric-dimensions-of-geohash-partitions-at-the-equator/)
export const DEFAULT_GEOHASH_LEVEL = 9;
// about 4.78 meters at equator, should be good enough
export const DEFAULT_QUAD_TREE_LEVEL = 23;
export class SpatialOptions {
    type;
    strategy;
    maxTreeLevel;
    minX;
    maxX;
    minY;
    maxY;
    // Circle radius units, only used for geography  indexes
    units;
    constructor(options) {
        options = options || {};
        this.type = options.type || "Geography";
        this.strategy = options.strategy || "GeohashPrefixTree";
        this.maxTreeLevel = options.maxTreeLevel || DEFAULT_GEOHASH_LEVEL;
        this.minX = options.minX || -180;
        this.maxX = options.maxX || 180;
        this.minY = options.minY || -90;
        this.maxY = options.maxY || 90;
        this.units = options.units || "Kilometers";
    }
}
export class SpatialOptionsFactory {
    geography() {
        return new GeographySpatialOptionsFactory();
    }
    cartesian() {
        return new CartesianSpatialOptionsFactory();
    }
}
export class CartesianSpatialOptionsFactory {
    boundingBoxIndex() {
        const opts = new SpatialOptions();
        opts.type = "Cartesian";
        opts.strategy = "BoundingBox";
        return opts;
    }
    quadPrefixTreeIndex(maxTreeLevel, bounds) {
        if (maxTreeLevel === 0) {
            throwError("InvalidArgumentException", "maxTreeLevel can't be 0.");
        }
        const opts = new SpatialOptions();
        opts.type = "Cartesian";
        opts.maxTreeLevel = maxTreeLevel;
        opts.strategy = "QuadPrefixTree";
        opts.minX = bounds.minX;
        opts.minY = bounds.minY;
        opts.maxX = bounds.maxX;
        opts.maxY = bounds.maxY;
        return opts;
    }
}
export class SpatialBounds {
    minX;
    maxX;
    minY;
    maxY;
    constructor(minX, minY, maxX, maxY) {
        this.minX = minX;
        this.maxX = maxX;
        this.minY = minY;
        this.maxY = maxY;
    }
}
export class GeographySpatialOptionsFactory {
    /**
     * Defines a Geohash Prefix Tree index using a default Max Tree Level {@link SpatialOptions}
     */
    defaultOptions(circleRadiusUnits = "Kilometers") {
        return this.geohashPrefixTreeIndex(0, circleRadiusUnits);
    }
    boundingBoxIndex(circleRadiusUnits = "Kilometers") {
        const ops = new SpatialOptions();
        ops.type = "Geography";
        ops.strategy = "BoundingBox";
        ops.units = circleRadiusUnits;
        return ops;
    }
    geohashPrefixTreeIndex(maxTreeLevel, circleRadiusUnits = "Kilometers") {
        if (maxTreeLevel === 0) {
            maxTreeLevel = DEFAULT_GEOHASH_LEVEL;
        }
        const opts = new SpatialOptions();
        opts.type = "Geography";
        opts.maxTreeLevel = maxTreeLevel;
        opts.strategy = "GeohashPrefixTree";
        opts.units = circleRadiusUnits;
        return opts;
    }
    quadPrefixTreeIndex(maxTreeLevel, circleRadiusUnits = "Kilometers") {
        if (maxTreeLevel === 0) {
            maxTreeLevel = DEFAULT_QUAD_TREE_LEVEL;
        }
        const opts = new SpatialOptions();
        opts.type = "Geography";
        opts.maxTreeLevel = maxTreeLevel;
        opts.strategy = "QuadPrefixTree";
        opts.units = circleRadiusUnits;
        return opts;
    }
}
//# sourceMappingURL=Spatial.js.map