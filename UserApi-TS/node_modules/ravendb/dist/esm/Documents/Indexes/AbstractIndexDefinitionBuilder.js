import { throwError } from "../../Exceptions/index.js";
import { IndexFieldOptions } from "./IndexFieldOptions.js";
export class AbstractIndexDefinitionBuilder {
    _indexName;
    reduce;
    storesStrings;
    indexesStrings;
    analyzersStrings;
    suggestionsOptions;
    termVectorsStrings;
    spatialIndexesStrings;
    vectorFieldStrings;
    lockMode;
    priority;
    state;
    compoundFieldsStrings;
    deploymentMode;
    outputReduceToCollection;
    patternForOutputReduceToCollectionReferences;
    patternReferencesCollectionName;
    additionalSources;
    additionalAssemblies;
    configuration;
    // noinspection TypeScriptAbstractClassConstructorCanBeMadeProtected
    constructor(indexName) {
        this._indexName = indexName || this.constructor.name;
        if (this._indexName.length > 256) {
            throwError("InvalidArgumentException", "The index name is limited to 256 characters, but was: " + this._indexName);
        }
        this.storesStrings = {};
        this.indexesStrings = {};
        this.suggestionsOptions = new Set();
        this.analyzersStrings = {};
        this.termVectorsStrings = {};
        this.spatialIndexesStrings = {};
        this.vectorFieldStrings = {};
        this.configuration = {};
    }
    toIndexDefinition(conventions, validateMap = true) {
        try {
            const indexDefinition = this._newIndexDefinition();
            indexDefinition.name = this._indexName;
            indexDefinition.reduce = this.reduce;
            indexDefinition.lockMode = this.lockMode;
            indexDefinition.priority = this.priority;
            indexDefinition.deploymentMode = this.deploymentMode;
            indexDefinition.state = this.state;
            indexDefinition.outputReduceToCollection = this.outputReduceToCollection;
            indexDefinition.patternForOutputReduceToCollectionReferences = this.patternForOutputReduceToCollectionReferences;
            indexDefinition.patternReferencesCollectionName = this.patternReferencesCollectionName;
            indexDefinition.compoundFields = this.compoundFieldsStrings;
            const suggestions = Object.fromEntries(Array.from(this.suggestionsOptions)
                .map((item) => [item, true]));
            this._applyValues(indexDefinition, this.indexesStrings, (options, value) => options.indexing = value);
            this._applyValues(indexDefinition, this.storesStrings, (options, value) => options.storage = value);
            this._applyValues(indexDefinition, this.analyzersStrings, (options, value) => options.analyzer = value);
            this._applyValues(indexDefinition, this.termVectorsStrings, (options, value) => options.termVector = value);
            this._applyValues(indexDefinition, this.spatialIndexesStrings, (options, value) => options.spatial = value);
            this._applyValues(indexDefinition, suggestions, (options, value) => options.suggestions = value);
            this._applyValues(indexDefinition, this.vectorFieldStrings, (options, value) => options.vector = value);
            indexDefinition.additionalSources = this.additionalSources;
            indexDefinition.additionalAssemblies = this.additionalAssemblies;
            indexDefinition.configuration = this.configuration;
            this._toIndexDefinition(indexDefinition, conventions);
            return indexDefinition;
        }
        catch (err) {
            throwError("IndexCompilationException", "Failed to create index " + this._indexName, err);
        }
    }
    _applyValues(indexDefinition, values, action) {
        for (const fieldName of Object.keys(values)) {
            const fieldVal = values[fieldName];
            const field = indexDefinition.fields[fieldName] =
                indexDefinition.fields[fieldName] || new IndexFieldOptions();
            action(field, fieldVal);
        }
    }
}
//# sourceMappingURL=AbstractIndexDefinitionBuilder.js.map