import { AbstractIndexCreationTaskBase } from "./AbstractIndexCreationTaskBase.js";
import { FieldStorage, FieldIndexing, FieldTermVector } from "./Enums.js";
import { SpatialOptions, SpatialOptionsFactory } from "./Spatial.js";
import { IndexDefinition } from "./IndexDefinition.js";
import { AdditionalAssembly } from "./AdditionalAssembly.js";
import { FieldVectorOptions } from "../Queries/VectorSearch/VectorSearchOptions.js";
type FieldOrAllFields<TField> = TField | "__all_fields";
/**
 * Base class for creating indexes
 */
export declare abstract class AbstractGenericIndexCreationTask<TField extends string = string> extends AbstractIndexCreationTaskBase<IndexDefinition> {
    protected storesStrings: Record<FieldOrAllFields<TField>, FieldStorage>;
    protected indexesStrings: Record<FieldOrAllFields<TField>, FieldIndexing>;
    protected analyzersStrings: Record<FieldOrAllFields<TField>, string>;
    protected indexSuggestions: Set<FieldOrAllFields<TField>>;
    protected termVectorsStrings: Record<FieldOrAllFields<TField>, FieldTermVector>;
    protected spatialOptionsStrings: Record<FieldOrAllFields<TField>, SpatialOptions>;
    protected vectorOptionsStrings: Record<FieldOrAllFields<TField>, FieldVectorOptions>;
    protected outputReduceToCollection: string;
    protected patternForOutputReduceToCollectionReferences: string;
    protected patternReferencesCollectionName: string;
    constructor();
    abstract get isMapReduce(): boolean;
    /**
     * Register a field to be indexed
     */
    protected index(field: FieldOrAllFields<TField>, indexing: FieldIndexing): void;
    /**
     * Register a field to be spatially indexed
     */
    protected spatial(field: FieldOrAllFields<TField>, indexing: (spatialOptsFactory: SpatialOptionsFactory) => SpatialOptions): void;
    protected storeAllFields(storage: FieldStorage): void;
    /**
     * Register a field to be stored
     */
    protected store(field: TField, storage: FieldStorage): void;
    /**
     * Register a field to be analyzed
     */
    protected analyze(field: FieldOrAllFields<TField>, analyzer: string): void;
    /**
     * Register a field to have term vectors
     */
    protected termVector(field: FieldOrAllFields<TField>, termVector: FieldTermVector): void;
    protected suggestion(field: FieldOrAllFields<TField>): void;
    protected addAssembly(assembly: AdditionalAssembly): void;
    protected vectorField(field: FieldOrAllFields<TField>, vector: FieldVectorOptions): void;
}
export {};
//# sourceMappingURL=AbstractGenericIndexCreationTask.d.ts.map