{"version":3,"file":"AbstractSubscriptionWorker.js","sourceRoot":"","sources":["../../../../src/Documents/Subscriptions/AbstractSubscriptionWorker.ts"],"names":[],"mappings":"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","sourcesContent":["import { DocumentType } from \"../DocumentAbstractions.js\";\r\nimport { getLogger } from \"../../Utility/LogUtil.js\";\r\nimport { SubscriptionWorkerOptions } from \"./SubscriptionWorkerOptions.js\";\r\nimport { Socket } from \"node:net\";\r\nimport { pipeline, Readable, Transform } from \"node:stream\";\r\nimport { EventEmitter } from \"node:events\";\r\nimport { ServerNode } from \"../../Http/ServerNode.js\";\r\nimport { IRequestExecutorOptions, RequestExecutor } from \"../../Http/RequestExecutor.js\";\r\nimport { GetTcpInfoForRemoteTaskCommand } from \"../Commands/GetTcpInfoForRemoteTaskCommand.js\";\r\nimport { GetTcpInfoCommand, TcpConnectionInfo } from \"../../ServerWide/Commands/GetTcpInfoCommand.js\";\r\nimport { TcpUtils } from \"../../Utility/TcpUtils.js\";\r\nimport { getError, RavenErrorType, throwError } from \"../../Exceptions/index.js\";\r\nimport {\r\n    SUBSCRIPTION_TCP_VERSION,\r\n    SupportedFeatures,\r\n    TcpConnectionHeaderMessage\r\n} from \"../../ServerWide/Tcp/TcpConnectionHeaderMessage.js\";\r\nimport { TcpNegotiateParameters } from \"../../ServerWide/Tcp/TcpNegotiateParameters.js\";\r\nimport { OUT_OF_RANGE_STATUS, TcpNegotiation } from \"../../ServerWide/Tcp/TcpNegotiation.js\";\r\nimport { TimeUtil } from \"../../Utility/TimeUtil.js\";\r\nimport { Parser } from \"../../ext/stream-json/Parser.js\";\r\nimport { StreamValues } from \"../../ext/stream-json/streamers/StreamValues.js\";\r\nimport { TcpNegotiationResponse } from \"../../ServerWide/Tcp/TcpNegotiationResponse.js\";\r\nimport { TcpConnectionHeaderResponse } from \"../../ServerWide/Tcp/TcpConnectionHeaderResponse.js\";\r\nimport { ObjectUtil } from \"../../Utility/ObjectUtil.js\";\r\nimport { SubscriptionConnectionServerMessage } from \"./SubscriptionConnectionServerMessage.js\";\r\nimport { EOL } from \"../../Utility/OsUtil.js\";\r\nimport { BatchFromServer, CounterIncludeItem } from \"./BatchFromServer.js\";\r\nimport { SubscriptionBatchBase } from \"./SubscriptionBatchBase.js\";\r\nimport { delay, wrapWithTimeout } from \"../../Utility/PromiseUtil.js\";\r\nimport { EmptyCallback } from \"../../Types/Callbacks.js\";\r\nimport { randomUUID } from \"node:crypto\";\r\nimport { StringUtil } from \"../../Utility/StringUtil.js\";\r\nimport { ServerCasing, ServerResponse } from \"../../Types/index.js\";\r\nimport { DocumentConventions } from \"../Conventions/DocumentConventions.js\";\r\nimport { CONSTANTS } from \"../../Constants.js\";\r\nimport { SubscriptionWorker } from \"./SubscriptionWorker.js\";\r\n\r\ntype EventTypes = \"afterAcknowledgment\" | \"onEstablishedSubscriptionConnection\" | \"connectionRetry\" | \"batch\" | \"error\" | \"end\" | \"unexpectedSubscriptionError\";\r\n\r\nexport abstract class AbstractSubscriptionWorker<TBatch extends SubscriptionBatchBase<TType>, TType extends object> {\r\n    protected readonly _documentType: DocumentType<TType>;\r\n    protected readonly _revisions: boolean;\r\n    protected readonly _logger = getLogger({ module: \"SubscriptionWorker\" });\r\n\r\n    protected readonly _dbName: string;\r\n    protected _processingCanceled = false;\r\n    protected readonly _options: SubscriptionWorkerOptions<TType>;\r\n    private _tcpClient: Socket;\r\n    private _parser: Transform;\r\n    protected _disposed: boolean = false;\r\n    protected _subscriptionTask: Promise<void>;\r\n    protected _forcedTopologyUpdateAttempts = 0;\r\n    protected _emitter = new EventEmitter();\r\n\r\n    public constructor(options: SubscriptionWorkerOptions<TType>,\r\n                       withRevisions: boolean, dbName: string) {\r\n        this._documentType = options.documentType;\r\n        this._options = Object.assign({\r\n            strategy: \"OpenIfFree\",\r\n            maxDocsPerBatch: 4096,\r\n            timeToWaitBeforeConnectionRetry: 5 * 1000,\r\n            maxErroneousPeriod: 5 * 60 * 1000,\r\n            workerId: randomUUID()\r\n        }, options);\r\n        this._revisions = withRevisions;\r\n\r\n        if (StringUtil.isNullOrEmpty(options.subscriptionName)) {\r\n            throwError(\"InvalidArgumentException\", \"SubscriptionConnectionOptions must specify the subscriptionName\");\r\n        }\r\n\r\n        this._dbName = dbName;\r\n    }\r\n\r\n    public getWorkerId() {\r\n        return this._options.workerId;\r\n    }\r\n\r\n    public on(event: \"batch\",\r\n              handler: (value: TBatch, callback: EmptyCallback) => void): this;\r\n    public on(event: \"error\",\r\n              handler: (error?: Error) => void): this;\r\n    public on(event: \"end\",\r\n              handler: (error?: Error) => void): this;\r\n    public on(event: \"unexpectedSubscriptionError\",\r\n              handler: (error?: Error) => void): this;\r\n    public on(event: \"onEstablishedSubscriptionConnection\", handler: (value: SubscriptionWorker<any>) => void): this;\r\n    public on(event: \"afterAcknowledgment\",\r\n              handler: (value: TBatch, callback: EmptyCallback) => void): this;\r\n    public on(event: \"connectionRetry\",\r\n              handler: (error?: Error) => void): this;\r\n    public on(event: EventTypes,\r\n              handler:\r\n                  ((batchOrError: TBatch, callback: EmptyCallback) => void)\r\n                  | ((value: SubscriptionWorker<any>) => void)\r\n                  | ((error: Error) => void)): this {\r\n        this._emitter.on(event, handler);\r\n\r\n        if (event === \"batch\" && !this._subscriptionTask) {\r\n            this._subscriptionTask = this._runSubscriptionAsync()\r\n                .catch(err => { this._emitter.emit(\"error\", err); })\r\n                .then(() => { this._emitter.emit(\"end\"); });\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    public off(event: \"batch\", handler: (value: TBatch, callback: EmptyCallback) => void): this;\r\n    public off(event: \"error\", handler: (error?: Error) => void): this;\r\n    public off(event: \"unexpectedSubscriptionError\", handler: (error?: Error) => void): this;\r\n    public off(event: \"onEstablishedSubscriptionConnection\", handler: (value: SubscriptionWorker<any>) => void): this;\r\n    public off(event: \"end\", handler: (error?: Error) => void): this;\r\n    public off(event: \"afterAcknowledgment\", handler: (value: TBatch, callback: EmptyCallback) => void): this;\r\n    public off(event: \"connectionRetry\", handler: (error?: Error) => void): this;\r\n    public off(event: EventTypes,\r\n               handler:\r\n                   ((batchOrError: TBatch, callback: EmptyCallback) => void)\r\n                   | ((value: SubscriptionWorker<any>) => void)\r\n                   | ((error: Error) => void)): this {\r\n        this._emitter.removeListener(event, handler);\r\n        return this;\r\n    }\r\n\r\n    public removeListener(event: \"batch\", handler: (value: TBatch, callback: EmptyCallback) => void): this;\r\n    public removeListener(event: \"error\", handler: (error?: Error) => void): this;\r\n    public removeListener(event: \"unexpectedSubscriptionError\", handler: (error?: Error) => void): this;\r\n    public removeListener(event: \"onEstablishedSubscriptionConnection\", handler: (value: SubscriptionWorker<any>) => void): this;\r\n    public removeListener(event: \"end\", handler: (error?: Error) => void): this;\r\n    public removeListener(\r\n        event: \"afterAcknowledgment\", handler: (value: TBatch, callback: EmptyCallback) => void): this;\r\n    public removeListener(event: \"connectionRetry\", handler: (error?: Error) => void): this;\r\n    public removeListener(\r\n        event: EventTypes,\r\n        handler:\r\n            ((batchOrError: TBatch, callback: EmptyCallback) => void)\r\n            | ((value: SubscriptionWorker<any>) => void)\r\n            | ((error: Error) => void)): this {\r\n        this.removeListener(event as any, handler as any);\r\n        return this;\r\n    }\r\n\r\n    public dispose(): void {\r\n        if (this._disposed) {\r\n            return;\r\n        }\r\n\r\n        this._disposed = true;\r\n        this._processingCanceled = true;\r\n\r\n        this._closeTcpClient(); // we disconnect immediately\r\n        if (this._parser) {\r\n            this._parser.end();\r\n        }\r\n\r\n        this._subscriptionLocalRequestExecutor?.dispose();\r\n    }\r\n\r\n\r\n    private _redirectNode: ServerNode;\r\n    protected _subscriptionLocalRequestExecutor: RequestExecutor;\r\n    protected subscriptionTcpVersion: number;\r\n\r\n    public get currentNodeTag() {\r\n        return this._redirectNode ? this._redirectNode.clusterTag : null;\r\n    }\r\n\r\n    public get subscriptionName() {\r\n        return this._options ? this._options.subscriptionName : null;\r\n    }\r\n\r\n    protected _shouldUseCompression() {\r\n        let compressionSupport: boolean = false;\r\n\r\n        const version = this.subscriptionTcpVersion ?? SUBSCRIPTION_TCP_VERSION;\r\n        if (version >= 53_000 && !this.getRequestExecutor().conventions.isDisableTcpCompression) {\r\n            compressionSupport = true;\r\n        }\r\n\r\n        return compressionSupport;\r\n    }\r\n\r\n    private async _connectToServer(): Promise<Socket> {\r\n        const command = new GetTcpInfoForRemoteTaskCommand(\r\n            \"Subscription/\" + this._dbName, this._dbName,\r\n            this._options ? this._options.subscriptionName : null, true);\r\n\r\n        const requestExecutor = this.getRequestExecutor();\r\n\r\n        let tcpInfo: TcpConnectionInfo;\r\n\r\n        if (this._redirectNode) {\r\n            try {\r\n                await requestExecutor.execute(command, null, {\r\n                    chosenNode: this._redirectNode,\r\n                    nodeIndex: null,\r\n                    shouldRetry: false\r\n                });\r\n                tcpInfo = command.result;\r\n            } catch (e) {\r\n                if (e.name === \"ClientVersionMismatchException\") {\r\n                    tcpInfo = await this._legacyTryGetTcpInfo(requestExecutor, this._redirectNode);\r\n                } else {\r\n                    // if we failed to talk to a node, we'll forget about it and let the topology to\r\n                    // redirect us to the current node\r\n\r\n                    this._redirectNode = null;\r\n\r\n                    throw e;\r\n                }\r\n            }\r\n        } else {\r\n            try {\r\n                await requestExecutor.execute(command);\r\n                tcpInfo = command.result;\r\n\r\n                if (tcpInfo.nodeTag) {\r\n                    this._redirectNode = requestExecutor.getTopology().nodes\r\n                        .find(x => x.clusterTag === tcpInfo.nodeTag);\r\n                }\r\n            } catch (e) {\r\n                if (e.name === \"ClientVersionMismatchException\") {\r\n                    tcpInfo = await this._legacyTryGetTcpInfo(requestExecutor);\r\n                } else {\r\n                    throw e;\r\n                }\r\n            }\r\n        }\r\n\r\n        const result = await TcpUtils.connectSecuredTcpSocket(\r\n            tcpInfo,\r\n            command.result.certificate,\r\n            requestExecutor.getAuthOptions(),\r\n            \"Subscription\",\r\n            (chosenUrl, tcpInfo, socket) => this._negotiateProtocolVersionForSubscription(chosenUrl, tcpInfo, socket));\r\n\r\n        this._tcpClient = result.socket;\r\n\r\n        this._supportedFeatures = result.supportedFeatures;\r\n\r\n        if (this._supportedFeatures.protocolVersion <= 0) {\r\n            throwError(\"InvalidOperationException\",\r\n                this._options.subscriptionName\r\n                + \" : TCP negotiation resulted with an invalid protocol version: \"\r\n                + this._supportedFeatures.protocolVersion);\r\n        }\r\n\r\n        await this._sendOptions(this._tcpClient, this._options);\r\n\r\n        this.setLocalRequestExecutor(command.getRequestedNode().url, {\r\n            authOptions: requestExecutor.getAuthOptions(),\r\n            documentConventions: requestExecutor.conventions\r\n        });\r\n\r\n        return this._tcpClient;\r\n    }\r\n\r\n\r\n    private async _negotiateProtocolVersionForSubscription(chosenUrl: string, tcpInfo: TcpConnectionInfo, socket: Socket): Promise<SupportedFeatures> {\r\n\r\n\r\n        const parameters = {\r\n            database: this._dbName,\r\n            operation: \"Subscription\",\r\n            version: SUBSCRIPTION_TCP_VERSION,\r\n            readResponseAndGetVersionCallback: url => this._readServerResponseAndGetVersion(url, socket),\r\n            destinationNodeTag: this.currentNodeTag,\r\n            destinationUrl: chosenUrl,\r\n            destinationServerId: tcpInfo.serverId,\r\n            licensedFeatures: {\r\n                dataCompression: this._shouldUseCompression()\r\n            }\r\n        } as TcpNegotiateParameters;\r\n\r\n        return TcpNegotiation.negotiateProtocolVersion(socket, parameters);\r\n    }\r\n\r\n\r\n    private async _legacyTryGetTcpInfo(requestExecutor: RequestExecutor, node?: ServerNode) {\r\n        const tcpCommand = new GetTcpInfoCommand(\"Subscription/\" + this._dbName, this._dbName);\r\n        try {\r\n            if (node) {\r\n                await requestExecutor.execute<TcpConnectionInfo>(tcpCommand, null, {\r\n                    chosenNode: node,\r\n                    shouldRetry: false,\r\n                    nodeIndex: undefined\r\n                });\r\n            } else {\r\n                await requestExecutor.execute(tcpCommand, null);\r\n            }\r\n        } catch (e) {\r\n            this._redirectNode = null;\r\n            throw e;\r\n        }\r\n\r\n        return tcpCommand.result;\r\n    }\r\n\r\n    private async _sendOptions(socket: Socket, options: SubscriptionWorkerOptions<TType>) {\r\n        const payload = {\r\n            SubscriptionName: options.subscriptionName,\r\n            TimeToWaitBeforeConnectionRetry:\r\n                TimeUtil.millisToTimeSpan(options.timeToWaitBeforeConnectionRetry),\r\n            IgnoreSubscriberErrors: options.ignoreSubscriberErrors || false,\r\n            Strategy: options.strategy,\r\n            MaxDocsPerBatch: options.maxDocsPerBatch,\r\n            MaxErroneousPeriod:\r\n                TimeUtil.millisToTimeSpan(options.maxErroneousPeriod),\r\n            CloseWhenNoDocsLeft: options.closeWhenNoDocsLeft || false,\r\n        };\r\n\r\n        return new Promise<void>(resolve => {\r\n            socket.write(JSON.stringify(payload, null, 0), () => resolve());\r\n        });\r\n    }\r\n\r\n    private async _ensureParser(socket: Socket): Promise<void> {\r\n        const conventions = this.getRequestExecutor().conventions;\r\n        const revisions = this._revisions;\r\n\r\n        const keysTransform = new Transform({\r\n            objectMode: true,\r\n            transform(chunk, encoding, callback) {\r\n                let value = chunk[\"value\"];\r\n                if (!value) {\r\n                    return callback();\r\n                }\r\n\r\n                value = SubscriptionWorker._mapToLocalObject(value, revisions, conventions);\r\n\r\n                callback(null, {...chunk, value});\r\n            }\r\n        });\r\n\r\n        this._parser = pipeline([\r\n            socket,\r\n            new Parser({ jsonStreaming: true, streamValues: false }),\r\n            new StreamValues(),\r\n            keysTransform\r\n        ], err => {\r\n            if (err && !socket.destroyed) {\r\n                this._emitter.emit(\"error\", err);\r\n            }\r\n        }) as Transform;\r\n\r\n        this._parser.pause();\r\n    }\r\n\r\n    // noinspection JSUnusedLocalSymbols\r\n    private async _readServerResponseAndGetVersion(url: string, socket: Socket): Promise<TcpNegotiationResponse> {\r\n        await this._ensureParser(socket);\r\n        const x: any = await this._readNextObject();\r\n        switch (x.status) {\r\n            case \"Ok\": {\r\n                return {\r\n                    version: x.version,\r\n                    licensedFeatures: x.licensedFeatures\r\n                }\r\n            }\r\n            case \"AuthorizationFailed\": {\r\n                throwError(\"AuthorizationException\",\r\n                    \"Cannot access database \" + this._dbName + \" because \" + x.message);\r\n                return;\r\n            }\r\n            case \"TcpVersionMismatch\": {\r\n                if (x.version !== OUT_OF_RANGE_STATUS) {\r\n                    return {\r\n                        version: x.version,\r\n                        licensedFeatures: x.licensedFeatures\r\n                    }\r\n                }\r\n\r\n                //Kindly request the server to drop the connection\r\n                await this._sendDropMessage(x.value);\r\n                throwError(\"InvalidOperationException\",\r\n                    \"Can't connect to database \" + this._dbName + \" because: \" + x.message);\r\n                break;\r\n            }\r\n            case \"InvalidNetworkTopology\": {\r\n                throwError(\"InvalidNetworkTopologyException\", \"Failed to connect to url \" + url + \" because \" + x.message);\r\n            }\r\n        }\r\n\r\n        return {\r\n            version: x.version,\r\n            licensedFeatures: x.licensedFeatures\r\n        };\r\n    }\r\n\r\n\r\n    private _sendDropMessage(reply: TcpConnectionHeaderResponse): Promise<void> {\r\n        const dropMsg = {\r\n            operation: \"Drop\",\r\n            databaseName: this._dbName,\r\n            operationVersion: SUBSCRIPTION_TCP_VERSION,\r\n            info: \"Couldn't agree on subscription tcp version ours: \"\r\n                + SUBSCRIPTION_TCP_VERSION + \" theirs: \" + reply.version\r\n        } as TcpConnectionHeaderMessage;\r\n\r\n        const payload = ObjectUtil.transformObjectKeys(dropMsg, {\r\n            defaultTransform: ObjectUtil.pascal\r\n        });\r\n\r\n        return new Promise<void>(resolve => {\r\n            this._tcpClient.write(JSON.stringify(payload, null, 0), () => resolve());\r\n        });\r\n    }\r\n\r\n    private _assertConnectionState(connectionStatus: SubscriptionConnectionServerMessage) {\r\n        if (connectionStatus.type === \"Error\") {\r\n            if (connectionStatus.exception.includes(\"DatabaseDoesNotExistException\")) {\r\n                throwError(\"DatabaseDoesNotExistException\",\r\n                    this._dbName + \" does not exists. \" + connectionStatus.message);\r\n            }\r\n        }\r\n\r\n        if (connectionStatus.type !== \"ConnectionStatus\") {\r\n            let message = \"Server returned illegal type message when expecting connection status, was:\" + connectionStatus.type;\r\n\r\n            if (connectionStatus.type === \"Error\") {\r\n                message += \". Exception: \" + connectionStatus.exception;\r\n            }\r\n            throwError(\"InvalidOperationException\", message);\r\n        }\r\n\r\n        // noinspection FallThroughInSwitchStatementJS\r\n        switch (connectionStatus.status) {\r\n            case \"Accepted\": {\r\n                break;\r\n            }\r\n            case \"InUse\": {\r\n                throwError(\"SubscriptionInUseException\",\r\n                    \"Subscription with id '\" + this._options.subscriptionName\r\n                    + \"' cannot be opened, because it's in use and the connection strategy is \"\r\n                    + this._options.strategy);\r\n                break;\r\n            }\r\n            case \"Closed\": {\r\n                const canReconnect = connectionStatus.data.CanReconnect || false;\r\n                const subscriptionClosedError = getError(\"SubscriptionClosedException\",\r\n                    \"Subscription with id '\" + this._options.subscriptionName\r\n                    + \"' was closed. \" + connectionStatus.exception);\r\n                (subscriptionClosedError as any).canReconnect = canReconnect;\r\n                throw subscriptionClosedError;\r\n            }\r\n            case \"Invalid\": {\r\n                throwError(\"SubscriptionInvalidStateException\",\r\n                    \"Subscription with id '\" + this._options.subscriptionName\r\n                    + \"' cannot be opened, because it is in invalid state. \" + connectionStatus.exception);\r\n                break;\r\n            }\r\n            case \"NotFound\": {\r\n                throwError(\"SubscriptionDoesNotExistException\",\r\n                    \"Subscription with id '\" + this._options.subscriptionName\r\n                    + \"' cannot be opened, because it does not exist. \" + connectionStatus.exception);\r\n                break;\r\n            }\r\n            case \"Redirect\": {\r\n                if (this._options.strategy === \"WaitForFree\") {\r\n                    if (connectionStatus.data) {\r\n                        const registerConnectionDurationInTicks = connectionStatus.data[\"RegisterConnectionDurationInTicks\"];\r\n                        if (registerConnectionDurationInTicks / 10_000 >= this._options.maxErroneousPeriod) {\r\n                            // this worker connection Waited For Free for more than MaxErroneousPeriod\r\n                            this._lastConnectionFailure = null;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                const data = connectionStatus.data;\r\n                const appropriateNode = data.redirectedTag;\r\n                const currentNode = data.currentTag;\r\n                const reasons = data.reasons;\r\n\r\n                const error = getError(\"SubscriptionDoesNotBelongToNodeException\",\r\n                    \"Subscription with id '\" + this._options.subscriptionName\r\n                    + \"' cannot be processed by current node '\" + currentNode + \"', it will be redirected to \" + appropriateNode + EOL + reasons);\r\n                (error as any).appropriateNode = appropriateNode;\r\n                throw error;\r\n            }\r\n            case \"ConcurrencyReconnect\": {\r\n                throwError(\"SubscriptionChangeVectorUpdateConcurrencyException\", connectionStatus.message);\r\n                break;\r\n            }\r\n            default: {\r\n                throwError(\"InvalidOperationException\",\r\n                    \"Subscription '\" + this._options.subscriptionName\r\n                    + \"' could not be opened, reason: \" + connectionStatus.status);\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    private async _processSubscription() {\r\n\r\n\r\n        try {\r\n            if (this._processingCanceled) {\r\n                throwError(\"OperationCanceledException\");\r\n            }\r\n\r\n            const socket = await this._connectToServer();\r\n\r\n            try {\r\n                if (this._processingCanceled) {\r\n                    throwError(\"OperationCanceledException\");\r\n                }\r\n\r\n                const tcpClientCopy = this._tcpClient;\r\n                const connectionStatus: SubscriptionConnectionServerMessage = await this._readNextObject();\r\n\r\n                if (this._processingCanceled) {\r\n                    return;\r\n                }\r\n\r\n                if (connectionStatus.type !== \"ConnectionStatus\" || connectionStatus.status !== \"Accepted\") {\r\n                    this._assertConnectionState(connectionStatus);\r\n                }\r\n\r\n                this._lastConnectionFailure = null;\r\n\r\n                if (this._processingCanceled) {\r\n                    return;\r\n                }\r\n\r\n                this._emitter.emit(\"onEstablishedSubscriptionConnection\", this);\r\n\r\n                await this._processSubscriptionInternal(tcpClientCopy);\r\n            } finally {\r\n                socket.end();\r\n                this._parser.end();\r\n            }\r\n        } catch (err) {\r\n            if (!this._disposed) {\r\n                throw err;\r\n            }\r\n\r\n            // otherwise this is thrown when shutting down,\r\n            // it isn't an error, so we don't need to treat it as such\r\n        }\r\n    }\r\n\r\n    private async _processSubscriptionInternal(tcpClientCopy: Socket) {\r\n\r\n        let notifiedSubscriber = Promise.resolve();\r\n\r\n        try {\r\n            const batch = this.createEmptyBatch();\r\n\r\n            while (!this._processingCanceled) {\r\n                await this._prepareBatch(tcpClientCopy, batch, notifiedSubscriber);\r\n                // start reading next batch from server on 1'st thread (can be before client started processing)\r\n\r\n                notifiedSubscriber = this._emitBatchAndWaitForProcessing(batch)\r\n                    .catch((err) => {\r\n                        this._logger.error(err, \"Subscription \" + this._options.subscriptionName\r\n                            + \". Subscriber threw an exception on document batch\");\r\n\r\n                        if (!this._options.ignoreSubscriberErrors) {\r\n                            throwError(\"SubscriberErrorException\",\r\n                                \"Subscriber threw an exception in subscription \"\r\n                                + this._options.subscriptionName, err);\r\n                        }\r\n                    })\r\n                    .then(() => {\r\n                        if (tcpClientCopy && tcpClientCopy.writable) {\r\n                            return this._sendAck(batch, tcpClientCopy);\r\n                        }\r\n                    });\r\n            }\r\n        } finally {\r\n            try {\r\n                await notifiedSubscriber;\r\n            } catch (e) {\r\n                //ignored\r\n            }\r\n\r\n            try {\r\n                await wrapWithTimeout(notifiedSubscriber, 15_000);\r\n            } catch {\r\n                // ignore\r\n            }\r\n        }\r\n    }\r\n\r\n    private async _prepareBatch(tcpClientCopy: Socket, batch: TBatch, notifiedSubscriber: Promise<void>): Promise<BatchFromServer> {\r\n        const readFromServer = this._readSingleSubscriptionBatchFromServer(batch);\r\n\r\n        try {\r\n            // and then wait for the subscriber to complete\r\n            await notifiedSubscriber;\r\n        } catch (err) {\r\n            // if the subscriber errored, we shut down\r\n            this._closeTcpClient();\r\n\r\n            // noinspection ExceptionCaughtLocallyJS\r\n            throw err;\r\n        }\r\n\r\n        const incomingBatch = await readFromServer;\r\n\r\n        if (this._processingCanceled) {\r\n            throwError(\"OperationCanceledException\");\r\n        }\r\n\r\n        batch.initialize(incomingBatch);\r\n\r\n        return incomingBatch;\r\n    }\r\n\r\n\r\n    private async _emitBatchAndWaitForProcessing(batch): Promise<void> {\r\n        return new Promise<void>((resolve, reject) => {\r\n            let listenerCount = this._emitter.listenerCount(\"batch\");\r\n            this._emitter.emit(\"batch\", batch, (error?: any) => {\r\n                if (error) {\r\n                    reject(error);\r\n                } else {\r\n                    listenerCount--;\r\n                    if (!listenerCount) {\r\n                        resolve();\r\n                    }\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    private async _readSingleSubscriptionBatchFromServer(batch: TBatch):\r\n        Promise<BatchFromServer> {\r\n        const incomingBatch = [] as SubscriptionConnectionServerMessage[];\r\n        const includes: any[] = [];\r\n        const counterIncludes: CounterIncludeItem[] = [];\r\n        const timeSeriesIncludes: any = [];\r\n\r\n        let endOfBatch = false;\r\n\r\n        while (!endOfBatch && !this._processingCanceled) {\r\n            const receivedMessage = await this._readNextObject();\r\n            if (!receivedMessage || this._processingCanceled) {\r\n                break;\r\n            }\r\n\r\n            switch (receivedMessage.type) {\r\n                case \"Data\": {\r\n                    incomingBatch.push(receivedMessage);\r\n                    break;\r\n                }\r\n                case \"Includes\": {\r\n                    includes.push(receivedMessage.includes);\r\n                    break;\r\n                }\r\n                case \"CounterIncludes\": {\r\n                    counterIncludes.push({ counterIncludes: receivedMessage.includedCounterNames, includes: receivedMessage.counterIncludes });\r\n                    break;\r\n                }\r\n                case \"TimeSeriesIncludes\": {\r\n                    timeSeriesIncludes.push(receivedMessage.timeSeriesIncludes);\r\n                    break;\r\n                }\r\n                case \"EndOfBatch\": {\r\n                    endOfBatch = true;\r\n                    break;\r\n                }\r\n                case \"Confirm\": {\r\n                    this._emitter.emit(\"afterAcknowledgment\", batch);\r\n\r\n                    incomingBatch.length = 0;\r\n                    batch.items.length = 0;\r\n                    break;\r\n                }\r\n                case \"ConnectionStatus\": {\r\n                    this._assertConnectionState(receivedMessage);\r\n                    break;\r\n                }\r\n                case \"Error\": {\r\n                    this._throwSubscriptionError(receivedMessage);\r\n                    break;\r\n                }\r\n                default: {\r\n                    this._throwInvalidServerResponse(receivedMessage);\r\n                    break;\r\n                }\r\n\r\n            }\r\n        }\r\n        return {\r\n            messages: incomingBatch,\r\n            includes,\r\n            counterIncludes,\r\n            timeSeriesIncludes\r\n        };\r\n    }\r\n\r\n\r\n    private _throwInvalidServerResponse(receivedMessage: SubscriptionConnectionServerMessage) {\r\n        throwError(\"InvalidArgumentException\",\r\n            \"Unrecognized message \" + receivedMessage.type + \" type received from server\");\r\n    }\r\n\r\n    private _throwSubscriptionError(receivedMessage: SubscriptionConnectionServerMessage) {\r\n        throwError(\"InvalidOperationException\",\r\n            \"Connection terminated by server. Exception: \" + (receivedMessage.exception || \"None\"));\r\n    }\r\n\r\n    private async _readNextObject(): Promise<SubscriptionConnectionServerMessage> {\r\n        const stream: Readable = this._parser;\r\n        if (this._processingCanceled) {\r\n            return null;\r\n        }\r\n\r\n        if (this._disposed) { // if we are disposed, nothing to do...\r\n            return null;\r\n        }\r\n\r\n        if (stream.readable) {\r\n            const data: { key: number, value: SubscriptionConnectionServerMessage } = stream.read() as any;\r\n            if (data) {\r\n                return data.value;\r\n            }\r\n        }\r\n\r\n        return new Promise<void>((resolve, reject) => {\r\n            stream.once(\"readable\", readableListener);\r\n            stream.once(\"error\", errorHandler);\r\n            stream.once(\"end\", endHandler);\r\n\r\n            function readableListener() {\r\n                stream.removeListener(\"error\", errorHandler);\r\n                stream.removeListener(\"end\", endHandler);\r\n                resolve();\r\n            }\r\n\r\n            function errorHandler(err) {\r\n                stream.removeListener(\"readable\", readableListener);\r\n                stream.removeListener(\"end\", endHandler);\r\n                reject(err);\r\n            }\r\n\r\n            function endHandler() {\r\n                stream.removeListener(\"readable\", readableListener);\r\n                stream.removeListener(\"error\", errorHandler);\r\n                reject(getError(\"SubscriptionException\", \"Subscription stream has ended unexpectedly.\"));\r\n            }\r\n        })\r\n            .then(() => this._readNextObject());\r\n    }\r\n\r\n    private async _sendAck(batch: TBatch, networkStream: Socket): Promise<void> {\r\n        const payload = {\r\n            ChangeVector: batch.lastSentChangeVectorInBatch,\r\n            Type: \"Acknowledge\"\r\n        };\r\n\r\n        return new Promise<void>((resolve, reject) => {\r\n            networkStream.write(JSON.stringify(payload, null, 0), (err) => {\r\n                err ? reject(err) : resolve();\r\n            });\r\n        });\r\n    }\r\n\r\n\r\n    private async _runSubscriptionAsync(): Promise<void> {\r\n        while (!this._processingCanceled) {\r\n            try {\r\n                this._closeTcpClient();\r\n\r\n                this._logger.info(\"Subscription \" + this._options.subscriptionName + \". Connecting to server...\");\r\n                await this._processSubscription();\r\n            } catch (error) {\r\n                if (this._processingCanceled) {\r\n                    if (!this._disposed) {\r\n                        throw error;\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                this._logger.warn(error, \"Subscription \"\r\n                    + this._options.subscriptionName + \". Pulling task threw the following exception. \");\r\n\r\n                if (this._shouldTryToReconnect(error)) {\r\n                    await delay(this._options.timeToWaitBeforeConnectionRetry);\r\n\r\n                    if (!this._redirectNode) {\r\n                        const reqEx = this.getRequestExecutor();\r\n                        const curTopology = reqEx.getTopologyNodes();\r\n                        const nextNodeIndex = (this._forcedTopologyUpdateAttempts++) % curTopology.length;\r\n                        try {\r\n                            const indexAndNode = await reqEx.getRequestedNode(curTopology[nextNodeIndex].clusterTag, true);\r\n                            this._redirectNode = indexAndNode.currentNode;\r\n\r\n                            this._logger.info(\"Subscription \" + this._options.subscriptionName + \". Will modify redirect node from null to \" + this._redirectNode.clusterTag);\r\n                        } catch {\r\n                            // will let topology to decide\r\n                            this._logger.info(\"Subscription '\" + this._options.subscriptionName + \"'. Could not select the redirect node will keep it null.\");\r\n                        }\r\n                    }\r\n\r\n                    this._emitter.emit(\"connectionRetry\", error);\r\n                } else {\r\n                    this._logger.error(error, \"Connection to subscription \"\r\n                        + this._options.subscriptionName + \" have been shut down because of an error.\");\r\n\r\n                    throw error;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    private _lastConnectionFailure: Date;\r\n    private _supportedFeatures: SupportedFeatures;\r\n\r\n    private _assertLastConnectionFailure(lastError: Error) {\r\n        if (!this._lastConnectionFailure) {\r\n            this._lastConnectionFailure = new Date();\r\n            return;\r\n        }\r\n\r\n        const maxErroneousPeriod =  this._options.maxErroneousPeriod;\r\n        const erroneousPeriodDuration = Date.now() - this._lastConnectionFailure.getTime();\r\n        if (erroneousPeriodDuration > maxErroneousPeriod) {\r\n            throwError(\"SubscriptionInvalidStateException\",\r\n                \"Subscription connection was in invalid state for more than \"\r\n                + maxErroneousPeriod + \" and therefore will be terminated.\", lastError);\r\n        }\r\n    }\r\n\r\n\r\n\r\n    private _shouldTryToReconnect(ex: Error) {\r\n        if (ex.name === (\"SubscriptionDoesNotBelongToNodeException\" as RavenErrorType)) {\r\n\r\n            const requestExecutor = this.getRequestExecutor();\r\n\r\n            const appropriateNode = (ex as any).appropriateNode;\r\n            if (!appropriateNode) {\r\n                this._assertLastConnectionFailure(ex);\r\n                this._redirectNode = null;\r\n                return true;\r\n            }\r\n\r\n            const nodeToRedirectTo = requestExecutor.getTopologyNodes()\r\n                .find(x => x.clusterTag === appropriateNode);\r\n\r\n            if (!nodeToRedirectTo) {\r\n                throwError(\"InvalidOperationException\",\r\n                    \"Could not redirect to \" + appropriateNode\r\n                    + \", because it was not found in local topology, even after retrying\");\r\n            }\r\n\r\n            this._redirectNode = nodeToRedirectTo;\r\n            return true;\r\n        } else if (ex.name === \"DatabaseDisabledException\" || ex.name === \"AllTopologyNodesDownException\") {\r\n            this._assertLastConnectionFailure(ex);\r\n            return true;\r\n        } else if (ex.name === \"NodeIsPassiveException\") {\r\n            // if we failed to talk to a node, we'll forget about it and let the topology to\r\n            // redirect us to the current node\r\n            this._redirectNode = null;\r\n            return true;\r\n        } else if (ex.name === \"SubscriptionChangeVectorUpdateConcurrencyException\") {\r\n            return true;\r\n        } else if (ex.name === \"SubscriptionClosedException\") {\r\n            if ((ex as any).canReconnect) {\r\n                return true;\r\n            }\r\n\r\n            this._processingCanceled = true;\r\n            return false;\r\n        }\r\n\r\n        if (ex.name === \"SubscriptionInUseException\"\r\n            || ex.name === \"SubscriptionDoesNotExistException\"\r\n            || ex.name === \"SubscriptionInvalidStateException\"\r\n            || ex.name === \"DatabaseDoesNotExistException\"\r\n            || ex.name === \"AuthorizationException\"\r\n            || ex.name === \"SubscriberErrorException\") {\r\n            this._processingCanceled = true;\r\n            return false;\r\n        }\r\n\r\n        this._emitter.emit(\"unexpectedSubscriptionError\", ex);\r\n\r\n        this._assertLastConnectionFailure(ex);\r\n        return true;\r\n    }\r\n\r\n    private _closeTcpClient() {\r\n        if (this._tcpClient) {\r\n            this._tcpClient.end();\r\n        }\r\n    }\r\n\r\n    protected abstract getRequestExecutor(): RequestExecutor;\r\n\r\n    protected abstract setLocalRequestExecutor(url: string, opts: IRequestExecutorOptions): void;\r\n\r\n    protected abstract createEmptyBatch(): TBatch;\r\n\r\n    protected abstract trySetRedirectNodeOnConnectToServer(): void;\r\n\r\n    private static _mapToLocalObject(json: ServerCasing<ServerResponse<SubscriptionConnectionServerMessage>>, revisions: boolean, conventions: DocumentConventions): SubscriptionConnectionServerMessage {\r\n        const { Data, Includes, CounterIncludes, TimeSeriesIncludes, ...rest } = json;\r\n\r\n        let data: any;\r\n        if (Data) {\r\n            if (revisions) {\r\n                data = {\r\n                    current: ObjectUtil.transformDocumentKeys(Data.Current, conventions),\r\n                    previous: ObjectUtil.transformDocumentKeys(Data.Previous, conventions),\r\n                    [CONSTANTS.Documents.Metadata.KEY]: ObjectUtil.transformMetadataKeys(Data[CONSTANTS.Documents.Metadata.KEY], conventions)\r\n                }\r\n            } else {\r\n                data = ObjectUtil.transformDocumentKeys(Data, conventions);\r\n            }\r\n        }\r\n\r\n        return {\r\n            ...ObjectUtil.transformObjectKeys(rest, {\r\n                defaultTransform: ObjectUtil.camel\r\n            }),\r\n            data,\r\n            includes: ObjectUtil.mapIncludesToLocalObject(Includes, conventions),\r\n            counterIncludes: ObjectUtil.mapCounterIncludesToLocalObject(CounterIncludes),\r\n            timeSeriesIncludes: ObjectUtil.mapTimeSeriesIncludesToLocalObject(TimeSeriesIncludes),\r\n        } as SubscriptionConnectionServerMessage;\r\n    }\r\n\r\n}"]}