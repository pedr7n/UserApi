import { getLogger } from "../../Utility/LogUtil.js";
import { throwError } from "../../Exceptions/index.js";
import { CONSTANTS } from "../../Constants.js";
import { StringUtil } from "../../Utility/StringUtil.js";
import { createMetadataDictionary } from "../../Mapping/MetadataAsDictionary.js";
import { EntityToJson } from "../Session/EntityToJson.js";
import { EOL } from "../../Utility/OsUtil.js";
export class SubscriptionBatchBase {
    _documentType;
    _revisions;
    lastSentChangeVectorInBatch;
    _requestExecutor;
    _dbName;
    _logger = getLogger({ module: "SubscriptionBatch" });
    _items = [];
    _includes;
    _counterIncludes;
    _timeSeriesIncludes;
    get items() {
        return this._items;
    }
    getNumberOfItemsInBatch() {
        return this._items ? this._items.length : 0;
    }
    getNumberOfIncludes() {
        return this._includes ? this._includes.length : 0;
    }
    constructor(documentType, revisions, requestExecutor, dbName) {
        this._documentType = documentType;
        this._revisions = revisions;
        this._requestExecutor = requestExecutor;
        this._dbName = dbName;
    }
    initialize(batch) {
        this._includes = batch.includes;
        this._counterIncludes = batch.counterIncludes;
        this._timeSeriesIncludes = batch.timeSeriesIncludes;
        this._items.length = 0;
        let lastReceivedChangeVector;
        for (const item of batch.messages) {
            const curDoc = item.data;
            const metadata = curDoc[CONSTANTS.Documents.Metadata.KEY];
            if (!metadata) {
                SubscriptionBatchBase._throwRequired("@metadata field");
            }
            const id = metadata[CONSTANTS.Documents.Metadata.ID];
            if (!id) {
                SubscriptionBatchBase._throwRequired("@id field");
            }
            const changeVector = metadata[CONSTANTS.Documents.Metadata.CHANGE_VECTOR];
            if (!changeVector) {
                SubscriptionBatchBase._throwRequired("@change-vector field");
            }
            lastReceivedChangeVector = changeVector;
            const projection = metadata[CONSTANTS.Documents.Metadata.PROJECTION] ?? false;
            this._logger.info("Got " + id + " (change vector: [" + lastReceivedChangeVector + "]");
            let instance = null;
            if (!item.exception) {
                instance = EntityToJson.convertToEntity(this._documentType, id, curDoc, this._requestExecutor.conventions);
                if (!StringUtil.isNullOrEmpty(id)) {
                    this.ensureDocumentId(instance, id);
                }
                // TODO: check if something's missing here
                // https://github.com/ravendb/ravendb-jvm-client/blob/v4.1/src/main/java/net/ravendb/client/documents/subscriptions/SubscriptionBatch.java#L222
            }
            const itemToAdd = new Item();
            itemToAdd.changeVector = changeVector;
            itemToAdd.id = id;
            itemToAdd.rawResult = curDoc;
            itemToAdd.rawMetadata = metadata;
            itemToAdd.result = instance;
            itemToAdd.exceptionMessage = item.exception;
            itemToAdd.projection = projection;
            itemToAdd.revision = this._revisions;
            itemToAdd.metadata = createMetadataDictionary({ raw: metadata });
            this._items.push(itemToAdd);
        }
    }
    static _throwRequired(name) {
        throwError("InvalidOperationException", "Document must have a " + name);
    }
}
/**
 * Represents a single item in a subscription batch results.
 */
export class Item {
    _result;
    exceptionMessage;
    id;
    changeVector;
    projection;
    revision;
    metadata;
    _throwItemProcessError() {
        throwError("InvalidOperationException", "Failed to process document " + this.id + " with Change Vector "
            + this.changeVector + " because: " + EOL + this.exceptionMessage);
    }
    get result() {
        if (this.exceptionMessage) {
            this._throwItemProcessError();
        }
        return this._result;
    }
    set result(result) {
        this._result = result;
    }
    rawResult;
    rawMetadata;
}
//# sourceMappingURL=SubscriptionBatchBase.js.map