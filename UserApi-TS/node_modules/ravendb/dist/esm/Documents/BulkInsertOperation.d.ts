import { Readable, Stream } from "node:stream";
import { RavenCommand } from "../Http/RavenCommand.js";
import { HttpRequestParameters } from "../Primitives/Http.js";
import { IMetadataDictionary } from "./Session/IMetadataDictionary.js";
import { IDocumentStore } from "./IDocumentStore.js";
import { ServerNode } from "../Http/ServerNode.js";
import { IDisposable } from "../Types/Contracts.js";
import { TypedTimeSeriesEntry } from "./Session/TimeSeries/TypedTimeSeriesEntry.js";
import { EntityConstructor } from "../Types/index.js";
import { Timer } from "../Primitives/Timer.js";
import { BulkInsertOnProgressEventArgs } from "./Session/SessionEvents.js";
import { Buffer } from "node:buffer";
import { BulkInsertOperationBase } from "./BulkInsert/BulkInsertOperationBase.js";
import { BulkInsertOptions } from "./BulkInsert/BulkInsertOptions.js";
import { HttpCompressionAlgorithm } from "../Http/HttpCompressionAlgorithm.js";
export declare class BulkInsertOperation extends BulkInsertOperationBase<object> {
    private static _countersBulkInsertOperationClass;
    private static _timeSeriesBulkInsertBaseClass;
    private static _timeSeriesBulkInsertClass;
    private static _typedTimeSeriesBulkInsertClass;
    private static _attachmentsBulkInsertClass;
    private static _attachmentsBulkInsertOperationClass;
    private _emitter;
    private _options;
    private _database;
    private readonly _generateEntityIdOnTheClient;
    private readonly _requestExecutor;
    private _inProgressCommand;
    private readonly _countersOperation;
    private readonly _attachmentsOperation;
    private _nodeTag;
    private readonly _timeSeriesBatchSize;
    private _concurrentCheck;
    private _first;
    private _useCompression;
    private _unsubscribeChanges;
    private _onProgressInitialized;
    private _timer;
    private readonly _streamLock;
    private _heartbeatCheckInterval;
    private _writer;
    private readonly _conventions;
    private readonly _store;
    constructor(database: string, store: IDocumentStore, options?: BulkInsertOptions);
    private static _handleHeartbeat;
    private sendHeartBeat;
    private static _checkServerVersion;
    on(event: "progress", handler: (value: BulkInsertOnProgressEventArgs) => void): this;
    off(event: "progress", handler: (value: BulkInsertOnProgressEventArgs) => void): this;
    get useCompression(): boolean;
    set useCompression(value: boolean);
    private static _throwNoDatabase;
    protected _waitForId(): Promise<void>;
    private static _typeCheckStoreArgs;
    /**
     * Synchronous version of store. It stores the entity unless the buffer is full
     * (then false is returned, and you are expected to call await store() ).
     *
     * Usage pattern:
     *
     * ```
     * if (!tryStoreSync(entity, id)) {
     *     await store(entity, id);
     * }
     * ```
     * @param entity Entity
     * @param id Document ID
     */
    tryStoreSync(entity: object, id: string): boolean;
    tryStoreSync(entity: object, id: string, metadata: IMetadataDictionary): boolean;
    store(entity: object): Promise<void>;
    store(entity: object, id: string): Promise<void>;
    store(entity: object, metadata: IMetadataDictionary): Promise<void>;
    store(entity: object, id: string, metadata: IMetadataDictionary): Promise<void>;
    private handleMetadata;
    private _writeToStream;
    private _handleErrors;
    private _concurrencyCheck;
    private _endPreviousCommandIfNeeded;
    private _writeString;
    private _writeComma;
    private static _verifyValidId;
    protected _getExceptionFromOperation(): Promise<Error>;
    protected _ensureStream(): Promise<void>;
    abort(): Promise<void>;
    finish(): Promise<void>;
    private _getId;
    attachmentsFor(id: string): IAttachmentsBulkInsert;
    countersFor(id: string): ICountersBulkInsert;
    timeSeriesFor(id: string, name: any): ITimeSeriesBulkInsert;
    timeSeriesFor<T extends object>(clazz: EntityConstructor<T>, id: string): ITypedTimeSeriesBulkInsert<T>;
    timeSeriesFor<T extends object>(clazz: EntityConstructor<T>, id: string, name: string): ITypedTimeSeriesBulkInsert<T>;
    private _typedTimeSeriesFor;
    private _timeSeriesFor;
    private static _validateTimeSeriesName;
    private isFlushNeeded;
    private flushIfNeeded;
    private isHeartbeatIntervalExceeded;
    private static readonly _countersBulkInsertClass;
}
export interface ICountersBulkInsert {
    increment(name: string): Promise<void>;
    increment(name: string, delta: number): Promise<void>;
}
export interface ITimeSeriesBulkInsert extends IDisposable {
    append(timestamp: Date, value: number): Promise<void>;
    append(timestamp: Date, value: number, tag: string): Promise<void>;
    append(timestamp: Date, values: number[]): Promise<void>;
    append(timestamp: Date, values: number[], tag: string): Promise<void>;
}
export interface ITypedTimeSeriesBulkInsert<T extends object> extends IDisposable {
    append(timestamp: Date, value: T): Promise<void>;
    append(timestamp: Date, value: T, tag: string): Promise<void>;
    append(entry: TypedTimeSeriesEntry<T>): Promise<void>;
}
export interface IAttachmentsBulkInsert {
    store(name: string, bytes: Buffer): Promise<void>;
    store(name: string, bytes: Buffer, contentType: string): Promise<void>;
}
export declare class BulkInsertCommand extends RavenCommand<void> {
    get isReadRequest(): boolean;
    private readonly _stream;
    private _skipOverwriteIfUnchanged;
    private readonly _id;
    private _compressionAlgorithm;
    constructor(id: number, compressionAlgorithm: HttpCompressionAlgorithm, stream: Readable, nodeTag: string, skipOverwriteIfUnchanged: boolean);
    createRequest(node: ServerNode): HttpRequestParameters;
    setResponseAsync(bodyStream: Stream, fromCache: boolean): Promise<string>;
}
export interface TimerState {
    parent: BulkInsertOperation;
    timer: Timer;
}
//# sourceMappingURL=BulkInsertOperation.d.ts.map