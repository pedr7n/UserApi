import { GenerateEntityIdOnTheClient } from "./Identity/GenerateEntityIdOnTheClient.js";
import { RavenCommand } from "../Http/RavenCommand.js";
import { MetadataInternal } from "../Mapping/MetadataAsDictionary.js";
import { CONSTANTS, HEADERS } from "../Constants.js";
import { getError, throwError } from "../Exceptions/index.js";
import { GetOperationStateCommand } from "./Operations/GetOperationStateOperation.js";
import { StringUtil } from "../Utility/StringUtil.js";
import { JsonSerializer } from "../Mapping/Json/Serializer.js";
import { GetNextOperationIdCommand } from "./Commands/GetNextOperationIdCommand.js";
import { DocumentInfo } from "./Session/DocumentInfo.js";
import { EntityToJson } from "./Session/EntityToJson.js";
import { KillOperationCommand } from "./Commands/KillOperationCommand.js";
import { TypeUtil } from "../Utility/TypeUtil.js";
import { TypedTimeSeriesEntry } from "./Session/TimeSeries/TypedTimeSeriesEntry.js";
import { TimeSeriesOperations } from "./TimeSeries/TimeSeriesOperations.js";
import { TimeSeriesValuesHelper } from "./Session/TimeSeries/TimeSeriesValuesHelper.js";
import { Timer } from "../Primitives/Timer.js";
import { EventEmitter } from "node:events";
import { BulkInsertOnProgressEventArgs } from "./Session/SessionEvents.js";
import { acquireSemaphore } from "../Utility/SemaphoreUtil.js";
import { Semaphore } from "../Utility/Semaphore.js";
import { BulkInsertOperationBase } from "./BulkInsert/BulkInsertOperationBase.js";
import { BulkInsertWriter } from "./BulkInsert/BulkInsertWriter.js";
export class BulkInsertOperation extends BulkInsertOperationBase {
    static _countersBulkInsertOperationClass = class CountersBulkInsertOperation {
        _operation;
        _id;
        _first = true;
        static MAX_COUNTERS_IN_BATCH = 1024;
        _countersInBatch = 0;
        constructor(bulkInsertOperation) {
            this._operation = bulkInsertOperation;
        }
        async increment(id, name, delta = 1) {
            const check = await this._operation._concurrencyCheck();
            try {
                await this._operation._executeBeforeStore();
                if (this._operation._inProgressCommand === "TimeSeries") {
                    BulkInsertOperation._timeSeriesBulkInsertBaseClass.throwAlreadyRunningTimeSeries();
                }
                try {
                    const isFirst = !this._id;
                    if (isFirst || !StringUtil.equalsIgnoreCase(this._id, id)) {
                        if (!isFirst) {
                            //we need to end the command for the previous document id
                            this._operation._writer.write("]}},");
                        }
                        else if (!this._operation._first) {
                            this._operation._writeComma();
                        }
                        this._operation._first = false;
                        this._id = id;
                        this._operation._inProgressCommand = "Counters";
                        this._writePrefixForNewCommand();
                    }
                    if (this._countersInBatch >= CountersBulkInsertOperation.MAX_COUNTERS_IN_BATCH) {
                        this._operation._writer.write("]}},");
                        this._writePrefixForNewCommand();
                    }
                    this._countersInBatch++;
                    if (!this._first) {
                        this._operation._writeComma();
                    }
                    this._first = false;
                    this._operation._writer.write(`{"Type":"Increment","CounterName":"`);
                    this._operation._writeString(name);
                    this._operation._writer.write(`","Delta":`);
                    this._operation._writer.write(delta.toString());
                    this._operation._writer.write("}");
                    await this._operation.flushIfNeeded();
                }
                catch (e) {
                    this._operation._handleErrors(this._id, e);
                }
            }
            finally {
                check.dispose();
            }
        }
        endPreviousCommandIfNeeded() {
            if (!this._id) {
                return;
            }
            this._operation._writer.write("]}}");
            this._id = null;
        }
        _writePrefixForNewCommand() {
            this._first = true;
            this._countersInBatch = 0;
            this._operation._writer.write(`{"Id":"`);
            this._operation._writeString(this._id);
            this._operation._writer.write(`","Type":"Counters","Counters":{"DocumentId":"`);
            this._operation._writeString(this._id);
            this._operation._writer.write(`","Operations":[`);
        }
    };
    static _timeSeriesBulkInsertBaseClass = class TimeSeriesBulkInsertBase {
        _operation;
        _id;
        _name;
        _first = true;
        _timeSeriesInBatch = 0;
        constructor(operation, id, name) {
            operation._endPreviousCommandIfNeeded();
            this._operation = operation;
            this._id = id;
            this._name = name;
            this._operation._inProgressCommand = "TimeSeries";
        }
        async _appendInternal(timestamp, values, tag) {
            const check = await this._operation._concurrencyCheck();
            try {
                await this._operation._executeBeforeStore();
                try {
                    if (this._first) {
                        if (!this._operation._first) {
                            this._operation._writeComma();
                        }
                        this._writePrefixForNewCommand();
                    }
                    else if (this._timeSeriesInBatch >= this._operation._timeSeriesBatchSize) {
                        this._operation._writer.write("]}},");
                        this._writePrefixForNewCommand();
                    }
                    this._timeSeriesInBatch++;
                    if (!this._first) {
                        this._operation._writeComma();
                    }
                    this._first = false;
                    this._operation._writer.write("[");
                    this._operation._writer.write(timestamp.getTime().toString());
                    this._operation._writeComma();
                    this._operation._writer.write(values.length.toString());
                    this._operation._writeComma();
                    let firstValue = true;
                    for (const value of values) {
                        if (!firstValue) {
                            this._operation._writeComma();
                        }
                        firstValue = false;
                        this._operation._writer.write(((value ?? 0).toString()));
                    }
                    if (tag) {
                        this._operation._writer.write(`,"`);
                        this._operation._writeString(tag);
                        this._operation._writer.write(`"`);
                    }
                    this._operation._writer.write("]");
                    await this._operation.flushIfNeeded();
                }
                catch (e) {
                    this._operation._handleErrors(this._id, e);
                }
            }
            finally {
                check.dispose();
            }
        }
        _writePrefixForNewCommand() {
            this._first = true;
            this._timeSeriesInBatch = 0;
            this._operation._writer.write(`{"Id":"`);
            this._operation._writeString(this._id);
            this._operation._writer.write(`","Type":"TimeSeriesBulkInsert","TimeSeries":{"Name":"`);
            this._operation._writeString(this._name);
            this._operation._writer.write(`","TimeFormat":"UnixTimeInMs","Appends":[`);
        }
        static throwAlreadyRunningTimeSeries() {
            throwError("BulkInsertInvalidOperationException", "There is an already running time series operation, did you forget to close it?");
        }
        dispose() {
            this._operation._inProgressCommand = "None";
            if (!this._first) {
                this._operation._writer.write("]}}");
            }
        }
    };
    static _timeSeriesBulkInsertClass = class TimeSeriesBulkInsert extends BulkInsertOperation._timeSeriesBulkInsertBaseClass {
        constructor(operation, id, name) {
            super(operation, id, name);
        }
        append(timestamp, valueOrValues, tag) {
            if (TypeUtil.isArray(valueOrValues)) {
                return this._appendInternal(timestamp, valueOrValues, tag);
            }
            else {
                return this._appendInternal(timestamp, [valueOrValues], tag);
            }
        }
    };
    static _typedTimeSeriesBulkInsertClass = class TypedTimeSeriesBulkInsert extends BulkInsertOperation._timeSeriesBulkInsertBaseClass {
        clazz;
        constructor(operation, clazz, id, name) {
            super(operation, id, name);
            this.clazz = clazz;
        }
        append(timestampOrEntry, value, tag) {
            if (timestampOrEntry instanceof TypedTimeSeriesEntry) {
                return this.append(timestampOrEntry.timestamp, timestampOrEntry.value, timestampOrEntry.tag);
            }
            else {
                const values = TimeSeriesValuesHelper.getValues(this.clazz, value);
                return this._appendInternal(timestampOrEntry, values, tag);
            }
        }
    };
    static _attachmentsBulkInsertClass = class AttachmentsBulkInsert {
        _operation;
        _id;
        constructor(operation, id) {
            this._operation = operation;
            this._id = id;
        }
        store(name, bytes, contentType) {
            return this._operation._attachmentsOperation.store(this._id, name, bytes, contentType);
        }
    };
    static _attachmentsBulkInsertOperationClass = class AttachmentsBulkInsertOperation {
        _operation;
        constructor(operation) {
            this._operation = operation;
        }
        async store(id, name, bytes, contentType) {
            const check = await this._operation._concurrencyCheck();
            try {
                this._operation._endPreviousCommandIfNeeded();
                await this._operation._executeBeforeStore();
                try {
                    if (!this._operation._first) {
                        this._operation._writeComma();
                    }
                    this._operation._writer.write(`{"Id":"`);
                    this._operation._writeString(id);
                    this._operation._writer.write(`","Type":"AttachmentPUT","Name":"`);
                    this._operation._writeString(name);
                    if (contentType) {
                        this._operation._writer.write(`","ContentType":"`);
                        this._operation._writeString(contentType);
                    }
                    this._operation._writer.write(`","ContentLength":`);
                    this._operation._writer.write(bytes.length.toString());
                    this._operation._writer.write("}");
                    await this._operation.flushIfNeeded();
                    this._operation._writer.write(bytes);
                    await this._operation.flushIfNeeded();
                }
                catch (e) {
                    this._operation._handleErrors(id, e);
                }
            }
            finally {
                check.dispose();
            }
        }
    };
    _emitter = new EventEmitter();
    _options;
    _database;
    _generateEntityIdOnTheClient;
    _requestExecutor;
    _inProgressCommand;
    _countersOperation = new BulkInsertOperation._countersBulkInsertOperationClass(this);
    _attachmentsOperation = new BulkInsertOperation._attachmentsBulkInsertOperationClass(this);
    _nodeTag;
    _timeSeriesBatchSize;
    _concurrentCheck = 0;
    _first = true;
    _useCompression = false;
    _unsubscribeChanges;
    _onProgressInitialized = false;
    _timer;
    _streamLock;
    _heartbeatCheckInterval = 40_000;
    _writer;
    _conventions;
    _store;
    constructor(database, store, options) {
        super();
        if (StringUtil.isNullOrEmpty(database)) {
            BulkInsertOperation._throwNoDatabase();
        }
        this._useCompression = options ? options.useCompression : false;
        this._options = options ?? {};
        this._database = database;
        this._conventions = store.conventions;
        this._store = store;
        this._requestExecutor = store.getRequestExecutor(database);
        this._writer = new BulkInsertWriter();
        this._writer.initialize();
        this._timeSeriesBatchSize = this._conventions.bulkInsert.timeSeriesBatchSize;
        this._generateEntityIdOnTheClient = new GenerateEntityIdOnTheClient(this._requestExecutor.conventions, entity => this._requestExecutor.conventions.generateDocumentId(database, entity));
        this._streamLock = new Semaphore(1);
        const timerState = {
            parent: this,
            timer: null
        };
        this._timer = new Timer(() => BulkInsertOperation._handleHeartbeat(timerState), this._heartbeatCheckInterval, this._heartbeatCheckInterval);
        timerState.timer = this._timer;
    }
    static async _handleHeartbeat(timerState) {
        const bulkInsert = timerState.parent;
        if (!bulkInsert) {
            timerState.timer.dispose();
            return;
        }
        await bulkInsert.sendHeartBeat();
    }
    async sendHeartBeat() {
        if (!this.isHeartbeatIntervalExceeded()) {
            return;
        }
        const context = acquireSemaphore(this._streamLock, {
            timeout: 0
        });
        try {
            await context.promise;
        }
        catch {
            return; // if locked we are already writing
        }
        try {
            await this._executeBeforeStore();
            this._endPreviousCommandIfNeeded();
            if (!BulkInsertOperation._checkServerVersion(this._requestExecutor.lastServerVersion)) {
                return;
            }
            if (!this._first) {
                this._writeComma();
            }
            this._first = false;
            this._inProgressCommand = "None";
            this._writer.write("{\"Type\":\"HeartBeat\"}");
            await this.flushIfNeeded(true);
        }
        catch {
            //Ignore the heartbeat if failed
        }
        finally {
            context.dispose();
        }
    }
    static _checkServerVersion(serverVersion) {
        if (serverVersion) {
            const versionParsed = serverVersion.split(".");
            const major = Number.parseInt(versionParsed[0], 10);
            const minor = versionParsed.length > 1 ? Number.parseInt(versionParsed[1]) : 0;
            const build = versionParsed.length > 2 ? Number.parseInt(versionParsed[2]) : 0;
            if (Number.isNaN(major) || Number.isNaN(minor)) {
                return false;
            }
            // version 6 only from 6.0.2
            if (major === 6 && minor > 0) {
                return true;
            }
            if (major === 6 && build < 2) {
                return false;
            }
            // 5.4.108 or higher
            return major > 5 || (major == 5 && minor >= 4 && build >= 110);
        }
        return false;
    }
    on(event, handler) {
        this._emitter.on("progress", handler);
        this._onProgressInitialized = true;
        return this;
    }
    off(event, handler) {
        this._emitter.off("progress", handler);
        return this;
    }
    get useCompression() {
        return this._useCompression;
    }
    set useCompression(value) {
        this._useCompression = value;
    }
    static _throwNoDatabase() {
        throwError("BulkInsertInvalidOperationException", "Cannot start bulk insert operation without specifying a name of a database to operate on."
            + "Database name can be passed as an argument when bulk insert is being created or default database can be defined using 'DocumentStore.setDatabase' method.");
    }
    async _waitForId() {
        if (this._operationId !== -1) {
            return;
        }
        const bulkInsertGetIdRequest = new GetNextOperationIdCommand();
        await this._requestExecutor.execute(bulkInsertGetIdRequest);
        this._operationId = bulkInsertGetIdRequest.result;
        this._nodeTag = bulkInsertGetIdRequest.nodeTag;
        if (this._onProgressInitialized && !this._unsubscribeChanges) {
            const observable = this._store.changes(this._database, this._nodeTag)
                .forOperationId(this._operationId);
            const handler = value => {
                const state = value.state;
                if (state && state.status === "InProgress") {
                    this._emitter.emit("progress", new BulkInsertOnProgressEventArgs(state.progress));
                }
            };
            observable.on("data", handler);
            this._unsubscribeChanges = {
                dispose() {
                    observable.off("data", handler);
                }
            };
        }
    }
    static _typeCheckStoreArgs(idOrMetadata, optionalMetadata) {
        let id;
        let metadata;
        let getId = false;
        if (typeof idOrMetadata === "string" || optionalMetadata) {
            id = idOrMetadata;
            metadata = optionalMetadata;
        }
        else {
            metadata = idOrMetadata;
            if (metadata && (CONSTANTS.Documents.Metadata.ID in metadata)) {
                id = metadata[CONSTANTS.Documents.Metadata.ID];
            }
        }
        if (!id) {
            getId = true;
        }
        return { id, metadata, getId };
    }
    tryStoreSync(entity, id, metadata) {
        if (this.isFlushNeeded() || this._first) {
            return false;
        }
        BulkInsertOperation._verifyValidId(id);
        metadata = this.handleMetadata(metadata, entity);
        this._endPreviousCommandIfNeeded();
        this._writeToStream(entity, id, metadata, "PUT");
        return true;
    }
    async store(entity, idOrMetadata, optionalMetadata) {
        const check = await this._concurrencyCheck();
        let id;
        try {
            const opts = BulkInsertOperation._typeCheckStoreArgs(idOrMetadata, optionalMetadata);
            let metadata = opts.metadata;
            id = opts.getId ? await this._getId(entity) : opts.id;
            BulkInsertOperation._verifyValidId(id);
            await this._executeBeforeStore();
            metadata = this.handleMetadata(metadata, entity);
            this._endPreviousCommandIfNeeded();
            try {
                this._writeToStream(entity, id, metadata, "PUT");
                await this.flushIfNeeded();
            }
            catch (e) {
                this._handleErrors(id, e);
            }
        }
        finally {
            check.dispose();
        }
    }
    handleMetadata(metadata, entity) {
        if (!metadata) {
            metadata = new MetadataInternal({});
        }
        if (!("@collection" in metadata)) {
            const collection = this._requestExecutor.conventions.getCollectionNameForEntity(entity);
            if (collection) {
                metadata["@collection"] = collection;
            }
        }
        if (!("Raven-Node-Type" in metadata)) {
            const descriptor = this._conventions.getTypeDescriptorByEntity(entity);
            const jsType = this._requestExecutor.conventions.getJsTypeName(descriptor);
            if (jsType) {
                metadata["Raven-Node-Type"] = jsType;
            }
        }
        return metadata;
    }
    // in node.js we handle errors outside of this method
    _writeToStream(entity, id, metadata, type) {
        if (this._first) {
            this._first = false;
        }
        else {
            this._writeComma();
        }
        this._inProgressCommand = "None";
        const documentInfo = new DocumentInfo();
        documentInfo.metadataInstance = metadata;
        let json = EntityToJson.convertEntityToJson(entity, this._conventions, documentInfo, true);
        json = this._conventions.transformObjectKeysToRemoteFieldNameConvention(json);
        this._writer.write(`{"Id":"`);
        this._writeString(id);
        const jsonString = JsonSerializer.getDefault().serialize(json);
        this._writer.write(`","Type":"PUT","Document":${jsonString}}`);
    }
    _handleErrors(documentId, e) {
        if (e.name === "BulkInsertClientException") {
            throw e;
        }
        const error = this._getExceptionFromOperation();
        if (error) {
            throw error;
        }
        throwError("InvalidOperationException", "Bulk insert error, Document Id: " + documentId, e);
    }
    async _concurrencyCheck() {
        if (this._concurrentCheck) {
            throwError("BulkInsertInvalidOperationException", "Bulk Insert store methods cannot be executed concurrently.");
        }
        this._concurrentCheck = 1;
        const context = acquireSemaphore(this._streamLock);
        await context.promise;
        return {
            dispose: () => {
                context.dispose();
                this._concurrentCheck = 0;
            }
        };
    }
    _endPreviousCommandIfNeeded() {
        if (this._inProgressCommand === "Counters") {
            this._countersOperation.endPreviousCommandIfNeeded();
        }
        else if (this._inProgressCommand === "TimeSeries") {
            BulkInsertOperation._timeSeriesBulkInsertBaseClass.throwAlreadyRunningTimeSeries();
        }
    }
    _writeString(input) {
        for (let i = 0; i < input.length; i++) {
            const c = input[i];
            if (`"` === c) {
                if (i === 0 || input[i - 1] !== `\\`) {
                    this._writer.write("\\");
                }
            }
            this._writer.write(c);
        }
    }
    _writeComma() {
        this._writer.write(",");
    }
    static _verifyValidId(id) {
        if (StringUtil.isNullOrEmpty(id)) {
            throwError("BulkInsertInvalidOperationException", "Document id must have a non empty value." +
                "If you want to store object literals with empty id, please register convention here: store.conventions.findCollectionNameForObjectLiteral");
        }
        if (id.endsWith("|")) {
            throwError("NotSupportedException", "Document ids cannot end with '|', but was called with " + id);
        }
    }
    async _getExceptionFromOperation() {
        const stateRequest = new GetOperationStateCommand(this._operationId, this._nodeTag);
        await this._requestExecutor.execute(stateRequest);
        if (!stateRequest.result) {
            return null;
        }
        const result = stateRequest.result["result"];
        if (stateRequest.result["status"] !== "Faulted") {
            return null;
        }
        return getError("BulkInsertAbortedException", result.error);
    }
    async _ensureStream() {
        const compressionAlgorithm = this._useCompression ? this._conventions.httpCompressionAlgorithm : null;
        await this._writer.ensureStream(compressionAlgorithm);
        const bulkCommand = new BulkInsertCommand(this._operationId, compressionAlgorithm, this._writer.compressedStream ?? this._writer.requestBodyStream, this._nodeTag, this._options.skipOverwriteIfUnchanged);
        this._bulkInsertExecuteTask = this._requestExecutor.execute(bulkCommand);
        this._bulkInsertExecuteTask
            .catch(() => this._bulkInsertExecuteTaskErrored = true);
    }
    async abort() {
        if (this._operationId !== -1) {
            await this._waitForId();
            try {
                await this._requestExecutor.execute(new KillOperationCommand(this._operationId, this._nodeTag));
            }
            catch (err) {
                throwError("BulkInsertAbortedException", "Unable to kill bulk insert operation, because it was not found on the server.", err);
            }
        }
    }
    async finish() {
        if (this._writer.requestBodyStreamFinished) {
            return;
        }
        this._timer?.dispose(); // in node.js we destroy timer in different place
        this._endPreviousCommandIfNeeded();
        let flushEx;
        try {
            const context = acquireSemaphore(this._streamLock);
            await context.promise;
            try {
                await this._writer.dispose();
            }
            finally {
                context.dispose();
            }
        }
        catch (e) {
            flushEx = e;
        }
        if (this._operationId === -1) {
            // closing without calling a single store.
            return;
        }
        if (this._bulkInsertExecuteTask) {
            try {
                await this._bulkInsertExecuteTask;
            }
            catch (e) {
                await this._throwBulkInsertAborted(e, flushEx);
            }
        }
        if (this._unsubscribeChanges) {
            this._unsubscribeChanges.dispose();
        }
    }
    async _getId(entity) {
        let idRef;
        if (this._generateEntityIdOnTheClient.tryGetIdFromInstance(entity, id => idRef = id)) {
            return idRef;
        }
        idRef = await this._generateEntityIdOnTheClient.generateDocumentKeyForStorage(entity);
        this._generateEntityIdOnTheClient.trySetIdentity(entity, idRef); // set id property if it was null;
        return idRef;
    }
    attachmentsFor(id) {
        if (StringUtil.isNullOrEmpty(id)) {
            throwError("InvalidArgumentException", "Document id cannot be null or empty");
        }
        return new BulkInsertOperation._attachmentsBulkInsertClass(this, id);
    }
    countersFor(id) {
        if (StringUtil.isNullOrEmpty(id)) {
            throwError("InvalidArgumentException", "Document id cannot be null or empty");
        }
        return new BulkInsertOperation._countersBulkInsertClass(this, id);
    }
    timeSeriesFor(classOrId, idOrName, name) {
        if (TypeUtil.isString(classOrId)) {
            return this._timeSeriesFor(classOrId, idOrName);
        }
        else {
            return this._typedTimeSeriesFor(classOrId, idOrName, name);
        }
    }
    _typedTimeSeriesFor(clazz, id, name = null) {
        if (StringUtil.isNullOrEmpty(id)) {
            throwError("InvalidArgumentException", "Document id cannot be null or empty");
        }
        let tsName = name;
        if (!tsName) {
            tsName = TimeSeriesOperations.getTimeSeriesName(clazz, this._conventions);
        }
        BulkInsertOperation._validateTimeSeriesName(tsName);
        return new BulkInsertOperation._typedTimeSeriesBulkInsertClass(this, clazz, id, tsName);
    }
    _timeSeriesFor(id, name) {
        if (StringUtil.isNullOrEmpty(id)) {
            throwError("InvalidArgumentException", "Document id cannot be null or empty");
        }
        BulkInsertOperation._validateTimeSeriesName(name);
        return new BulkInsertOperation._timeSeriesBulkInsertClass(this, id, name);
    }
    static _validateTimeSeriesName(name) {
        if (StringUtil.isNullOrEmpty(name)) {
            throwError("InvalidArgumentException", "Time series name cannot be null or empty");
        }
        if (StringUtil.startsWithIgnoreCase(name, HEADERS.INCREMENTAL_TIME_SERIES_PREFIX) && !name.includes("@")) {
            throwError("InvalidArgumentException", "Time Series name cannot start with " + HEADERS.INCREMENTAL_TIME_SERIES_PREFIX + " prefix");
        }
    }
    isFlushNeeded() {
        return this._writer.isFlushNeeded();
    }
    async flushIfNeeded(force = false) {
        force = force || this.isHeartbeatIntervalExceeded();
        return this._writer.flushIfNeeded(force);
    }
    isHeartbeatIntervalExceeded() {
        return Date.now() - this._writer.lastFlushToStream.getTime() >= this._heartbeatCheckInterval;
    }
    static _countersBulkInsertClass = class CountersBulkInsert {
        _operation;
        _id;
        constructor(operation, id) {
            this._operation = operation;
            this._id = id;
        }
        increment(name, delta = 1) {
            return this._operation._countersOperation.increment(this._id, name, delta);
        }
    };
}
export class BulkInsertCommand extends RavenCommand {
    get isReadRequest() {
        return false;
    }
    _stream;
    _skipOverwriteIfUnchanged;
    _id;
    _compressionAlgorithm;
    constructor(id, compressionAlgorithm, stream, nodeTag, skipOverwriteIfUnchanged) {
        super();
        this._compressionAlgorithm = compressionAlgorithm;
        this._stream = stream;
        this._id = id;
        this._selectedNodeTag = nodeTag;
        this._skipOverwriteIfUnchanged = skipOverwriteIfUnchanged;
    }
    createRequest(node) {
        const uri = node.url
            + "/databases/" + node.database
            + "/bulk_insert?id=" + this._id
            + "&skipOverwriteIfUnchanged=" + (this._skipOverwriteIfUnchanged ? "true" : "false");
        const headersBuilder = this._headers().typeAppJson();
        if (this._compressionAlgorithm === "Gzip") {
            headersBuilder.with("Content-Encoding", "gzip");
        }
        const headers = headersBuilder.build();
        return {
            method: "POST",
            uri,
            body: this._stream,
            duplex: "half",
            headers
        };
    }
    async setResponseAsync(bodyStream, fromCache) {
        return throwError("NotImplementedException", "Not implemented");
    }
}
//# sourceMappingURL=BulkInsertOperation.js.map