import { TypeUtil } from "../../Utility/TypeUtil.js";
import { ConfigureTimeSeriesValueNamesOperation } from "../Operations/TimeSeries/ConfigureTimeSeriesValueNamesOperation.js";
import { throwError } from "../../Exceptions/index.js";
import { TimeSeriesPolicy } from "../Operations/TimeSeries/TimeSeriesPolicy.js";
import { ConfigureTimeSeriesPolicyOperation } from "../Operations/TimeSeries/ConfigureTimeSeriesPolicyOperation.js";
import { StringUtil } from "../../Utility/StringUtil.js";
import { RawTimeSeriesPolicy } from "../Operations/TimeSeries/RawTimeSeriesPolicy.js";
import { ConfigureRawTimeSeriesPolicyOperation } from "../Operations/TimeSeries/ConfigureRawTimeSeriesPolicyOperation.js";
import { RemoveTimeSeriesPolicyOperation } from "../Operations/TimeSeries/RemoveTimeSeriesPolicyOperation.js";
import { TimeSeriesValuesHelper } from "../Session/TimeSeries/TimeSeriesValuesHelper.js";
export class TimeSeriesOperations {
    _store;
    _database;
    _executor;
    constructor(store, database) {
        this._store = store;
        this._database = database || store.database;
        this._executor = this._store.maintenance.forDatabase(database);
    }
    async register(collectionClassOrCollection, timeSeriesEntryClassOrName, nameOrValuesName) {
        if (TypeUtil.isString(collectionClassOrCollection)) {
            return this._registerInternal(collectionClassOrCollection, timeSeriesEntryClassOrName, nameOrValuesName);
        }
        else {
            const collectionClass = collectionClassOrCollection;
            if (TypeUtil.isString(timeSeriesEntryClassOrName)) {
                const collection = this._store.conventions.findCollectionName(collectionClass);
                await this._registerInternal(collection, timeSeriesEntryClassOrName, nameOrValuesName);
            }
            else { // [ClassConstructor<TCollection>, ClassConstructor<TTimeSeriesEntry>, string?]
                let name = nameOrValuesName;
                if (!name) {
                    name = TimeSeriesOperations.getTimeSeriesName(timeSeriesEntryClassOrName, this._store.conventions);
                }
                const mapping = TimeSeriesValuesHelper.getFieldsMapping(timeSeriesEntryClassOrName);
                if (!mapping) {
                    throwError("InvalidOperationException", TimeSeriesOperations.getTimeSeriesName(timeSeriesEntryClassOrName, this._store.conventions) + " must contain valid mapping");
                }
                const collection = this._store.conventions.findCollectionName(collectionClass);
                const valueNames = mapping.map(x => x.name);
                await this._registerInternal(collection, name, valueNames);
            }
        }
    }
    async _registerInternal(collection, name, valueNames) {
        const parameters = {
            collection,
            timeSeries: name,
            valueNames,
            update: true
        };
        const command = new ConfigureTimeSeriesValueNamesOperation(parameters);
        await this._executor.send(command);
    }
    async setPolicy(collectionNameOrClass, name, aggregation, retention) {
        const collection = TypeUtil.isString(collectionNameOrClass) ? collectionNameOrClass : this._store.conventions.findCollectionName(collectionNameOrClass);
        const p = new TimeSeriesPolicy(name, aggregation, retention);
        await this._executor.send(new ConfigureTimeSeriesPolicyOperation(collection, p));
    }
    async setRawPolicy(collectionOrClass, retention) {
        const collection = TypeUtil.isString(collectionOrClass) ? collectionOrClass : this._store.conventions.findCollectionName(collectionOrClass);
        const p = new RawTimeSeriesPolicy(retention);
        await this._executor.send(new ConfigureRawTimeSeriesPolicyOperation(collection, p));
    }
    async removePolicy(clazzOrCollection, name) {
        const collection = TypeUtil.isString(clazzOrCollection) ? clazzOrCollection : this._store.conventions.findCollectionName(clazzOrCollection);
        await this._executor.send(new RemoveTimeSeriesPolicyOperation(collection, name));
    }
    static getTimeSeriesName(clazz, conventions) {
        return conventions.findCollectionName(clazz);
    }
    forDatabase(database) {
        if (StringUtil.equalsIgnoreCase(database, this._database)) {
            return this;
        }
        return new TimeSeriesOperations(this._store, database);
    }
}
//# sourceMappingURL=TimeSeriesOperations.js.map