import { CONSTANTS } from "../../../Constants.js";
import { WktCriteria } from "./WktCriteria.js";
import { CircleCriteria } from "./CircleCriteria.js";
import { TypeUtil } from "../../../Utility/TypeUtil.js";
export class SpatialCriteriaFactory {
    static INSTANCE = new SpatialCriteriaFactory();
    constructor() {
        // empty
    }
    relatesToShape(shapeWkt, relation, units, distErrorPercent) {
        if (TypeUtil.isNullOrUndefined(distErrorPercent)) {
            distErrorPercent = CONSTANTS.Documents.Indexing.Spatial.DEFAULT_DISTANCE_ERROR_PCT;
        }
        return new WktCriteria(shapeWkt, relation, units, distErrorPercent);
    }
    static _normalizeArgs(distErrorPercentOrUnits, distErrorPercent) {
        let units = null;
        if (TypeUtil.isString(distErrorPercentOrUnits)) {
            units = distErrorPercentOrUnits;
        }
        else if (TypeUtil.isNumber(distErrorPercentOrUnits)) {
            distErrorPercent = distErrorPercentOrUnits;
            units = null;
        }
        distErrorPercent = distErrorPercent ?? CONSTANTS.Documents.Indexing.Spatial.DEFAULT_DISTANCE_ERROR_PCT;
        return { units, distErrorPercent };
    }
    intersects(shapeWkt, distErrorPercentOrUnits, distErrorPercent) {
        const args = SpatialCriteriaFactory._normalizeArgs(distErrorPercentOrUnits, distErrorPercent);
        return this.relatesToShape(shapeWkt, "Intersects", args.units, args.distErrorPercent);
    }
    contains(shapeWkt, distErrorPercentOrUnits, distErrorPercent) {
        const args = SpatialCriteriaFactory._normalizeArgs(distErrorPercentOrUnits, distErrorPercent);
        return this.relatesToShape(shapeWkt, "Contains", args.units, args.distErrorPercent);
    }
    disjoint(shapeWkt, distErrorPercentOrUnits, distErrorPercent) {
        const args = SpatialCriteriaFactory._normalizeArgs(distErrorPercentOrUnits, distErrorPercent);
        return this.relatesToShape(shapeWkt, "Disjoint", args.units, args.distErrorPercent);
    }
    within(shapeWkt, distErrorPercentOrUnits, distErrorPercent) {
        const args = SpatialCriteriaFactory._normalizeArgs(distErrorPercentOrUnits, distErrorPercent);
        return this.relatesToShape(shapeWkt, "Within", args.units, args.distErrorPercent);
    }
    withinRadius(radius, latitude, longitude, radiusUnits = null, distErrorPercent) {
        distErrorPercent = distErrorPercent ?? CONSTANTS.Documents.Indexing.Spatial.DEFAULT_DISTANCE_ERROR_PCT;
        return new CircleCriteria(radius, latitude, longitude, radiusUnits, "Within", distErrorPercent);
    }
}
//# sourceMappingURL=SpatialCriteriaFactory.js.map