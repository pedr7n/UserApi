import { RavenCommand } from "../../Http/RavenCommand.js";
import { StringBuilder } from "../../Utility/StringBuilder.js";
export class AbstractQueryCommand extends RavenCommand {
    _metadataOnly;
    _indexEntriesOnly;
    _ignoreLimit;
    constructor(indexQuery, canCache, metadataOnly, indexEntriesOnly, ignoreLimit) {
        super();
        this._metadataOnly = metadataOnly;
        this._indexEntriesOnly = indexEntriesOnly;
        this._ignoreLimit = ignoreLimit;
        this._canCache = canCache;
        // we won't allow aggressive caching of queries with WaitForNonStaleResults
        this._canCacheAggressively = canCache && !indexQuery.waitForNonStaleResults;
    }
    get isReadRequest() {
        return true;
    }
    createRequest(node) {
        const path = new StringBuilder(node.url)
            .append("/databases/")
            .append(node.database)
            .append("/queries?queryHash=")
            // we need to add a query hash because we are using POST queries
            // so we need to unique parameter per query so the query cache will
            // work properly
            .append(this.getQueryHash());
        if (this._metadataOnly) {
            path.append("&metadataOnly=true");
        }
        if (this._indexEntriesOnly) {
            path.append("&debug=entries");
        }
        if (this._ignoreLimit) {
            path.append("&ignoreLimit=true");
        }
        path.append("&addTimeSeriesNames=true");
        const uri = path.toString();
        const body = this._getContent();
        const headers = this._headers().typeAppJson().build();
        return {
            method: "POST",
            uri,
            headers,
            body
        };
    }
}
//# sourceMappingURL=AbstractQueryCommand.js.map