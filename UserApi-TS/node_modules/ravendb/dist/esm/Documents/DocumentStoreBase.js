import { EventEmitter } from "node:events";
import { throwError } from "../Exceptions/index.js";
import { validateUri } from "../Utility/UriUtil.js";
import { DocumentConventions } from "./Conventions/DocumentConventions.js";
import { IndexCreation } from "./Indexes/IndexCreation.js";
import { PutIndexesOperation } from "./Operations/Indexes/PutIndexesOperation.js";
import { DocumentSubscriptions } from "./Subscriptions/DocumentSubscriptions.js";
import { TypeUtil } from "../Utility/TypeUtil.js";
import { CaseInsensitiveKeysMap } from "../Primitives/CaseInsensitiveKeysMap.js";
import { TimeSeriesOperations } from "./TimeSeries/TimeSeriesOperations.js";
import { StringUtil } from "../Utility/StringUtil.js";
import { AiOperations } from "./Operations/AI/AiOperations.js";
export class DocumentStoreBase extends EventEmitter {
    /* TBD 4.1
    public abstract disableAggressiveCaching(): IDisposable;
    public abstract disableAggressiveCaching(database: string): IDisposable;
    */
    constructor() {
        super();
        this._subscriptions = new DocumentSubscriptions(this);
    }
    _disposed;
    isDisposed() {
        return this._disposed;
    }
    executeIndex(task, database) {
        this.assertInitialized();
        return task.execute(this, this.conventions, database);
    }
    async executeIndexes(tasks, database) {
        this.assertInitialized();
        const indexesToAdd = IndexCreation.createIndexesToAdd(tasks, this.conventions);
        await this.maintenance
            .forDatabase(this.getEffectiveDatabase(database))
            .send(new PutIndexesOperation(...indexesToAdd));
    }
    _timeSeriesOperation;
    get timeSeries() {
        if (!this._timeSeriesOperation) {
            this._timeSeriesOperation = new TimeSeriesOperations(this);
        }
        return this._timeSeriesOperation;
    }
    _conventions;
    _aiOperations;
    get ai() {
        if (!this._aiOperations) {
            this._aiOperations = new AiOperations(this);
        }
        return this._aiOperations;
    }
    get conventions() {
        if (!this._conventions) {
            this._conventions = new DocumentConventions();
        }
        return this._conventions;
    }
    set conventions(value) {
        this._assertNotInitialized("conventions");
        this._conventions = value;
    }
    _urls = [];
    get urls() {
        return this._urls;
    }
    set urls(value) {
        this._assertNotInitialized("urls");
        if (!value || !Array.isArray(value)) {
            throwError("InvalidArgumentException", `Invalid urls array passed: ${value.toString()}.`);
        }
        for (let i = 0; i < value.length; i++) {
            if (!value[i]) {
                throwError("InvalidArgumentException", `Url cannot be null or undefined - url index: ${i}`);
            }
            validateUri(value[i]);
            value[i] = value[i].replace(/\/$/, "");
        }
        this._urls = value;
    }
    _initialized;
    _authOptions;
    _subscriptions;
    get subscriptions() {
        return this._subscriptions;
    }
    _lastRaftIndexPerDatabase = CaseInsensitiveKeysMap.create();
    getLastTransactionIndex(database) {
        const index = this._lastRaftIndexPerDatabase.get(database);
        if (!index) {
            return null;
        }
        return index;
    }
    setLastTransactionIndex(database, index) {
        if (!index) {
            return;
        }
        const initialValue = this._lastRaftIndexPerDatabase.get(database);
        const result = TypeUtil.isUndefined(initialValue)
            ? index
            : Math.max(initialValue, index);
        this._lastRaftIndexPerDatabase.set(database, result);
    }
    _ensureNotDisposed() {
        if (this._disposed) {
            throwError("InvalidOperationException", "The document store has already been disposed and cannot be used");
        }
    }
    assertInitialized() {
        if (!this._initialized) {
            throwError("InvalidOperationException", "You cannot open a session or access the database commands before initializing the document store. "
                + "Did you forget calling initialize()?");
        }
    }
    _assertNotInitialized(property) {
        if (this._initialized) {
            throwError("InvalidOperationException", "You cannot set '" + property + "' after the document store has been initialized.");
        }
    }
    _database;
    get database() {
        return this._database;
    }
    set database(value) {
        this._assertNotInitialized("database");
        this._database = value;
    }
    get authOptions() {
        return this._authOptions;
    }
    set authOptions(value) {
        this._assertNotInitialized("authOptions");
        this._authOptions = value;
    }
    // TBD public IDisposable AggressivelyCache(string database = null)
    _eventHandlers = [];
    addSessionListener(eventName, eventHandler) {
        this._eventHandlers.push([eventName, eventHandler]);
        return this;
    }
    removeSessionListener(eventName, eventHandler) {
        const toRemove = this._eventHandlers
            .find(x => x[0] === eventName && x[1] === eventHandler);
        if (toRemove) {
            this._eventHandlers.splice(this._eventHandlers.indexOf(toRemove), 1);
        }
    }
    registerEvents(requestExecutorOrSession) {
        for (const [eventName, eventHandler] of this._eventHandlers) {
            if (eventName === "failedRequest"
                || eventName === "topologyUpdated"
                || eventName === "beforeRequest"
                || eventName === "succeedRequest") {
                requestExecutorOrSession.on(eventName, eventHandler);
            }
            else {
                requestExecutorOrSession.on(eventName, eventHandler);
            }
        }
    }
    _assertValidConfiguration() {
        this.conventions.validate();
    }
    getEffectiveDatabase(database) {
        return DocumentStoreBase.getEffectiveDatabase(this, database);
    }
    static getEffectiveDatabase(store, database) {
        if (!database) {
            database = store.database;
        }
        if (!StringUtil.isNullOrWhitespace(database)) {
            return database;
        }
        throwError("InvalidArgumentException", "Cannot determine database to operate on. " +
            "Please either specify 'database' directly as an action parameter " +
            "or set the default database to operate on using 'DocumentStore.database' property. " +
            "Did you forget to pass 'database' parameter?");
    }
}
//# sourceMappingURL=DocumentStoreBase.js.map