import { StringUtil } from "../../Utility/StringUtil.js";
import { throwError } from "../../Exceptions/index.js";
import { TypeUtil } from "../../Utility/TypeUtil.js";
import { IdTypeAndName } from "../IdTypeAndName.js";
import { CountersBatchCommandData } from "../Commands/Batches/CountersBatchCommandData.js";
import { CounterOperation } from "../Operations/Counters/CounterOperation.js";
/**
 * Abstract implementation for in memory session operations
 */
export class SessionCountersBase {
    _docId;
    _session;
    constructor(session, entityOrId) {
        if (TypeUtil.isObject(entityOrId)) {
            const document = session.documentsByEntity.get(entityOrId);
            if (!document) {
                this._throwEntityNotInSession(entityOrId);
                return;
            }
            this._docId = document.id;
        }
        else if (TypeUtil.isString(entityOrId)) {
            if (!entityOrId) {
                throwError("InvalidArgumentException", "DocumentId cannot be empty.");
            }
            this._docId = entityOrId;
        }
        else {
            throwError("InvalidArgumentException", "Document ID or entity argument is neither string nor entity.");
        }
        this._session = session;
    }
    increment(counter, delta = 1) {
        if (StringUtil.isNullOrWhitespace(counter)) {
            throwError("InvalidArgumentException", "Counter cannot be empty.");
        }
        const counterOp = new CounterOperation();
        counterOp.type = "Increment";
        counterOp.counterName = counter;
        counterOp.delta = delta;
        const documentInfo = this._session.documentsById.getValue(this._docId);
        if (documentInfo && this._session.deletedEntities.contains(documentInfo.entity)) {
            SessionCountersBase._throwDocumentAlreadyDeletedInSession(this._docId, counter);
        }
        const command = this._session.deferredCommandsMap.get(IdTypeAndName.keyFor(this._docId, "Counters", null));
        if (command) {
            const countersBatchCommandData = command;
            if (countersBatchCommandData.hasDelete(counter)) {
                SessionCountersBase._throwIncrementCounterAfterDeleteAttempt(this._docId, counter);
            }
            countersBatchCommandData.counters.operations.push(counterOp);
        }
        else {
            this._session.defer(new CountersBatchCommandData(this._docId, counterOp));
        }
    }
    delete(counter) {
        if (StringUtil.isNullOrWhitespace(counter)) {
            throwError("InvalidArgumentException", "Counter is required.");
        }
        if (this._session.deferredCommandsMap.has(IdTypeAndName.keyFor(this._docId, "DELETE", null))) {
            return; // no-op
        }
        const documentInfo = this._session.documentsById.getValue(this._docId);
        if (documentInfo && this._session.deletedEntities.contains(documentInfo.entity)) {
            return; //no-op
        }
        const counterOp = new CounterOperation();
        counterOp.type = "Delete";
        counterOp.counterName = counter;
        const command = this._session.deferredCommandsMap.get(IdTypeAndName.keyFor(this._docId, "Counters", null));
        if (command) {
            const countersBatchCommandData = command;
            if (countersBatchCommandData.hasIncrement(counter)) {
                SessionCountersBase._throwDeleteCounterAfterIncrementAttempt(this._docId, counter);
            }
            countersBatchCommandData.counters.operations.push(counterOp);
        }
        else {
            this._session.defer(new CountersBatchCommandData(this._docId, counterOp));
        }
        const cache = this._session.countersByDocId.get(this._docId);
        if (cache) {
            cache.data.delete(counter);
        }
    }
    _throwEntityNotInSession(entity) {
        throwError("InvalidArgumentException", `Entity is not associated with the session, cannot add counter to it. ` +
            "Use documentId instead of track the entity in the session");
    }
    static _throwIncrementCounterAfterDeleteAttempt(documentId, counter) {
        throwError("InvalidOperationException", "Can't increment counter " + counter
            + " of document " + documentId
            + ", there is a deferred command registered to delete a counter with the same name.");
    }
    static _throwDeleteCounterAfterIncrementAttempt(documentId, counter) {
        throwError("InvalidOperationException", "Can't delete counter " + counter
            + " of document " + documentId
            + ", there is a deferred command registered to increment a counter with the same name.");
    }
    static _throwDocumentAlreadyDeletedInSession(documentId, counter) {
        throwError("InvalidOperationException", "Can't increment counter " + counter
            + " of document " + documentId
            + ", the document was already deleted in this session.");
    }
}
//# sourceMappingURL=SessionCountersBase.js.map