import { AbstractDocumentQuery } from "./AbstractDocumentQuery.js";
import { throwError } from "../../Exceptions/index.js";
import { CONSTANTS } from "../../Constants.js";
import { QueryData } from "../Queries/QueryData.js";
import { GroupByDocumentQuery } from "./GroupByDocumentQuery.js";
import { FieldsToFetchToken } from "./Tokens/FieldsToFetchToken.js";
import { SpatialCriteriaFactory } from "../Queries/Spatial/SpatialCriteriaFactory.js";
import { TypeUtil } from "../../Utility/TypeUtil.js";
import { FacetBuilder } from "../Queries/Facets/FacetBuilder.js";
import { AggregationDocumentQuery } from "../Queries/Facets/AggregationDocumentQuery.js";
import { MoreLikeThisBase } from "../Queries/MoreLikeThis/MoreLikeThisBase.js";
import { MoreLikeThisUsingDocument } from "../Queries/MoreLikeThis/MoreLikeThisUsingDocument.js";
import { MoreLikeThisBuilder } from "../Queries/MoreLikeThis/MoreLikeThisBuilder.js";
import { MoreLikeThisUsingDocumentForDocumentQuery } from "../Queries/MoreLikeThis/MoreLikeThisUsingDocumentForDocumentQuery.js";
import { SuggestionBase } from "../Queries/Suggestions/SuggestionBase.js";
import { SuggestionDocumentQuery } from "../Queries/Suggestions/SuggestionDocumentQuery.js";
import { SuggestionBuilder } from "../Queries/Suggestions/SuggestionBuilder.js";
import { QueryIncludeBuilder } from "./Loaders/QueryIncludeBuilder.js";
import { FilterFactory } from "../Queries/FilterFactory.js";
export const NESTED_OBJECT_TYPES_PROJECTION_FIELD = "__PROJECTED_NESTED_OBJECT_TYPES__";
export class DocumentQuery extends AbstractDocumentQuery {
    constructor(documentType, session, indexName, collectionName, isGroupBy, declareTokens, loadTokens, fromAlias, isProjectInto) {
        super(documentType, session, indexName, collectionName, isGroupBy, declareTokens, loadTokens, fromAlias, isProjectInto);
    }
    selectFields(propertiesOrQueryData, projectionType, projectionBehavior) {
        projectionBehavior ??= "Default";
        if (this.isProjectInto || (this.fieldsToFetchToken?.projections?.length > 0)) {
            QueryData.throwProjectionIsAlreadyDone();
        }
        if (projectionType) {
            this._theSession.conventions.tryRegisterJsType(projectionType);
        }
        if (TypeUtil.isString(propertiesOrQueryData)) {
            propertiesOrQueryData = [propertiesOrQueryData];
        }
        if (Array.isArray(propertiesOrQueryData)) {
            if (projectionType) {
                return this._selectFieldsByProjectionType(propertiesOrQueryData, projectionType, projectionBehavior);
            }
            const queryData = new QueryData(propertiesOrQueryData, propertiesOrQueryData);
            queryData.isProjectInto = true;
            queryData.projectionBehavior = projectionBehavior;
            return this.selectFields(queryData, projectionType);
        }
        else {
            propertiesOrQueryData.isProjectInto = true;
            const queryData = propertiesOrQueryData;
            // add nested object types to result, so we can properly read types
            if (!queryData.isCustomFunction) {
                queryData.fields = [...queryData.fields, `${CONSTANTS.Documents.Metadata.KEY}.${CONSTANTS.Documents.Metadata.NESTED_OBJECT_TYPES}`];
                queryData.projections = [...queryData.projections, CONSTANTS.Documents.Metadata.NESTED_OBJECT_TYPES_PROJECTION_FIELD];
            }
            // we don't assign here projection behavior as it comes from override which already holds proper behavior from QueryData
            // queryData.projectionBehavior = projectionBehavior;
            return this.createDocumentQueryInternal(projectionType, queryData);
        }
    }
    _selectFieldsByProjectionType(properties, projectionType, projectionBehavior) {
        if (!properties || !properties.length) {
            throwError("InvalidArgumentException", "Fields cannot be null or empty.");
        }
        try {
            const projections = properties;
            const fields = properties.map(x => x);
            const queryData = new QueryData(fields, projections);
            queryData.projectionBehavior = projectionBehavior;
            return this.selectFields(queryData, projectionType);
        }
        catch (err) {
            throwError("RavenException", "Unable to project to type: " + projectionType, err);
        }
    }
    selectTimeSeries(timeSeriesQuery, projectionClass) {
        const queryData = this._createTimeSeriesQueryData(timeSeriesQuery);
        return this.selectFields(queryData, projectionClass);
    }
    distinct() {
        this._distinct();
        return this;
    }
    orderByScore() {
        this._orderByScore();
        return this;
    }
    orderByScoreDescending() {
        this._orderByScoreDescending();
        return this;
    }
    includeExplanations(optionsOrExplanationsCallback, explanationsCallback) {
        if (arguments.length === 1) {
            return this.includeExplanations(null, optionsOrExplanationsCallback);
        }
        this._includeExplanations(optionsOrExplanationsCallback, explanationsCallback);
        return this;
    }
    timings(timings) {
        this._includeTimings(timings);
        return this;
    }
    waitForNonStaleResults(waitTimeout = null) {
        this._waitForNonStaleResults(waitTimeout);
        return this;
    }
    addParameter(name, value) {
        super.addParameter(name, value);
        return this;
    }
    addOrder(fieldName, descending, ordering = "String") {
        if (descending) {
            this.orderByDescending(fieldName, ordering);
        }
        else {
            this.orderBy(fieldName, ordering);
        }
        return this;
    }
    // TBD public IDocumentQuery<T> AddOrder<TValue>(Expression<Func<T, TValue>> propertySelector, bool descending, OrderingType ordering)
    // TBD void IQueryBase<T, IDocumentQuery<T>>.AfterStreamExecuted(Action<BlittableJsonReaderObject> action)
    // TBD void IQueryBase<T, IRawDocumentQuery<T>>.AfterStreamExecuted(Action<BlittableJsonReaderObject> action)
    openSubclause() {
        this._openSubclause();
        return this;
    }
    closeSubclause() {
        this._closeSubclause();
        return this;
    }
    negateNext() {
        this._negateNext();
        return this;
    }
    search(fieldName, searchTerms, operator) {
        this._search(fieldName, searchTerms, operator);
        return this;
    }
    // TBD public IDocumentQuery<T> Search<TValue>(Expression<Func<T, TValue>> propertySelector, string searchTerms, SearchOperator @operator)
    intersect() {
        this._intersect();
        return this;
    }
    containsAny(fieldName, values) {
        this._containsAny(fieldName, values);
        return this;
    }
    // TBD public IDocumentQuery<T> ContainsAny<TValue>(Expression<Func<T, TValue>> propertySelector, IEnumerable<TValue> values)
    containsAll(fieldName, values) {
        this._containsAll(fieldName, values);
        return this;
    }
    // TBD public IDocumentQuery<T> ContainsAll<TValue>(Expression<Func<T, TValue>> propertySelector, IEnumerable<TValue> values)
    statistics(stats) {
        this._statistics(stats);
        return this;
    }
    usingDefaultOperator(queryOperator) {
        this._usingDefaultOperator(queryOperator);
        return this;
    }
    noTracking() {
        this._noTracking();
        return this;
    }
    noCaching() {
        this._noCaching();
        return this;
    }
    include(pathOrIncludes) {
        if (TypeUtil.isFunction(pathOrIncludes)) {
            const includesBuilder = new QueryIncludeBuilder(this.conventions);
            pathOrIncludes(includesBuilder);
            this._include(includesBuilder);
        }
        else if (TypeUtil.isString(pathOrIncludes)) {
            this._include(pathOrIncludes);
        }
        else {
            throwError("InvalidArgumentException", "include() accepts either string or function.");
        }
        return this;
    }
    // TBD: IDocumentQuery<T> IDocumentQueryBase<T, IDocumentQuery<T>>.Include(Expression<Func<T, object>> path)
    not() {
        this.negateNext();
        return this;
    }
    take(count) {
        this._take(count);
        return this;
    }
    skip(count) {
        this._skip(count);
        return this;
    }
    whereLucene(fieldName, whereClause, exact) {
        this._whereLucene(fieldName, whereClause, exact);
        return this;
    }
    whereEquals(...args) {
        this._whereEquals(...args);
        return this;
    }
    whereNotEquals(...args) {
        this._whereNotEquals(...args);
        return this;
    }
    whereIn(...args) {
        this._whereIn(...args);
        return this;
    }
    whereStartsWith(fieldName, value, exact) {
        this._whereStartsWith(fieldName, value, exact);
        return this;
    }
    whereEndsWith(fieldName, value, exact) {
        this._whereEndsWith(fieldName, value, exact);
        return this;
    }
    whereBetween(...args) {
        this._whereBetween(...args);
        return this;
    }
    whereGreaterThan(...args) {
        this._whereGreaterThan(...args);
        return this;
    }
    whereGreaterThanOrEqual(...args) {
        this._whereGreaterThanOrEqual(...args);
        return this;
    }
    whereLessThan(...args) {
        this._whereLessThan(...args);
        return this;
    }
    whereLessThanOrEqual(...args) {
        this._whereLessThanOrEqual(...args);
        return this;
    }
    // TBD public IDocumentQuery<T> WhereGreaterThan<TValue>(Expression<Func<T, TValue>> propertySelector, TValue value, bool exact = false)
    // TBD public IDocumentQuery<T> WhereGreaterThanOrEqual<TValue>(Expression<Func<T, TValue>> propertySelector, TValue value, bool exact = false)
    // TBD public IDocumentQuery<T> WhereLessThanOrEqual<TValue>(Expression<Func<T, TValue>> propertySelector, TValue value, bool exact = false)
    // TBD public IDocumentQuery<T> WhereLessThanOrEqual<TValue>(
    //      Expression<Func<T, TValue>> propertySelector, TValue value, bool exact = false)
    // TBD public IDocumentQuery<T> WhereExists<TValue>(Expression<Func<T, TValue>> propertySelector)
    whereExists(fieldName) {
        this._whereExists(fieldName);
        return this;
    }
    // TBD IDocumentQuery<T> IFilterDocumentQueryBase<T, IDocumentQuery<T>>.WhereRegex<TValue>(Expression<Func<T, TValue>> propertySelector, string pattern)
    whereRegex(fieldName, pattern) {
        this._whereRegex(fieldName, pattern);
        return this;
    }
    andAlso(wrapPreviousQueryClauses) {
        this._andAlso(wrapPreviousQueryClauses);
        return this;
    }
    orElse() {
        this._orElse();
        return this;
    }
    boost(boost) {
        this._boost(boost);
        return this;
    }
    fuzzy(fuzzy) {
        this._fuzzy(fuzzy);
        return this;
    }
    proximity(proximity) {
        this._proximity(proximity);
        return this;
    }
    randomOrdering(seed) {
        this._randomOrdering(seed);
        return this;
    }
    groupBy(...args) {
        this._groupBy(...args);
        return new GroupByDocumentQuery(this);
    }
    ofType(tResultClass) {
        if (tResultClass) {
            this._theSession.conventions.tryRegisterJsType(tResultClass);
        }
        return this.createDocumentQueryInternal(tResultClass);
    }
    orderBy(...args) {
        this._orderBy(...args);
        return this;
    }
    orderByDescending(...args) {
        this._orderByDescending(...args);
        return this;
    }
    createDocumentQueryInternal(resultClass, queryData) {
        let newFieldsToFetch;
        if (queryData && queryData.fields.length > 0) {
            let { fields } = queryData;
            if (!this._isGroupBy) {
                const identityProperty = this.conventions.getIdentityProperty(resultClass);
                if (identityProperty) {
                    fields = queryData.fields.map(p => p === identityProperty ? CONSTANTS.Documents.Indexing.Fields.DOCUMENT_ID_FIELD_NAME : p);
                }
            }
            let sourceAliasReference;
            DocumentQuery._getSourceAliasIfExists(resultClass, queryData, fields, s => sourceAliasReference = s);
            newFieldsToFetch = FieldsToFetchToken.create(fields, queryData.projections, queryData.isCustomFunction, sourceAliasReference);
        }
        else {
            newFieldsToFetch = null;
            if (this.fieldsToFetchToken) {
                queryData = new QueryData(this.fieldsToFetchToken.fieldsToFetch, this.fieldsToFetchToken.projections, this._fromToken.alias(), this._declareTokens, this._loadTokens, this.fieldsToFetchToken.customFunction);
                queryData.projectionBehavior = this.projectionBehavior;
            }
        }
        if (newFieldsToFetch) {
            this._updateFieldsToFetchToken(newFieldsToFetch);
        }
        const query = new DocumentQuery(resultClass, this._theSession, this.indexName, this.collectionName, this._isGroupBy, queryData ? queryData.declareTokens : null, queryData ? queryData.loadTokens : null, queryData ? queryData.fromAlias : null, queryData ? queryData.isProjectInto : null);
        query._queryRaw = this._queryRaw;
        query._pageSize = this._pageSize;
        query._selectTokens = this._selectTokens;
        query.fieldsToFetchToken = this.fieldsToFetchToken;
        query._whereTokens = this._whereTokens;
        query._orderByTokens = this._orderByTokens;
        query._groupByTokens = this._groupByTokens;
        query._filterTokens = this._filterTokens;
        query._queryParameters = this._queryParameters;
        query._filterModeStack = [...this._filterModeStack];
        query._start = this._start;
        query._timeout = this._timeout;
        query._queryStats = queryData?.queryStatistics ?? this._queryStats;
        query._theWaitForNonStaleResults = this._theWaitForNonStaleResults;
        query._negate = this._negate;
        //noinspection unchecked
        query._documentIncludes = new Set(this._documentIncludes);
        query._counterIncludesTokens = this._counterIncludesTokens;
        query._timeSeriesIncludesTokens = this._timeSeriesIncludesTokens;
        query._revisionsIncludesTokens = this._revisionsIncludesTokens;
        query._compareExchangeValueIncludesTokens = this._compareExchangeValueIncludesTokens;
        query._rootTypes = new Set([this._clazz]);
        for (const listener of query.listeners("beforeQuery")) {
            query.on("beforeQuery", listener);
        }
        for (const listener of query.listeners("afterQuery")) {
            query.on("afterQuery", listener);
        }
        for (const listener of query.listeners("afterStreamExecuted")) {
            query.on("afterStreamExecuted", listener);
        }
        query._explanations = this._explanations;
        query._explanationToken = this._explanationToken;
        query._queryTimings = this._queryTimings;
        query._queryHighlightings = this._queryHighlightings;
        query._highlightingTokens = this._highlightingTokens;
        query._disableEntitiesTracking = this._disableEntitiesTracking;
        query._disableCaching = this._disableCaching;
        query.projectionBehavior = queryData ? queryData.projectionBehavior : this.projectionBehavior;
        query._isIntersect = this._isIntersect;
        query._defaultOperator = this._defaultOperator;
        query._filterLimit = this._filterLimit;
        return query;
    }
    aggregateBy(facetOrFacetBuilder, ...facets) {
        if (TypeUtil.isNullOrUndefined(facetOrFacetBuilder)) {
            throwError("InvalidArgumentException", "Facet or facet builder cannot be null.");
        }
        const argType = typeof facetOrFacetBuilder;
        if (argType === "function") {
            const ff = new FacetBuilder();
            facetOrFacetBuilder(ff);
            return this.aggregateBy(ff.getFacet());
        }
        for (const facet of [facetOrFacetBuilder, ...facets]) {
            this._aggregateBy(facet);
        }
        return new AggregationDocumentQuery(this);
    }
    aggregateUsing(facetSetupDocumentId) {
        this._aggregateUsing(facetSetupDocumentId);
        return new AggregationDocumentQuery(this);
    }
    highlight(parameters, hightlightingsCallback) {
        this._highlight(parameters, hightlightingsCallback);
        return this;
    }
    spatial(fieldNameOrField, clause) {
        const criteria = clause(SpatialCriteriaFactory.INSTANCE);
        this._spatial(fieldNameOrField, criteria);
        return this;
    }
    /**
     * Filter matches to be inside the specified radius
     */
    withinRadiusOf(fieldName, radius, latitude, longitude, radiusUnits = null, distanceErrorPct = CONSTANTS.Documents.Indexing.Spatial.DEFAULT_DISTANCE_ERROR_PCT) {
        this._withinRadiusOf(fieldName, radius, latitude, longitude, radiusUnits, distanceErrorPct);
        return this;
    }
    relatesToShape(fieldName, shapeWkt, relation, distanceErrorPctOrUnits, distanceErrorPct) {
        let units;
        if (TypeUtil.isNullOrUndefined(distanceErrorPct)) {
            if (TypeUtil.isString(distanceErrorPctOrUnits)) {
                units = distanceErrorPctOrUnits;
                distanceErrorPct = CONSTANTS.Documents.Indexing.Spatial.DEFAULT_DISTANCE_ERROR_PCT;
            }
            else {
                units = null;
                distanceErrorPct = distanceErrorPctOrUnits;
            }
        }
        else {
            units = distanceErrorPctOrUnits;
        }
        this._spatialByShapeWkt(fieldName, shapeWkt, relation, units, distanceErrorPct);
        return this;
    }
    orderByDistance(...args) {
        this._orderByDistance(...args);
        return this;
    }
    orderByDistanceDescending(...args) {
        this._orderByDistanceDescending(...args);
        return this;
    }
    moreLikeThis(moreLikeThisBaseOrBuilder) {
        if (moreLikeThisBaseOrBuilder instanceof MoreLikeThisBase) {
            const mlt = this._moreLikeThis();
            try {
                mlt.withOptions(moreLikeThisBaseOrBuilder.options);
                if (moreLikeThisBaseOrBuilder instanceof MoreLikeThisUsingDocument) {
                    mlt.withDocument(moreLikeThisBaseOrBuilder.documentJson);
                }
            }
            finally {
                mlt.dispose();
            }
        }
        else {
            const f = new MoreLikeThisBuilder();
            moreLikeThisBaseOrBuilder(f);
            const moreLikeThis = this._moreLikeThis();
            try {
                moreLikeThis.withOptions(f.getMoreLikeThis().options);
                const innerMoreLikeThis = f.getMoreLikeThis();
                if (innerMoreLikeThis instanceof MoreLikeThisUsingDocument) {
                    moreLikeThis.withDocument(innerMoreLikeThis.documentJson);
                }
                else if (innerMoreLikeThis instanceof MoreLikeThisUsingDocumentForDocumentQuery) {
                    innerMoreLikeThis.forDocumentQuery(this);
                }
            }
            finally {
                moreLikeThis.dispose();
            }
        }
        return this;
    }
    suggestUsing(suggestBaseOrBuilder) {
        if (suggestBaseOrBuilder instanceof SuggestionBase) {
            this._suggestUsing(suggestBaseOrBuilder);
            return new SuggestionDocumentQuery(this);
        }
        else {
            const f = new SuggestionBuilder();
            suggestBaseOrBuilder(f);
            this.suggestUsing(f.suggestion);
            return new SuggestionDocumentQuery(this);
        }
    }
    filter(builder, limit) {
        limit ??= Number.MAX_SAFE_INTEGER;
        const mode = this.setFilterMode(true);
        try {
            const f = new FilterFactory(this, limit);
            builder(f);
        }
        finally {
            mode.dispose();
        }
        return this;
    }
    shardContext(action) {
        this._shardContext(action);
        return this;
    }
    /**
     * Performs a vector similarity search using the specified field and embedding vector.
     * @param fieldName Field containing vector values or a function that returns a field using the vector factory
     * @param valueFactory The vector to compare against as a function, array of numbers, or string
     * @param options Additional vector search options
     */
    vectorSearch(fieldName, valueFactory, options) {
        this._vectorSearch(fieldName, valueFactory, options);
        return this;
    }
}
//# sourceMappingURL=DocumentQuery.js.map