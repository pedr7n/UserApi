import { SessionCountersBase } from "./SessionCountersBase.js";
import { CaseInsensitiveKeysMap } from "../../Primitives/CaseInsensitiveKeysMap.js";
import { CONSTANTS } from "../../Constants.js";
import { GetCountersOperation } from "../Operations/Counters/GetCountersOperation.js";
import { ObjectUtil } from "../../Utility/ObjectUtil.js";
export class SessionDocumentCounters extends SessionCountersBase {
    constructor(session, entityOrId) {
        super(session, entityOrId);
    }
    async getAll() {
        let cache = this._session.countersByDocId.get(this._docId);
        if (!cache) {
            cache = {
                gotAll: false,
                data: CaseInsensitiveKeysMap.create()
            };
        }
        let missingCounters = !cache.gotAll;
        const document = this._session.documentsById.getValue(this._docId);
        if (document) {
            const metadataCounters = document.metadata[CONSTANTS.Documents.Metadata.COUNTERS];
            if (!metadataCounters) {
                missingCounters = false;
            }
            else if (cache.data.size >= metadataCounters.length) {
                missingCounters = false;
                for (const c of metadataCounters) {
                    if (cache.data.has(c)) {
                        continue;
                    }
                    missingCounters = true;
                    break;
                }
            }
        }
        if (missingCounters) {
            // we either don't have the document in session and GotAll = false,
            // or we do and cache doesn't contain all metadata counters
            this._session.incrementRequestCount();
            const details = await this._session.operations.send(new GetCountersOperation(this._docId), this._session.sessionInfo);
            cache.data.clear();
            for (const counterDetail of details.counters) {
                cache.data.set(counterDetail.counterName, counterDetail.totalValue);
            }
        }
        cache.gotAll = true;
        if (!this._session.noTracking) {
            this._session.countersByDocId.set(this._docId, cache);
        }
        return ObjectUtil.mapToLiteral(cache.data);
    }
    async get(counters) {
        return Array.isArray(counters)
            ? this._getCounters(counters)
            : this._getCounter(counters);
    }
    async _getCounter(counter) {
        let value = null;
        let cache = this._session.countersByDocId.get(this._docId);
        if (cache) {
            value = cache.data.get(counter) || null;
            if (cache.data.has(counter)) {
                return value;
            }
        }
        else {
            cache = { gotAll: false, data: CaseInsensitiveKeysMap.create() };
        }
        const document = this._session.documentsById.getValue(this._docId);
        let metadataHasCounterName = false;
        if (document) {
            const metadataCounters = document.metadata["@counters"];
            if (metadataCounters) {
                metadataHasCounterName = metadataCounters.some(x => x.toLocaleLowerCase() === counter.toLocaleLowerCase());
            }
        }
        if ((!document && !cache.gotAll) || metadataHasCounterName) {
            // we either don't have the document in session and GotAll = false,
            // or we do and it's metadata contains the counter name
            this._session.incrementRequestCount();
            const details = await this._session.operations.send(new GetCountersOperation(this._docId, counter), this._session.sessionInfo);
            if (details.counters && details.counters.length) {
                const counterDetail = details.counters[0];
                value = counterDetail ? counterDetail.totalValue : null;
            }
        }
        cache.data.set(counter, value);
        if (!this._session.noTracking) {
            this._session.countersByDocId.set(this._docId, cache);
        }
        return value;
    }
    async _getCounters(counters) {
        let cache = this._session.countersByDocId.get(this._docId);
        if (!cache) {
            cache = { gotAll: false, data: CaseInsensitiveKeysMap.create() };
        }
        let metadataCounters = null;
        const document = this._session.documentsById.getValue(this._docId);
        if (document) {
            metadataCounters = document.metadata[CONSTANTS.Documents.Metadata.COUNTERS];
        }
        const result = new Map();
        for (const counter of counters) {
            const hasCounter = cache.data.has(counter);
            const val = cache.data.get(counter);
            let notInMetadata = true;
            if (document && metadataCounters) {
                notInMetadata = !metadataCounters.some(x => x.toLowerCase() === counter.toLowerCase());
            }
            if (hasCounter || cache.gotAll || (document && notInMetadata)) {
                // we either have value in cache,
                // or we have the metadata and the counter is not there,
                // or GotAll
                result.set(counter, val);
                continue;
            }
            result.clear();
            this._session.incrementRequestCount();
            const details = await this._session.operations.send(new GetCountersOperation(this._docId, counters), this._session.sessionInfo);
            for (const counterDetail of details.counters) {
                if (!counterDetail) {
                    continue;
                }
                cache.data.set(counterDetail.counterName, counterDetail.totalValue);
                result.set(counterDetail.counterName, counterDetail.totalValue);
            }
            break;
        }
        if (!this._session.noTracking) {
            this._session.countersByDocId.set(this._docId, cache);
        }
        return ObjectUtil.mapToLiteral(result);
    }
}
//# sourceMappingURL=SessionDocumentCounters.js.map