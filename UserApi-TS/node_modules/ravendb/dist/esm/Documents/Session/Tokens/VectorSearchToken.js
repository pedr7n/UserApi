import { WhereToken } from "./WhereToken.js";
import { vectorSearchConfigurationToMethodName } from "../../../Utility/VectorSearchUtil.js";
export class VectorSearchToken extends WhereToken {
    static EMBEDDING_PREFIX = "embedding.";
    static EMBEDDING_FOR_DOCUMENT = VectorSearchToken.EMBEDDING_PREFIX + "forDoc";
    static EMBEDDING_FOR_RAW = VectorSearchToken.EMBEDDING_PREFIX + "Raw";
    static EMBEDDING_TEXT = VectorSearchToken.EMBEDDING_PREFIX + "text";
    static EMBEDDING_TEXT_INT8 = VectorSearchToken.EMBEDDING_PREFIX + "text_i8";
    static EMBEDDING_TEXT_INT1 = VectorSearchToken.EMBEDDING_PREFIX + "text_i1";
    static EMBEDDING_SINGLE = VectorSearchToken.EMBEDDING_PREFIX + "f32";
    static EMBEDDING_SINGLE_INT8 = VectorSearchToken.EMBEDDING_PREFIX + "f32_i8";
    static EMBEDDING_SINGLE_INT1 = VectorSearchToken.EMBEDDING_PREFIX + "f32_i1";
    static EMBEDDING_INT8 = VectorSearchToken.EMBEDDING_PREFIX + "i8";
    static EMBEDDING_INT1 = VectorSearchToken.EMBEDDING_PREFIX + "i1";
    static DEFAULT_EMBEDDING_TYPE = "Single";
    static DEFAULT_IS_EXACT = false;
    static AI_TASK_METHOD_NAME = "ai.task";
    _similarityThreshold;
    _sourceQuantizationType;
    _targetQuantizationType;
    _numberOfCandidatesForQuerying;
    _isDocumentId;
    _embeddingsGenerationTaskIdentifier;
    constructor(fieldName, parameterName, sourceQuantizationType, targetQuantizationType, similarityThreshold, numberOfCandidatesForQuerying, isExact, isDocumentId, embeddingsGenerationTaskIdentifier) {
        super();
        this.fieldName = fieldName;
        this.parameterName = parameterName;
        this._sourceQuantizationType = sourceQuantizationType;
        this._targetQuantizationType = targetQuantizationType;
        this._similarityThreshold = similarityThreshold;
        this._numberOfCandidatesForQuerying = numberOfCandidatesForQuerying;
        this._isDocumentId = isDocumentId;
        this._embeddingsGenerationTaskIdentifier = embeddingsGenerationTaskIdentifier;
        this.options = {
            exact: isExact,
            boost: null,
            fuzzy: null,
            proximity: null,
            searchOperator: null,
            fromParameterName: null,
            toParameterName: null,
            method: null,
            whereShape: null,
            distanceErrorPct: null,
            vectorSearch: null
        };
    }
    static getTaskIdentifier(fieldAccessor) {
        if (fieldAccessor.embeddingsGenerationTaskIdentifier) {
            return fieldAccessor.embeddingsGenerationTaskIdentifier;
        }
        return null;
    }
    static getSourceQuantizationType(fieldAccessor) {
        if (fieldAccessor.sourceQuantizationType) {
            return fieldAccessor.sourceQuantizationType;
        }
        return VectorSearchToken.DEFAULT_EMBEDDING_TYPE;
    }
    static getTargetQuantizationType(fieldAccessor) {
        if (fieldAccessor.destinationQuantizationType) {
            return fieldAccessor.destinationQuantizationType;
        }
        return VectorSearchToken.DEFAULT_EMBEDDING_TYPE;
    }
    writeTo(writer) {
        if (this.options.boost != null) {
            writer.append("boost(");
        }
        if (this.options.exact) {
            writer.append("exact(");
        }
        writer.append("vector.search(");
        if (this._sourceQuantizationType === "Single" && this._targetQuantizationType === "Single") {
            writer.append(this.fieldName);
        }
        else {
            const methodName = vectorSearchConfigurationToMethodName(this._sourceQuantizationType, this._targetQuantizationType);
            if (this._sourceQuantizationType === "Text" && this._embeddingsGenerationTaskIdentifier != null) {
                writer.append(`${methodName}(${this.fieldName}, ${VectorSearchToken.AI_TASK_METHOD_NAME}('${this._embeddingsGenerationTaskIdentifier}'))`);
            }
            else {
                writer.append(`${methodName}(${this.fieldName})`);
            }
        }
        writer.append(", ");
        if (this._isDocumentId) {
            writer.append(`${VectorSearchToken.EMBEDDING_FOR_DOCUMENT}($${this.parameterName})`);
        }
        else {
            writer.append(`$${this.parameterName}`);
        }
        const parametersAreDefault = this._similarityThreshold == null &&
            this._numberOfCandidatesForQuerying == null;
        if (!parametersAreDefault) {
            writer.append(", ").append(this._similarityThreshold?.toString() ?? "null");
            writer.append(", ").append(this._numberOfCandidatesForQuerying?.toString() ?? "null");
        }
        writer.append(')');
        if (this.options.exact) {
            writer.append(')');
        }
        if (this.options.boost != null) {
            writer.append(`, ${this.options.boost.toString()})`);
        }
    }
}
//# sourceMappingURL=VectorSearchToken.js.map