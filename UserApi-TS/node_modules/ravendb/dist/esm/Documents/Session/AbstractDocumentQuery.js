import { QueryOperation } from "./Operations/QueryOperation.js";
import { GroupByCountToken } from "./Tokens/GroupByCountToken.js";
import { GroupByToken } from "./Tokens/GroupByToken.js";
import { HighlightingToken } from "./Tokens/HighlightingToken.js";
import { FieldsToFetchToken } from "./Tokens/FieldsToFetchToken.js";
import { FromToken } from "./Tokens/FromToken.js";
import { DistinctToken } from "./Tokens/DistinctToken.js";
import { QueryStatistics } from "./QueryStatistics.js";
import { throwError } from "../../Exceptions/index.js";
import { IndexQuery } from "../Queries/IndexQuery.js";
import { GroupBy } from "../Queries/GroupBy.js";
import { GroupByKeyToken } from "../Session/Tokens/GroupByKeyToken.js";
import { GroupBySumToken } from "../Session/Tokens/GroupBySumToken.js";
import { ExplanationToken } from "../Session/Tokens/ExplanationToken.js";
import { TimingsToken } from "../Session/Tokens/TimingsToken.js";
import { TrueToken } from "../Session/Tokens/TrueToken.js";
import { WhereOptions, WhereToken } from "../Session/Tokens/WhereToken.js";
import { QueryFieldUtil } from "../Queries/QueryFieldUtil.js";
import { CloseSubclauseToken } from "./Tokens/CloseSubclauseToken.js";
import { OpenSubclauseToken } from "./Tokens/OpenSubclauseToken.js";
import { NegateToken } from "./Tokens/NegateToken.js";
import { WhereParams } from "./WhereParams.js";
import { TypeUtil } from "../../Utility/TypeUtil.js";
import { DateUtil } from "../../Utility/DateUtil.js";
import { MethodCall } from "./MethodCall.js";
import { QueryOperatorToken } from "./Tokens/QueryOperatorToken.js";
import { OrderByToken } from "./Tokens/OrderByToken.js";
import { FacetToken } from "./Tokens/FacetToken.js";
import { CounterIncludesToken } from "./Tokens/CounterIncludesToken.js";
import { EventEmitter } from "node:events";
import { StringUtil } from "../../Utility/StringUtil.js";
import { IntersectMarkerToken } from "./Tokens/IntersectMarkerToken.js";
import { DocumentConventions } from "../Conventions/DocumentConventions.js";
import { CONSTANTS, TIME_SERIES } from "../../Constants.js";
import { DocumentQueryHelper } from "./DocumentQueryHelper.js";
import { ShapeToken } from "./Tokens/ShapeToken.js";
import { SessionBeforeQueryEventArgs } from "./SessionEvents.js";
import { CmpXchg } from "./CmpXchg.js";
import { DocumentQueryCustomization } from "./DocumentQueryCustomization.js";
import { MoreLikeThisScope } from "../Queries/MoreLikeThis/MoreLikeThisScope.js";
import { MoreLikeThisToken } from "./Tokens/MoreLikeThisToken.js";
import { LazyQueryOperation } from "../Session/Operations/Lazy/LazyQueryOperation.js";
import { SuggestToken } from "./Tokens/SuggestToken.js";
import { SuggestionWithTerm } from "../Queries/Suggestions/SuggestionWithTerm.js";
import { SuggestionWithTerms } from "../Queries/Suggestions/SuggestionWithTerms.js";
import { QueryData } from "../Queries/QueryData.js";
import { QueryTimings } from "../Queries/Timings/QueryTimings.js";
import { Explanations } from "../Queries/Explanation/Explanations.js";
import { extractHighlightingOptionsFromParameters } from "../Queries/Highlighting/HighlightingOptions.js";
import { QueryHighlightings } from "../Queries/Highlighting/QueryHighlightings.js";
import { IncludesUtil } from "./IncludesUtil.js";
import { TimeSeriesIncludesToken } from "./Tokens/TimeSeriesIncludesToken.js";
import { CompareExchangeValueIncludesToken } from "./Tokens/CompareExchangeValueIncludesToken.js";
import { TimeSeriesQueryBuilder } from "../Queries/TimeSeries/TimeSeriesQueryBuilder.js";
import { StringBuilder } from "../../Utility/StringBuilder.js";
import { RevisionIncludesToken } from "./Tokens/RevisionIncludesToken.js";
import { QueryShardedContextBuilder } from "./Querying/Sharding/QueryShardedContextBuilder.js";
import { VectorEmbeddingFieldValueFactory } from "./VectorFieldFactory.js";
import { VectorEmbeddingFieldFactory } from "../Queries/VectorSearch/VectorEmbeddingFieldFactory.js";
import { JsonSerializer } from "../../Mapping/Json/Serializer.js";
import { VectorSearchToken } from "./Tokens/VectorSearchToken.js";
/**
 * A query against a Raven index
 */
export class AbstractDocumentQuery extends EventEmitter {
    _clazz;
    _aliasToGroupByFieldName = {};
    _defaultOperator = "AND";
    _rootTypes = new Set();
    /**
     * Whether to negate the next operation
     */
    _negate;
    /**
     * Whether to negate the next operation in Filter
     */
    _negateFilter;
    _indexName;
    _collectionName;
    _currentClauseDepth;
    _queryRaw;
    get indexName() {
        return this._indexName;
    }
    get collectionName() {
        return this._collectionName;
    }
    _filterModeStack = [];
    _queryParameters = {};
    _isIntersect;
    _isGroupBy;
    _theSession;
    _pageSize;
    _selectTokens = [];
    _fromToken;
    _declareTokens;
    _loadTokens;
    fieldsToFetchToken;
    _isProjectInto;
    _whereTokens = [];
    _groupByTokens = [];
    _orderByTokens = [];
    _withTokens = [];
    _filterTokens = [];
    _start;
    _conventions;
    /**
     * Limits filter clause.
     */
    _filterLimit;
    _timeout;
    _theWaitForNonStaleResults;
    _documentIncludes = new Set();
    _statsCallback = TypeUtil.NOOP;
    /**
     * Holds the query stats
     */
    _queryStats = new QueryStatistics();
    _disableEntitiesTracking;
    _disableCaching;
    projectionBehavior;
    _parameterPrefix = "p";
    _includesAlias;
    _highlightingTokens = [];
    _queryHighlightings = new QueryHighlightings();
    _queryTimings;
    _explanations;
    _explanationToken;
    isFilterActive() {
        return this._filterModeStack.length && this._filterModeStack[0];
    }
    get isDistinct() {
        return this._selectTokens
            && this._selectTokens.length
            && this._selectTokens[0] instanceof DistinctToken;
    }
    get theWaitForNonStaleResults() {
        return this._theWaitForNonStaleResults;
    }
    get timeout() {
        return this._timeout;
    }
    get queryParameters() {
        return this._queryParameters;
    }
    get selectTokens() {
        return this._selectTokens;
    }
    get isProjectInto() {
        return this._isProjectInto;
    }
    set isProjectInto(value) {
        this._isProjectInto = value;
    }
    /**
     * Gets the document convention from the query session
     */
    get conventions() {
        return this._conventions;
    }
    /**
     * Gets the session associated with this document query
     */
    get session() {
        return this._theSession;
    }
    isDynamicMapReduce() {
        return this._groupByTokens && !!this._groupByTokens.length;
    }
    _isInMoreLikeThis;
    _getDefaultTimeout() {
        return this._conventions.waitForNonStaleResultsTimeout;
    }
    constructor(clazz, session, indexName, collectionName, isGroupBy, declareTokens, loadTokens, fromAlias = null, isProjectInto = false) {
        super();
        this._clazz = clazz;
        this._rootTypes.add(clazz);
        this._isGroupBy = isGroupBy;
        this._indexName = indexName;
        this._collectionName = collectionName;
        this._fromToken = FromToken.create(indexName, collectionName, fromAlias);
        this._declareTokens = declareTokens;
        this._loadTokens = loadTokens;
        this._theSession = session;
        this.on("afterQueryExecuted", (result) => {
            this._updateStatsAndHighlightingsAndExplanations(result);
        });
        this._conventions = !session ?
            new DocumentConventions() :
            session.conventions;
        // TBD _linqPathProvider = new LinqPathProvider(_conventions);
        this._isProjectInto = isProjectInto || false;
    }
    _assertMethodIsCurrentlySupported(methodName) {
        if (!this.isFilterActive()) {
            return;
        }
        throwError("InvalidQueryException", methodName
            + " is currently unsupported for 'filter'. If you want to use"
            + methodName + " in where method you have to put it before 'filter'");
    }
    _getCurrentWhereTokens() {
        if (this.isFilterActive()) {
            return this._filterTokens;
        }
        if (!this._isInMoreLikeThis) {
            return this._whereTokens;
        }
        if (!this._whereTokens || !this._whereTokens.length) {
            throwError("InvalidOperationException", "Cannot get MoreLikeThisToken because there are no where token specified.");
        }
        const lastToken = this._whereTokens.at(-1);
        if (lastToken instanceof MoreLikeThisToken) {
            return lastToken.whereTokens;
        }
        else {
            throwError("InvalidOperationException", "Last token is not MoreLikeThisToken");
        }
    }
    _ensureValidFieldName(fieldName, isNestedPath) {
        if (!this._theSession
            || !this._theSession.conventions
            || isNestedPath
            || this._isGroupBy) {
            return QueryFieldUtil.escapeIfNecessary(fieldName, isNestedPath);
        }
        for (const rootType of this._rootTypes) {
            const identityProperty = this._theSession.conventions.getIdentityProperty(rootType);
            if (identityProperty && identityProperty === fieldName) {
                return CONSTANTS.Documents.Indexing.Fields.DOCUMENT_ID_FIELD_NAME;
            }
        }
        return QueryFieldUtil.escapeIfNecessary(fieldName);
    }
    _appendOperatorIfNeeded(tokens) {
        this._assertNoRawQuery();
        if (!tokens || !tokens.length) {
            return;
        }
        const lastToken = tokens.at(-1);
        if (!(lastToken instanceof WhereToken) && !(lastToken instanceof CloseSubclauseToken)) {
            return;
        }
        let lastWhere = null;
        for (let i = tokens.length - 1; i >= 0; i--) {
            if (tokens[i] instanceof WhereToken) {
                lastWhere = tokens[i];
                break;
            }
        }
        let token = this._defaultOperator === "AND"
            ? QueryOperatorToken.AND
            : QueryOperatorToken.OR;
        if (lastWhere
            && lastWhere.options?.searchOperator) {
            token = QueryOperatorToken.OR; // default to OR operator after search if AND was not specified explicitly
        }
        tokens.push(token);
    }
    _transformCollection(fieldName, values) {
        const result = [];
        for (const value of values) {
            if (Array.isArray(value)) {
                result.push(...this._transformCollection(fieldName, value));
            }
            else {
                const nestedWhereParams = new WhereParams();
                nestedWhereParams.allowWildcards = true;
                nestedWhereParams.fieldName = fieldName;
                nestedWhereParams.value = value;
                result.push(this._transformValue(nestedWhereParams));
            }
        }
        return result;
    }
    _negateIfNeeded(tokens, fieldName) {
        if (!this._negate) {
            return;
        }
        this._negate = false;
        if (!tokens || !tokens.length || tokens.at(-1) instanceof OpenSubclauseToken) {
            if (fieldName) {
                this._whereExists(fieldName);
            }
            else {
                this._whereTrue();
            }
            this._andAlso();
        }
        tokens.push(NegateToken.INSTANCE);
    }
    _usingDefaultOperator(operator) {
        if (this._getCurrentWhereTokens().length > 0) {
            throwError("InvalidOperationException", "Default operator can only be set before any where clause is added.");
        }
        this._defaultOperator = operator;
    }
    /**
     * Instruct the query to wait for non stale result for the specified wait timeout.
     * This shouldn't be used outside of unit tests unless you are well aware of the implications
     */
    _waitForNonStaleResults(waitTimeout) {
        if (this._theWaitForNonStaleResults) {
            if (!this._timeout || waitTimeout && this._timeout < waitTimeout) {
                this._timeout = waitTimeout;
            }
            return;
        }
        this._theWaitForNonStaleResults = true;
        this._timeout = waitTimeout || this._getDefaultTimeout();
    }
    _getLazyQueryOperation() {
        if (!this._queryOperation) {
            this._queryOperation = this.initializeQueryOperation();
        }
        const clazz = this._conventions.getJsTypeByDocumentType(this._clazz);
        return new LazyQueryOperation(this._theSession, this._queryOperation, this, clazz);
    }
    initializeQueryOperation() {
        const beforeQueryEventArgs = new SessionBeforeQueryEventArgs(this._theSession, new DocumentQueryCustomization(this));
        this._theSession.emit("beforeQuery", beforeQueryEventArgs);
        const indexQuery = this.getIndexQuery();
        return new QueryOperation(this._theSession, this._indexName, indexQuery, this.fieldsToFetchToken, this._disableEntitiesTracking, false, false, this._isProjectInto);
    }
    _transformValue(whereParams, forRange = false) {
        if (TypeUtil.isNullOrUndefined(whereParams.value)) {
            return null;
        }
        if ("" === whereParams.value) {
            return "";
        }
        let objectValue = null;
        if (this._conventions.tryConvertValueToObjectForQuery(whereParams.fieldName, whereParams.value, forRange, s => objectValue = s)) {
            return objectValue;
        }
        const value = whereParams.value;
        return this._stringifyParameter(value);
    }
    _stringifyParameter(value) {
        if (TypeUtil.isDate(value)) {
            return DateUtil.utc.stringify(value);
        }
        if (TypeUtil.isString(value)) {
            return value;
        }
        if (TypeUtil.isNumber(value)) {
            return value;
        }
        if (value === false || value === true) {
            return value;
        }
        return value || null;
    }
    _addQueryParameter(value) {
        const parameterName = this.parameterPrefix + Object.keys(this._queryParameters).length;
        this._queryParameters[parameterName] = this._stringifyParameter(value);
        return parameterName;
    }
    static _getSourceAliasIfExists(documentType, queryData, fields, sourceAlias) {
        sourceAlias(null);
        if (fields.length !== 1 || !fields[0]) {
            return;
        }
        const indexOf = fields[0].indexOf(".");
        if (indexOf === -1) {
            return;
        }
        const possibleAlias = fields[0].substring(0, indexOf);
        if (queryData.fromAlias && queryData.fromAlias === possibleAlias) {
            sourceAlias(possibleAlias);
            return;
        }
        if (!queryData.loadTokens || queryData.loadTokens.length === 0) {
            return;
        }
        if (!queryData.loadTokens.some(x => x.alias === possibleAlias)) {
            return;
        }
        sourceAlias(possibleAlias);
    }
    _createTimeSeriesQueryData(timeSeriesQuery) {
        const builder = new TimeSeriesQueryBuilder();
        timeSeriesQuery(builder);
        const fields = [TIME_SERIES.SELECT_FIELD_NAME + "(" + builder.queryText + ")"];
        const projections = [TIME_SERIES.QUERY_FUNCTION];
        return new QueryData(fields, projections);
    }
    _addFilterLimit(filterLimit) {
        if (filterLimit <= 0) {
            throwError("InvalidOperationException", "filterLimit need to be positive and bigger than 0.");
        }
        if (filterLimit !== Number.MAX_SAFE_INTEGER) {
            this._filterLimit = filterLimit;
        }
    }
    _getCurrentOrderByTokens() {
        return this._orderByTokens;
    }
    _getCurrentFilterTokens() {
        return this._filterTokens;
    }
    _updateFieldsToFetchToken(fieldsToFetch) {
        this.fieldsToFetchToken = fieldsToFetch;
        if (this._selectTokens && !this._selectTokens.length) {
            this._selectTokens.push(fieldsToFetch);
        }
        else {
            const fetchToken = [...this._selectTokens]
                .find(x => x instanceof FieldsToFetchToken);
            if (fetchToken) {
                const idx = this._selectTokens.indexOf(fetchToken);
                this._selectTokens[idx] = fieldsToFetch;
            }
            else {
                this._selectTokens.push(fieldsToFetch);
            }
        }
    }
    getIndexQuery() {
        let serverVersion = null;
        if (this._theSession && this._theSession.requestExecutor) {
            serverVersion = this._theSession.requestExecutor.lastServerVersion;
        }
        const compatibilityMode = serverVersion && serverVersion.localeCompare("4.2") < 0;
        const query = this.toString(compatibilityMode);
        const indexQuery = this._generateIndexQuery(query);
        this.emit("beforeQueryExecuted", indexQuery);
        return indexQuery;
    }
    /**
     * Gets the fields for projection
     */
    getProjectionFields() {
        return this.fieldsToFetchToken &&
            this.fieldsToFetchToken.projections
            ? [...this.fieldsToFetchToken.projections]
            : [];
    }
    /**
     * Order the search results randomly using the specified seed
     * this is useful if you want to have repeatable random queries
     */
    _randomOrdering(seed) {
        this._assertNoRawQuery();
        this._noCaching();
        if (!seed) {
            this._orderByTokens.push(OrderByToken.random);
            return;
        }
        this._orderByTokens.push(OrderByToken.createRandom(seed));
    }
    // TBD public void _customSortUsing(String typeName)
    // TBD public void _customSortUsing(String typeName, boolean descending)
    _projection(projectionBehavior) {
        this.projectionBehavior = projectionBehavior;
    }
    _shardContext(action) {
        const builderImpl = new QueryShardedContextBuilder();
        action(builderImpl);
        const shardContext = builderImpl.documentIds.size === 1 ? Array.from(builderImpl.documentIds.keys())[0] : Array.from(builderImpl.documentIds);
        this.queryParameters[CONSTANTS.Documents.Querying.SHARD_CONTEXT_PARAMETER_NAME] = shardContext;
    }
    addGroupByAlias(fieldName, projectedName) {
        this._aliasToGroupByFieldName[projectedName] = fieldName;
    }
    _assertNoRawQuery() {
        if (this._queryRaw) {
            throwError("InvalidOperationException", "RawQuery was called, cannot modify this query by calling on "
                + "operations that would modify the query (such as Where, Select, OrderBy, GroupBy, etc)");
        }
    }
    addParameter(name, value) {
        name = name.replace(/^\$/, "");
        if (Object.keys(this._queryParameters).includes(name)) {
            throwError("InvalidOperationException", "The parameter " + name + " was already added");
        }
        this._queryParameters[name] = value;
    }
    _groupBy(fieldOrFieldName, ...fieldsOrFieldNames) {
        if (typeof (fieldOrFieldName) === "string") {
            const mapping = fieldsOrFieldNames.map(x => GroupBy.field(x));
            this._groupBy(GroupBy.field(fieldOrFieldName), ...mapping);
            return;
        }
        if (!this._fromToken.isDynamic) {
            throwError("InvalidOperationException", "groupBy only works with dynamic queries");
        }
        this._assertNoRawQuery();
        this._isGroupBy = true;
        const fieldName = this._ensureValidFieldName(fieldOrFieldName.field, false);
        this._groupByTokens.push(GroupByToken.create(fieldName, fieldOrFieldName.method));
        if (!fieldsOrFieldNames || !fieldsOrFieldNames.length) {
            return;
        }
        for (const item of fieldsOrFieldNames) {
            fieldOrFieldName = this._ensureValidFieldName(item.field, false);
            this._groupByTokens.push(GroupByToken.create(fieldOrFieldName, item.method));
        }
    }
    _groupByKey(fieldName, projectedName = null) {
        this._assertNoRawQuery();
        this._isGroupBy = true;
        if (projectedName && this._aliasToGroupByFieldName[projectedName]) {
            const aliasedFieldName = this._aliasToGroupByFieldName[projectedName];
            if (!fieldName || fieldName.toLocaleLowerCase() === (projectedName || "").toLocaleLowerCase()) {
                fieldName = aliasedFieldName;
            }
        }
        else if (fieldName
            && Object.keys(this._aliasToGroupByFieldName)
                .reduce((result, next) => result || next === fieldName, false)) {
            fieldName = this._aliasToGroupByFieldName[fieldName];
        }
        this._selectTokens.push(GroupByKeyToken.create(fieldName, projectedName));
    }
    _groupBySum(fieldName, projectedName = null) {
        this._assertNoRawQuery();
        this._isGroupBy = true;
        fieldName = this._ensureValidFieldName(fieldName, false);
        this._selectTokens.push(GroupBySumToken.create(fieldName, projectedName));
    }
    _groupByCount(projectedName = null) {
        this._assertNoRawQuery();
        this._isGroupBy = true;
        this._selectTokens.push(GroupByCountToken.create(projectedName));
    }
    _whereTrue() {
        const tokens = this._getCurrentWhereTokens();
        this._appendOperatorIfNeeded(tokens);
        this._negateIfNeeded(tokens, null);
        tokens.push(TrueToken.INSTANCE);
    }
    _moreLikeThis() {
        this._appendOperatorIfNeeded(this._whereTokens);
        const token = new MoreLikeThisToken();
        this._whereTokens.push(token);
        this._isInMoreLikeThis = true;
        return new MoreLikeThisScope(token, v => this._addQueryParameter(v), () => this._isInMoreLikeThis = false);
    }
    _include(pathOrIncludes) {
        if (!pathOrIncludes) {
            return;
        }
        if (TypeUtil.isString(pathOrIncludes)) {
            if (this._theSession) {
                this._theSession.assertNoIncludesInNonTrackingSession();
            }
            this._documentIncludes.add(pathOrIncludes);
            return;
        }
        const { documentsToInclude } = pathOrIncludes;
        if (documentsToInclude && documentsToInclude.size > 0) {
            if (this._theSession) {
                this._theSession.assertNoIncludesInNonTrackingSession();
            }
            for (const doc of documentsToInclude) {
                this._documentIncludes.add(doc);
            }
        }
        this._includeCounters(pathOrIncludes.alias, pathOrIncludes.countersToIncludeBySourcePath);
        if (pathOrIncludes.timeSeriesToIncludeBySourceAlias) {
            this._includeTimeSeries(pathOrIncludes.alias, pathOrIncludes.timeSeriesToIncludeBySourceAlias);
        }
        if (pathOrIncludes.revisionsToIncludeByDateTime) {
            this._includeRevisionsByDate(pathOrIncludes.revisionsToIncludeByDateTime);
        }
        if (pathOrIncludes.revisionsToIncludeByChangeVector) {
            this._includeRevisionsByChangeVector(pathOrIncludes.revisionsToIncludeByChangeVector);
        }
        if (pathOrIncludes.compareExchangeValuesToInclude && pathOrIncludes.compareExchangeValuesToInclude.size > 0) {
            if (this._theSession) {
                this._theSession.assertNoIncludesInNonTrackingSession();
            }
            this._compareExchangeValueIncludesTokens = [];
            for (const compareExchangeValue of pathOrIncludes.compareExchangeValuesToInclude) {
                this._compareExchangeValueIncludesTokens.push(CompareExchangeValueIncludesToken.create(compareExchangeValue));
            }
        }
    }
    // TBD: public void Include(Expression<Func<T, object>> path)
    _take(count) {
        this._pageSize = count;
    }
    _skip(count) {
        this._start = count;
    }
    /**
     * Filter the results from the index using the specified where clause.
     */
    _whereLucene(fieldName, whereClause, exact) {
        fieldName = this._ensureValidFieldName(fieldName, false);
        const tokens = this._getCurrentWhereTokens();
        this._appendOperatorIfNeeded(tokens);
        this._negateIfNeeded(tokens, fieldName);
        const options = exact ? new WhereOptions({ exact }) : null;
        const whereToken = WhereToken.create("Lucene", fieldName, this._addQueryParameter(whereClause), options);
        tokens.push(whereToken);
    }
    /**
     * Simplified method for opening a new clause within the query
     */
    _openSubclause() {
        this._currentClauseDepth++;
        const tokens = this._getCurrentWhereTokens();
        this._appendOperatorIfNeeded(tokens);
        this._negateIfNeeded(tokens, null);
        tokens.push(OpenSubclauseToken.create());
    }
    /**
     * Simplified method for closing a clause within the query
     */
    _closeSubclause() {
        this._currentClauseDepth--;
        const tokens = this._getCurrentWhereTokens();
        tokens.push(CloseSubclauseToken.create());
    }
    _whereEquals(fieldNameOrWhereParams, value, exact = false) {
        if (!TypeUtil.isObject(fieldNameOrWhereParams)) {
            const params = new WhereParams();
            params.fieldName = fieldNameOrWhereParams;
            params.value = value;
            params.exact = exact;
            this._whereEquals(params);
            return;
        }
        const whereParams = fieldNameOrWhereParams;
        if (this._negate) {
            this._negate = false;
            this._whereNotEquals(whereParams);
            return;
        }
        whereParams.fieldName = this._ensureValidFieldName(whereParams.fieldName, whereParams.nestedPath);
        const tokens = this._getCurrentWhereTokens();
        this._appendOperatorIfNeeded(tokens);
        if (this._ifValueIsMethod("Equals", whereParams, tokens)) {
            return;
        }
        const transformToEqualValue = this._transformValue(whereParams);
        const addQueryParameter = this._addQueryParameter(transformToEqualValue);
        const whereToken = WhereToken.create("Equals", whereParams.fieldName, addQueryParameter, new WhereOptions({
            exact: whereParams.exact
        }));
        tokens.push(whereToken);
    }
    _ifValueIsMethod(op, whereParams, tokens) {
        if (whereParams.value instanceof MethodCall) {
            const mc = whereParams.value;
            const args = mc.args.map(() => null);
            for (let i = 0; i < mc.args.length; i++) {
                args[i] = this._addQueryParameter(mc.args[i]);
            }
            let token;
            const type = mc.constructor.name;
            if (CmpXchg.name === type) {
                token = WhereToken.create(op, whereParams.fieldName, null, new WhereOptions({
                    methodType: "CmpXchg",
                    parameters: args,
                    property: mc.accessPath,
                    exact: whereParams.exact
                }));
            }
            else {
                throwError("InvalidArgumentException", `Unknown method ${type}.`);
            }
            tokens.push(token);
            return true;
        }
        return false;
    }
    _whereNotEquals(fieldNameOrWhereParams, value, exact = false) {
        let whereParams;
        if (TypeUtil.isString(fieldNameOrWhereParams)) {
            whereParams = new WhereParams();
            whereParams.fieldName = fieldNameOrWhereParams;
            whereParams.value = value;
            whereParams.exact = exact;
            return this._whereNotEquals(whereParams);
        }
        whereParams = fieldNameOrWhereParams;
        if (this._negate) {
            this._negate = false;
            this._whereEquals(whereParams);
            return;
        }
        const transformToEqualValue = this._transformValue(whereParams);
        const tokens = this._getCurrentWhereTokens();
        this._appendOperatorIfNeeded(tokens);
        whereParams.fieldName = this._ensureValidFieldName(whereParams.fieldName, whereParams.nestedPath);
        if (this._ifValueIsMethod("NotEquals", whereParams, tokens)) {
            return;
        }
        const whereToken = WhereToken.create("NotEquals", whereParams.fieldName, this._addQueryParameter(transformToEqualValue), new WhereOptions(whereParams.exact));
        tokens.push(whereToken);
    }
    _negateNext() {
        this._negate = !this._negate;
    }
    /**
     * Check that the field has one of the specified value
     */
    _whereIn(fieldName, values, exact = false) {
        this._assertMethodIsCurrentlySupported("whereIn");
        fieldName = this._ensureValidFieldName(fieldName, false);
        const tokens = this._getCurrentWhereTokens();
        this._appendOperatorIfNeeded(tokens);
        this._negateIfNeeded(tokens, fieldName);
        const whereToken = WhereToken.create("In", fieldName, this._addQueryParameter(this._transformCollection(fieldName, AbstractDocumentQuery._unpackCollection(values))));
        tokens.push(whereToken);
    }
    _whereStartsWith(fieldName, value, exact = false) {
        this._assertMethodIsCurrentlySupported("whereStartsWith");
        const whereParams = new WhereParams();
        whereParams.fieldName = fieldName;
        whereParams.value = value;
        whereParams.allowWildcards = true;
        const transformToEqualValue = this._transformValue(whereParams);
        const tokens = this._getCurrentWhereTokens();
        this._appendOperatorIfNeeded(tokens);
        whereParams.fieldName = this._ensureValidFieldName(whereParams.fieldName, whereParams.nestedPath);
        this._negateIfNeeded(tokens, whereParams.fieldName);
        const whereToken = WhereToken.create("StartsWith", whereParams.fieldName, this._addQueryParameter(transformToEqualValue), new WhereOptions({
            exact
        }));
        tokens.push(whereToken);
    }
    /**
     * Matches fields which ends with the specified value.
     */
    _whereEndsWith(fieldName, value, exact = false) {
        this._assertMethodIsCurrentlySupported("whereEndsWith");
        const whereParams = new WhereParams();
        whereParams.fieldName = fieldName;
        whereParams.value = value;
        whereParams.allowWildcards = true;
        const transformToEqualValue = this._transformValue(whereParams);
        const tokens = this._getCurrentWhereTokens();
        this._appendOperatorIfNeeded(tokens);
        whereParams.fieldName = this._ensureValidFieldName(whereParams.fieldName, whereParams.nestedPath);
        this._negateIfNeeded(tokens, whereParams.fieldName);
        const whereToken = WhereToken.create("EndsWith", whereParams.fieldName, this._addQueryParameter(transformToEqualValue), new WhereOptions({
            exact
        }));
        tokens.push(whereToken);
    }
    /**
     * Matches fields where the value is between the specified start and end, inclusive
     */
    _whereBetween(fieldName, start, end, exact = false) {
        this._assertMethodIsCurrentlySupported("whereBetween");
        fieldName = this._ensureValidFieldName(fieldName, false);
        const tokens = this._getCurrentWhereTokens();
        this._appendOperatorIfNeeded(tokens);
        this._negateIfNeeded(tokens, fieldName);
        const startParams = new WhereParams();
        startParams.value = start;
        startParams.fieldName = fieldName;
        const endParams = new WhereParams();
        endParams.value = end;
        endParams.fieldName = fieldName;
        const fromParameterName = this._addQueryParameter(!start ? "*" : this._transformValue(startParams, true));
        const toParameterName = this._addQueryParameter(!end ? "NULL" : this._transformValue(endParams, true));
        const whereToken = WhereToken.create("Between", fieldName, null, new WhereOptions({
            exact,
            from: fromParameterName,
            to: toParameterName
        }));
        tokens.push(whereToken);
    }
    /**
     * Matches fields where the value is greater than the specified value
     */
    _whereGreaterThan(fieldName, value, exact = false) {
        fieldName = this._ensureValidFieldName(fieldName, false);
        const tokens = this._getCurrentWhereTokens();
        this._appendOperatorIfNeeded(tokens);
        this._negateIfNeeded(tokens, fieldName);
        const whereParams = new WhereParams();
        whereParams.value = value;
        whereParams.fieldName = fieldName;
        const parameter = this._addQueryParameter(!value ? "*" : this._transformValue(whereParams, true));
        const whereToken = WhereToken.create("GreaterThan", fieldName, parameter, new WhereOptions({ exact }));
        tokens.push(whereToken);
    }
    /**
     * Matches fields where the value is greater than or equal to the specified value
     */
    _whereGreaterThanOrEqual(fieldName, value, exact = false) {
        fieldName = this._ensureValidFieldName(fieldName, false);
        const tokens = this._getCurrentWhereTokens();
        this._appendOperatorIfNeeded(tokens);
        this._negateIfNeeded(tokens, fieldName);
        const whereParams = new WhereParams();
        whereParams.value = value;
        whereParams.fieldName = fieldName;
        const parameter = this._addQueryParameter(!value ? "*" : this._transformValue(whereParams, true));
        const whereToken = WhereToken.create("GreaterThanOrEqual", fieldName, parameter, new WhereOptions({ exact }));
        tokens.push(whereToken);
    }
    _whereLessThan(fieldName, value, exact = false) {
        fieldName = this._ensureValidFieldName(fieldName, false);
        const tokens = this._getCurrentWhereTokens();
        this._appendOperatorIfNeeded(tokens);
        this._negateIfNeeded(tokens, fieldName);
        const whereParams = new WhereParams();
        whereParams.value = value;
        whereParams.fieldName = fieldName;
        const parameter = this._addQueryParameter(!value ? "NULL" : this._transformValue(whereParams, true));
        const whereToken = WhereToken.create("LessThan", fieldName, parameter, new WhereOptions({ exact }));
        tokens.push(whereToken);
    }
    _whereLessThanOrEqual(fieldName, value, exact = false) {
        fieldName = this._ensureValidFieldName(fieldName, false);
        const tokens = this._getCurrentWhereTokens();
        this._appendOperatorIfNeeded(tokens);
        this._negateIfNeeded(tokens, fieldName);
        const whereParams = new WhereParams();
        whereParams.value = value;
        whereParams.fieldName = fieldName;
        const parameter = this._addQueryParameter(!value ? "NULL" : this._transformValue(whereParams, true));
        const whereToken = WhereToken.create("LessThanOrEqual", fieldName, parameter, new WhereOptions({ exact }));
        tokens.push(whereToken);
    }
    /**
     * Matches fields where Regex.IsMatch(filedName, pattern)
     */
    _whereRegex(fieldName, pattern) {
        this._assertMethodIsCurrentlySupported("whereRegex");
        fieldName = this._ensureValidFieldName(fieldName, false);
        const tokens = this._getCurrentWhereTokens();
        this._appendOperatorIfNeeded(tokens);
        this._negateIfNeeded(tokens, fieldName);
        const whereParams = new WhereParams();
        whereParams.value = pattern;
        whereParams.fieldName = fieldName;
        const parameter = this._addQueryParameter(this._transformValue(whereParams));
        const whereToken = WhereToken.create("Regex", fieldName, parameter);
        tokens.push(whereToken);
    }
    _andAlso(wrapPreviousQueryClauses = false) {
        const tokens = this._getCurrentWhereTokens();
        if (!tokens || !tokens.length) {
            return;
        }
        if (tokens.at(-1) instanceof QueryOperatorToken) {
            throwError("InvalidOperationException", "Cannot add AND, previous token was already an operator token.");
        }
        if (wrapPreviousQueryClauses) {
            tokens.unshift(OpenSubclauseToken.create());
            tokens.push(CloseSubclauseToken.create());
            tokens.push(QueryOperatorToken.AND);
        }
        else {
            tokens.push(QueryOperatorToken.AND);
        }
    }
    /**
     * Add an OR to the query
     */
    _orElse() {
        const tokens = this._getCurrentWhereTokens();
        if (!tokens && !tokens.length) {
            return;
        }
        if (tokens.at(-1) instanceof QueryOperatorToken) {
            throwError("InvalidOperationException", "Cannot add OR, previous token was already an operator token.");
        }
        tokens.push(QueryOperatorToken.OR);
    }
    setFilterMode(on) {
        return new FilterModeScope(this._filterModeStack, on);
    }
    /**
     * Specifies a boost weight to the previous where clause.
     * The higher the boost factor, the more relevant the term will be.
     * <p>
     * boosting factor where 1.0 is default, less than 1.0 is lower weight, greater than 1.0 is higher weight
     * <p>
     * http://lucene.apache.org/java/2_4_0/queryparsersyntax.html#Boosting%20a%20Term
     */
    _boost(boost) {
        this._assertMethodIsCurrentlySupported("boost");
        if (boost === 1.0) {
            return;
        }
        if (boost < 0.0) {
            throwError("InvalidArgumentException", "Boost factor must be a non-negative number");
        }
        const tokens = this._getCurrentWhereTokens();
        let last = tokens.length ? tokens.at(-1) : null;
        if (last instanceof WhereToken) {
            last.options.boost = boost;
        }
        else if (last instanceof CloseSubclauseToken) {
            const parameter = this._addQueryParameter(boost);
            const close = last;
            let openSubclauseToSkip = 0;
            let index = tokens.indexOf(last);
            while (last && index > 0) {
                index--;
                last = tokens[index]; // find the previous option
                if (last instanceof CloseSubclauseToken) {
                    // We have to count how many inner subclauses were inside current subclause
                    openSubclauseToSkip++;
                }
                else if (last instanceof OpenSubclauseToken && openSubclauseToSkip > 0) {
                    // Inner subclause open - we have to skip it because we want to match only the leftmost opening.
                    openSubclauseToSkip--;
                }
                else if (last instanceof OpenSubclauseToken) {
                    last.boostParameterName = parameter;
                    close.boostParameterName = parameter;
                }
            }
        }
        else {
            throwError("InvalidOperationException", "Cannot apply boost");
        }
    }
    /**
     * Specifies a fuzziness factor to the single word term in the last where clause
     * <p>
     * 0.0 to 1.0 where 1.0 means closer match
     * <p>
     * https://lucene.apache.org/core/2_9_4/queryparsersyntax.html#Fuzzy%20Searches
     */
    _fuzzy(fuzzy) {
        this._assertMethodIsCurrentlySupported("fuzzy");
        const tokens = this._getCurrentWhereTokens();
        if (!tokens && !tokens.length) {
            throwError("InvalidOperationException", "Fuzzy can only be used right after where clause.");
        }
        const whereToken = tokens.at(-1);
        if (!(whereToken instanceof WhereToken)) {
            throwError("InvalidOperationException", "Fuzzy can only be used right after where clause.");
        }
        if (whereToken.whereOperator !== "Equals") {
            throwError("InvalidOperationException", "Fuzzy can only be used right after where clause with equals operator");
        }
        if (fuzzy < 0.0 || fuzzy > 1.0) {
            throwError("InvalidArgumentException", "Fuzzy distance must be between 0.0 and 1.0.");
        }
        whereToken.options.fuzzy = fuzzy;
    }
    /**
     * Specifies a proximity distance for the phrase in the last search clause
     * <p>
     * https://lucene.apache.org/core/2_9_4/queryparsersyntax.html#Proximity%20Searches
     */
    _proximity(proximity) {
        this._assertMethodIsCurrentlySupported("proximity");
        const tokens = this._getCurrentWhereTokens();
        if (!tokens && !tokens.length) {
            throwError("InvalidOperationException", "Proximity can only be used right after search clause.");
        }
        const whereToken = tokens.at(-1);
        if (!(whereToken instanceof WhereToken)) {
            throwError("InvalidOperationException", "Proximity can only be used right after search clause.");
        }
        if (whereToken.whereOperator !== "Search") {
            throwError("InvalidOperationException", "Proximity can only be used right after search clause");
        }
        if (proximity < 0) {
            throwError("InvalidArgumentException", "Proximity distance must be a number greater than or equal to 0");
        }
        whereToken.options.proximity = proximity;
    }
    _orderBy(field, orderingOrOptions = "String") {
        if (TypeUtil.isString(orderingOrOptions)) {
            this._assertNoRawQuery();
            const f = this._ensureValidFieldName(field, false);
            this._orderByTokens.push(OrderByToken.createAscending(f, { ordering: orderingOrOptions }));
        }
        else {
            const sorterName = orderingOrOptions.sorterName;
            if (StringUtil.isNullOrEmpty(sorterName)) {
                throwError("InvalidArgumentException", "SorterName cannot be null or empty");
            }
            this._assertNoRawQuery();
            const f = this._ensureValidFieldName(field, false);
            this._orderByTokens.push(OrderByToken.createAscending(f, orderingOrOptions));
        }
    }
    _orderByDescending(field, orderingOrOptions = "String") {
        if (TypeUtil.isString(orderingOrOptions)) {
            this._assertNoRawQuery();
            const f = this._ensureValidFieldName(field, false);
            this._orderByTokens.push(OrderByToken.createDescending(f, { ordering: orderingOrOptions }));
        }
        else {
            const sorterName = orderingOrOptions.sorterName;
            if (StringUtil.isNullOrEmpty(sorterName)) {
                throwError("InvalidArgumentException", "SorterName cannot be null or empty");
            }
            this._assertNoRawQuery();
            const f = this._ensureValidFieldName(field, false);
            this._orderByTokens.push(OrderByToken.createDescending(f, orderingOrOptions));
        }
    }
    _orderByScore() {
        this._assertNoRawQuery();
        this._orderByTokens.push(OrderByToken.scoreAscending);
    }
    _orderByScoreDescending() {
        this._assertNoRawQuery();
        this._orderByTokens.push(OrderByToken.scoreDescending);
    }
    /**
     * Provide statistics about the query, such as total count of matching records
     */
    _statistics(statsCallback) {
        this._queryStats.requestedByUser = true;
        statsCallback(this._queryStats);
    }
    // TBD public void InvokeAfterStreamExecuted(BlittableJsonReaderObject result)
    /**
     * Generates the index query.
     */
    _generateIndexQuery(query) {
        const indexQuery = new IndexQuery();
        indexQuery.query = query;
        indexQuery.waitForNonStaleResults = this._theWaitForNonStaleResults;
        indexQuery.waitForNonStaleResultsTimeout = this._timeout;
        indexQuery.queryParameters = this._queryParameters;
        indexQuery.disableCaching = this._disableCaching;
        indexQuery.projectionBehavior = this.projectionBehavior;
        indexQuery.skipStatistics = !this._queryStats.requestedByUser;
        return indexQuery;
    }
    /**
     * Perform a search for documents which fields that match the searchTerms.
     * If there is more than a single term, each of them will be checked independently.
     */
    _search(fieldName, searchTerms, operator = "OR") {
        this._assertMethodIsCurrentlySupported("search");
        const tokens = this._getCurrentWhereTokens();
        this._appendOperatorIfNeeded(tokens);
        fieldName = this._ensureValidFieldName(fieldName, false);
        this._negateIfNeeded(tokens, fieldName);
        const whereToken = WhereToken.create("Search", fieldName, this._addQueryParameter(searchTerms), new WhereOptions({ search: operator }));
        tokens.push(whereToken);
    }
    toString(compatibilityMode = false) {
        if (this._queryRaw) {
            if (compatibilityMode) {
                return this._queryRaw;
            }
            const rawQueryText = new StringBuilder(this._queryRaw);
            this._buildPagination(rawQueryText);
            return rawQueryText.toString();
        }
        if (this._currentClauseDepth) {
            throwError("InvalidOperationException", "A clause was not closed correctly within this query, current clause depth = "
                + this._currentClauseDepth);
        }
        const queryText = new StringBuilder();
        this._buildDeclare(queryText);
        this._buildFrom(queryText);
        this._buildGroupBy(queryText);
        this._buildWhere(queryText);
        this._buildOrderBy(queryText);
        this._buildLoad(queryText);
        this._buildFilter(queryText);
        this._buildSelect(queryText);
        this._buildInclude(queryText);
        if (!compatibilityMode) {
            this._buildPagination(queryText);
        }
        return queryText.toString();
    }
    _buildPagination(queryText) {
        if (this._start > 0 || !TypeUtil.isNullOrUndefined(this._pageSize)) {
            queryText
                .append(" limit $")
                .append(this._addQueryParameter(this._start))
                .append(", $")
                .append(this._addQueryParameter(this._pageSize));
        }
        if (this._filterTokens.length > 0 && this._filterLimit > 0) {
            queryText
                .append(" filter_limit $")
                .append(this._addQueryParameter(this._filterLimit));
        }
    }
    _buildInclude(queryText) {
        if (!this._documentIncludes.size
            && !this._highlightingTokens.length
            && !this._explanationToken
            && !this._queryTimings
            && !this._counterIncludesTokens
            && !this._revisionsIncludesTokens
            && !this._timeSeriesIncludesTokens
            && !this._compareExchangeValueIncludesTokens) {
            return;
        }
        queryText.append(" include ");
        const firstRef = {
            value: true
        };
        for (const include of this._documentIncludes) {
            if (!firstRef.value) {
                queryText.append(",");
            }
            firstRef.value = false;
            let escapedInclude;
            if (IncludesUtil.requiresQuotes(include, x => escapedInclude = x)) {
                queryText.append("'");
                queryText.append(escapedInclude);
                queryText.append("'");
            }
            else {
                queryText.append(include);
            }
        }
        this._writeIncludeTokens(this._counterIncludesTokens, firstRef, queryText);
        this._writeIncludeTokens(this._timeSeriesIncludesTokens, firstRef, queryText);
        this._writeIncludeTokens(this._revisionsIncludesTokens, firstRef, queryText);
        this._writeIncludeTokens(this._compareExchangeValueIncludesTokens, firstRef, queryText);
        this._writeIncludeTokens(this._highlightingTokens, firstRef, queryText);
        if (this._explanationToken) {
            if (!firstRef.value) {
                queryText.append(",");
            }
            firstRef.value = false;
            this._explanationToken.writeTo(queryText);
        }
        if (this._queryTimings) {
            if (!firstRef.value) {
                queryText.append(",");
            }
            firstRef.value = false;
            TimingsToken.instance.writeTo(queryText);
        }
    }
    _writeIncludeTokens(tokens, firstRef, queryText) {
        if (!tokens) {
            return;
        }
        for (const token of tokens) {
            if (!firstRef.value) {
                queryText.append(",");
            }
            firstRef.value = false;
            token.writeTo(queryText);
        }
    }
    _intersect() {
        const tokens = this._getCurrentWhereTokens();
        if (tokens.length > 0) {
            const last = tokens.at(-1);
            if (last instanceof WhereToken || last instanceof CloseSubclauseToken) {
                this._isIntersect = true;
                tokens.push(IntersectMarkerToken.INSTANCE);
                return;
            }
        }
        throwError("InvalidOperationException", "Cannot add INTERSECT at this point.");
    }
    _whereExists(fieldName) {
        fieldName = this._ensureValidFieldName(fieldName, false);
        const tokens = this._getCurrentWhereTokens();
        this._appendOperatorIfNeeded(tokens);
        this._negateIfNeeded(tokens, null);
        tokens.push(WhereToken.create("Exists", fieldName, null));
    }
    _containsAny(fieldName, values) {
        this._assertMethodIsCurrentlySupported("containsAny");
        fieldName = this._ensureValidFieldName(fieldName, false);
        const tokens = this._getCurrentWhereTokens();
        this._appendOperatorIfNeeded(tokens);
        this._negateIfNeeded(tokens, fieldName);
        const array = this._transformCollection(fieldName, AbstractDocumentQuery._unpackCollection(values));
        const whereToken = WhereToken.create("In", fieldName, this._addQueryParameter(array), new WhereOptions({ exact: false }));
        tokens.push(whereToken);
    }
    _containsAll(fieldName, values) {
        this._assertMethodIsCurrentlySupported("containsAll");
        fieldName = this._ensureValidFieldName(fieldName, false);
        const tokens = this._getCurrentWhereTokens();
        this._appendOperatorIfNeeded(tokens);
        this._negateIfNeeded(tokens, fieldName);
        const array = this._transformCollection(fieldName, AbstractDocumentQuery._unpackCollection(values));
        if (!array.length) {
            tokens.push(TrueToken.INSTANCE);
            return;
        }
        const whereToken = WhereToken.create("AllIn", fieldName, this._addQueryParameter(array));
        tokens.push(whereToken);
    }
    addRootType(clazz) {
        this._rootTypes.add(clazz);
    }
    // TBD public string GetMemberQueryPathForOrderBy(Expression expression)
    // TBD public string GetMemberQueryPath(Expression expression)
    _distinct() {
        if (this.isDistinct) {
            throwError("InvalidOperationException", "This is already a distinct query.");
        }
        if (!this._selectTokens.length) {
            this._selectTokens.push(DistinctToken.INSTANCE);
        }
        else {
            this._selectTokens.unshift(DistinctToken.INSTANCE);
        }
    }
    _updateStatsAndHighlightingsAndExplanations(queryResult) {
        this._queryStats.updateQueryStats(queryResult);
        this._queryHighlightings.update(queryResult);
        if (this._explanations) {
            this._explanations.update(queryResult);
        }
        if (this._queryTimings) {
            this._queryTimings.update(queryResult);
        }
    }
    _buildSelect(writer) {
        if (!this._selectTokens || !this._selectTokens.length) {
            return;
        }
        writer.append(" select ");
        if (this._selectTokens.length === 1 && this._selectTokens[0] instanceof DistinctToken) {
            this._selectTokens[0].writeTo(writer);
            writer.append(" *");
            return;
        }
        for (let i = 0; i < this._selectTokens.length; i++) {
            const token = this._selectTokens[i];
            if (i > 0 && !(this._selectTokens[i - 1] instanceof DistinctToken)) {
                writer.append(",");
            }
            DocumentQueryHelper.addSpaceIfNeeded(i > 0 ? this._selectTokens[i - 1] : null, token, writer);
            token.writeTo(writer);
        }
    }
    _buildFrom(writer) {
        this._fromToken.writeTo(writer);
    }
    _buildDeclare(writer) {
        if (!this._declareTokens) {
            return;
        }
        for (const token of this._declareTokens) {
            token.writeTo(writer);
        }
    }
    _buildLoad(writer) {
        if (!this._loadTokens || !this._loadTokens.length) {
            return;
        }
        writer.append(" load ");
        for (let i = 0; i < this._loadTokens.length; i++) {
            if (i !== 0) {
                writer.append(", ");
            }
            this._loadTokens[i].writeTo(writer);
        }
    }
    _buildWhere(writer) {
        if (!this._whereTokens || !this._whereTokens.length) {
            return;
        }
        writer
            .append(" where ");
        if (this._isIntersect) {
            writer
                .append("intersect(");
        }
        for (let i = 0; i < this._whereTokens.length; i++) {
            DocumentQueryHelper.addSpaceIfNeeded(i > 0 ? this._whereTokens[i - 1] : null, this._whereTokens[i], writer);
            this._whereTokens[i].writeTo(writer);
        }
        if (this._isIntersect) {
            writer.append(") ");
        }
    }
    _buildGroupBy(writer) {
        if (!this._groupByTokens || !this._groupByTokens.length) {
            return;
        }
        writer
            .append(" group by ");
        let isFirst = true;
        for (const token of this._groupByTokens) {
            if (!isFirst) {
                writer.append(", ");
            }
            token.writeTo(writer);
            isFirst = false;
        }
    }
    _buildFilter(writer) {
        if (this._filterTokens.length === 0) {
            return;
        }
        writer
            .append(" filter ");
        for (let i = 0; i < this._filterTokens.length; i++) {
            DocumentQueryHelper.addSpaceIfNeeded(i > 0 ? this._filterTokens[i - 1] : null, this._filterTokens[i], writer);
            this._filterTokens[i].writeTo(writer);
        }
    }
    _buildOrderBy(writer) {
        if (!this._orderByTokens || !this._orderByTokens.length) {
            return;
        }
        writer
            .append(" order by ");
        let isFirst = true;
        for (const token of this._orderByTokens) {
            if (!isFirst) {
                writer.append(", ");
            }
            token.writeTo(writer);
            isFirst = false;
        }
    }
    static _unpackCollection(items) {
        const results = [];
        for (const item of items) {
            if (Array.isArray(item)) {
                results.push(...AbstractDocumentQuery._unpackCollection(item));
            }
            else {
                results.push(item);
            }
        }
        return results;
    }
    // TBD protected Action<BlittableJsonReaderObject> AfterStreamExecutedCallback;
    _queryOperation;
    queryOperation() {
        return this._queryOperation;
    }
    // TBD public IDocumentQueryCustomization AfterStreamExecuted(Action<BlittableJsonReaderObject> action)
    _noTracking() {
        this._disableEntitiesTracking = true;
    }
    _noCaching() {
        this._disableCaching = true;
    }
    _includeTimings(timingsCallback) {
        if (this._queryTimings) {
            timingsCallback(this._queryTimings);
            return;
        }
        this._queryTimings = new QueryTimings();
        timingsCallback(this._queryTimings);
    }
    _highlight(parameters, highlightingsCallback) {
        highlightingsCallback(this._queryHighlightings.add(parameters.fieldName));
        const optionsParameterName = parameters
            ? this._addQueryParameter(extractHighlightingOptionsFromParameters(parameters))
            : null;
        const token = HighlightingToken.create(parameters.fieldName, parameters.fragmentLength, parameters.fragmentCount, optionsParameterName);
        this._highlightingTokens.push(token);
    }
    _withinRadiusOf(fieldName, radius, latitude, longitude, radiusUnits, distErrorPercent) {
        fieldName = this._ensureValidFieldName(fieldName, false);
        const tokens = this._getCurrentWhereTokens();
        this._appendOperatorIfNeeded(tokens);
        this._negateIfNeeded(tokens, fieldName);
        const whereToken = WhereToken.create("SpatialWithin", fieldName, null, new WhereOptions({
            shape: ShapeToken.circle(this._addQueryParameter(radius), this._addQueryParameter(latitude), this._addQueryParameter(longitude), radiusUnits),
            distance: distErrorPercent
        }));
        tokens.push(whereToken);
    }
    _spatialByShapeWkt(fieldName, shapeWkt, relation, units, distErrorPercent) {
        fieldName = this._ensureValidFieldName(fieldName, false);
        const tokens = this._getCurrentWhereTokens();
        this._appendOperatorIfNeeded(tokens);
        this._negateIfNeeded(tokens, fieldName);
        const wktToken = ShapeToken.wkt(this._addQueryParameter(shapeWkt), units);
        let whereOperator;
        switch (relation) {
            case "Within": {
                whereOperator = "SpatialWithin";
                break;
            }
            case "Contains": {
                whereOperator = "SpatialContains";
                break;
            }
            case "Disjoint": {
                whereOperator = "SpatialDisjoint";
                break;
            }
            case "Intersects": {
                whereOperator = "SpatialIntersects";
                break;
            }
            default: {
                throwError("InvalidArgumentException", `relation: ${relation}.`);
            }
        }
        tokens.push(WhereToken.create(whereOperator, fieldName, null, new WhereOptions({
            shape: wktToken,
            distance: distErrorPercent
        })));
    }
    _spatial(fieldNameOrDynamicSpatialField, criteria) {
        let tokens;
        if (typeof (fieldNameOrDynamicSpatialField) === "string") {
            const fieldName = this._ensureValidFieldName(fieldNameOrDynamicSpatialField, false);
            tokens = this._getCurrentWhereTokens();
            this._appendOperatorIfNeeded(tokens);
            this._negateIfNeeded(tokens, fieldName);
            tokens.push(criteria.toQueryToken(fieldName, (o) => this._addQueryParameter(o)));
            return;
        }
        const dynamicField = fieldNameOrDynamicSpatialField;
        this._assertIsDynamicQuery(dynamicField, "spatial");
        tokens = this._getCurrentWhereTokens();
        this._appendOperatorIfNeeded(tokens);
        this._negateIfNeeded(tokens, null);
        tokens.push(criteria.toQueryToken(dynamicField.toField((fName, isNestedPath) => this._ensureValidFieldName(fName, isNestedPath)), (o) => this._addQueryParameter(o)));
    }
    _orderByDistance(fieldNameOrField, shapeWktOrLatitude, longitudeOrRoundFactor, roundFactor) {
        if (TypeUtil.isString(fieldNameOrField)) {
            if (TypeUtil.isString(shapeWktOrLatitude)) {
                const roundFactorParameterName = longitudeOrRoundFactor ? this._addQueryParameter(longitudeOrRoundFactor) : null;
                this._orderByTokens.push(OrderByToken.createDistanceAscending(fieldNameOrField, this._addQueryParameter(shapeWktOrLatitude), roundFactorParameterName));
            }
            else {
                const roundFactorParameterName = roundFactor ? this._addQueryParameter(roundFactor) : null;
                this._orderByTokens.push(OrderByToken.createDistanceAscending(fieldNameOrField, this._addQueryParameter(shapeWktOrLatitude), this._addQueryParameter(longitudeOrRoundFactor), roundFactorParameterName));
            }
            return;
        }
        const field = fieldNameOrField;
        this._assertIsDynamicQuery(field, "orderByDistance");
        if (!fieldNameOrField) {
            throwError("InvalidArgumentException", "Field cannot be null.");
        }
        if (TypeUtil.isString(shapeWktOrLatitude)) {
            this._orderByDistance("'" + field.toField((f, isNestedPath) => this._ensureValidFieldName(f, isNestedPath)) + "'", shapeWktOrLatitude);
        }
        else {
            this._orderByDistance("'" + field.toField((f, isNestedPath) => this._ensureValidFieldName(f, isNestedPath)) + "'", shapeWktOrLatitude, longitudeOrRoundFactor, field.roundFactor);
        }
    }
    _orderByDistanceDescending(fieldNameOrField, shapeWktOrLatitude, longitudeOrRoundFactor, roundFactor) {
        if (TypeUtil.isString(fieldNameOrField)) {
            if (TypeUtil.isString(shapeWktOrLatitude)) {
                const roundFactorParameterName = longitudeOrRoundFactor ? this._addQueryParameter(longitudeOrRoundFactor) : null;
                this._orderByTokens.push(OrderByToken.createDistanceDescending(fieldNameOrField, this._addQueryParameter(shapeWktOrLatitude), roundFactorParameterName));
            }
            else {
                const roundFactorParameterName = roundFactor ? this._addQueryParameter(roundFactor) : null;
                this._orderByTokens.push(OrderByToken.createDistanceDescending(fieldNameOrField, this._addQueryParameter(shapeWktOrLatitude), this._addQueryParameter(longitudeOrRoundFactor), roundFactorParameterName));
            }
            return;
        }
        const field = fieldNameOrField;
        this._assertIsDynamicQuery(field, "orderByDistance");
        if (!fieldNameOrField) {
            throwError("InvalidArgumentException", "Field cannot be null.");
        }
        if (TypeUtil.isString(shapeWktOrLatitude)) {
            this._orderByDistanceDescending("'" + field.toField((f, isNestedPath) => this._ensureValidFieldName(f, isNestedPath)) + "'", shapeWktOrLatitude);
        }
        else {
            this._orderByDistanceDescending("'" + field.toField((f, isNestedPath) => this._ensureValidFieldName(f, isNestedPath)) + "'", shapeWktOrLatitude, longitudeOrRoundFactor, field.roundFactor);
        }
    }
    _assertIsDynamicQuery(dynamicField, methodName) {
        if (!this._fromToken.isDynamic) {
            throwError("InvalidOperationException", "Cannot execute query method '" + methodName +
                "'. Field '" + dynamicField.toField(this._ensureValidFieldName) +
                "' cannot be used when static index '" +
                this._fromToken.indexName + "' is queried. " +
                "Dynamic spatial fields can only be used with dynamic queries, " +
                " for static index queries please use valid spatial fields defined in index definition.");
        }
    }
    _initSync() {
        if (this._queryOperation) {
            return Promise.resolve();
        }
        this._queryOperation = this.initializeQueryOperation();
        return this._executeActualQuery();
    }
    async _executeActualQuery() {
        // TBD 4.1 context = this._queryOperation.enterQueryContext();
        const command = this._queryOperation.createRequest();
        await this._theSession.requestExecutor.execute(command, this._theSession.sessionInfo);
        this._queryOperation.setResult(command.result);
        this.emit("afterQueryExecuted", this._queryOperation.getCurrentQueryResults());
        /* TBD 4.1
        .finally(() => {
            if (context) {
                context.dispose();
            }
        });
        */
    }
    async iterator() {
        await this._initSync();
        const results = this._queryOperation.complete(this._clazz);
        return results[Symbol.iterator]();
    }
    async all() {
        const results = await this.iterator();
        const array = [...results];
        if (this.conventions.returnPlainJsObjects) {
            return array.map(item => JsonSerializer.toPlainObject(item));
        }
        return array;
    }
    async getQueryResult() {
        await this._initSync();
        return this._queryOperation.getCurrentQueryResults().createSnapshot();
    }
    async first() {
        const entries = await this._executeQueryOperation(1);
        if (entries.length === 0) {
            throwError("InvalidOperationException", "Expected at least one result.");
        }
        if (this.conventions.returnPlainJsObjects) {
            return JsonSerializer.toPlainObject(entries[0]);
        }
        return entries[0];
    }
    async firstOrNull() {
        const entries = await this._executeQueryOperation(1);
        if (this.conventions.returnPlainJsObjects) {
            return JsonSerializer.toPlainObject(entries[0]) || null;
        }
        return entries[0] || null;
    }
    async single() {
        const entries = await this._executeQueryOperation(2);
        if (entries.length !== 1) {
            throwError("InvalidOperationException", `Expected single result, but got ${entries.length ? "more than that" : 0}.`);
        }
        if (this.conventions.returnPlainJsObjects) {
            return JsonSerializer.toPlainObject(entries[0]);
        }
        return entries[0];
    }
    async singleOrNull() {
        const entries = await this._executeQueryOperation(2);
        if (entries.length === 2) {
            throwError("InvalidOperationException", `Expected single result, but got more than that.`);
        }
        if (this.conventions.returnPlainJsObjects) {
            return entries.length === 1 ? JsonSerializer.toPlainObject(entries[0]) : null;
        }
        return entries.length === 1 ? entries[0] : null;
    }
    async count() {
        this._take(0);
        const queryResult = await this.getQueryResult();
        return queryResult.totalResults;
    }
    async _executeQueryOperation(take) {
        await this._executeQueryOperationInternal(take);
        return this.queryOperation().complete(this._clazz);
    }
    async _executeQueryOperationInternal(take) {
        if ((take || take === 0) && (!this._pageSize || this._pageSize > take)) {
            this._take(take);
        }
        await this._initSync();
    }
    async longCount() {
        this._take(0);
        const queryResult = await this.getQueryResult();
        return queryResult.totalResults;
    }
    async any() {
        if (this.isDistinct) {
            // for distinct it is cheaper to do count 1
            const result = await this._executeQueryOperation(1);
            return !!result[0];
        }
        this._take(0);
        const queryResult = await this.getQueryResult();
        return queryResult.totalResults > 0;
    }
    _aggregateBy(facet) {
        for (const token of this._selectTokens) {
            if (token instanceof FacetToken) {
                continue;
            }
            throwError("InvalidOperationException", "Aggregation query can select only facets while it got " + token.constructor.name + " token");
        }
        const facetToken = FacetToken.create(facet, (val) => this._addQueryParameter(val));
        this._selectTokens.push(facetToken);
    }
    _aggregateUsing(facetSetupDocumentId) {
        this._selectTokens.push(FacetToken.create(facetSetupDocumentId));
    }
    lazily() {
        const lazyQueryOperation = this._getLazyQueryOperation();
        return this._theSession
            .addLazyOperation(lazyQueryOperation);
    }
    countLazily() {
        if (!this._queryOperation) {
            this._take(0);
            this._queryOperation = this.initializeQueryOperation();
        }
        const clazz = this._conventions.getJsTypeByDocumentType(this._clazz);
        const lazyQueryOperation = new LazyQueryOperation(this._theSession, this._queryOperation, this, clazz);
        return this._theSession.addLazyCountOperation(lazyQueryOperation);
    }
    _suggestUsing(suggestion) {
        if (!suggestion) {
            throwError("InvalidArgumentException", "suggestion cannot be null");
        }
        this._assertCanSuggest(suggestion);
        let token = null;
        if (suggestion instanceof SuggestionWithTerm) {
            const term = suggestion;
            token = SuggestToken.create(term.field, term.displayField, this._addQueryParameter(term.term), this._getOptionsParameterName(term.options));
        }
        else if (suggestion instanceof SuggestionWithTerms) {
            const terms = suggestion;
            token = SuggestToken.create(terms.field, terms.displayField, this._addQueryParameter(terms.terms), this._getOptionsParameterName(terms.options));
        }
        else {
            throwError("InvalidOperationException", "Unknown type of suggestion: " + suggestion);
        }
        this._selectTokens.push(token);
    }
    _getOptionsParameterName(options) {
        let optionsParameterName = null;
        if (options) {
            optionsParameterName = this._addQueryParameter(options);
        }
        return optionsParameterName;
    }
    _assertCanSuggest(suggestion) {
        if (this._whereTokens.length) {
            throwError("InvalidOperationException", "Cannot add suggest when WHERE statements are present.");
        }
        if (this._selectTokens.length) {
            const lastToken = this._selectTokens.at(-1);
            if (lastToken instanceof SuggestToken) {
                if (lastToken.fieldName === suggestion.field) {
                    throwError("InvalidOperationException", "Cannot add suggest for the same field again.");
                }
            }
            else {
                throwError("InvalidOperationException", "Cannot add suggest when SELECT statements are present.");
            }
        }
        if (this._orderByTokens.length) {
            throwError("InvalidOperationException", "Cannot add suggest when ORDER BY statements are present.");
        }
    }
    _includeExplanations(options, explanationsCallback) {
        if (this._explanationToken) {
            throwError("InvalidOperationException", "Duplicate IncludeExplanations method calls are forbidden.");
        }
        const optionsParameterName = options
            ? this._addQueryParameter(options)
            : null;
        this._explanationToken = ExplanationToken.create(optionsParameterName);
        this._explanations = new Explanations();
        explanationsCallback(this._explanations);
    }
    _timeSeriesIncludesTokens;
    _counterIncludesTokens;
    _compareExchangeValueIncludesTokens;
    _revisionsIncludesTokens;
    _includeCounters(alias, counterToIncludeByDocId) {
        if (!counterToIncludeByDocId || !counterToIncludeByDocId.size) {
            return;
        }
        if (this._theSession) {
            this._theSession.assertNoIncludesInNonTrackingSession();
        }
        this._counterIncludesTokens = [];
        this._includesAlias = alias;
        for (const [key, val] of counterToIncludeByDocId.entries()) {
            if (val[0]) {
                this._counterIncludesTokens.push(CounterIncludesToken.all(key));
                continue;
            }
            const valArr = [...val[1]];
            if (!valArr || !valArr.length) {
                continue;
            }
            for (const name of val[1]) {
                this._counterIncludesTokens.push(CounterIncludesToken.create(key, name));
            }
        }
    }
    _includeTimeSeries(alias, timeSeriesToInclude) {
        if (!timeSeriesToInclude || !timeSeriesToInclude.size) {
            return;
        }
        if (this._theSession) {
            this._theSession.assertNoIncludesInNonTrackingSession();
        }
        this._timeSeriesIncludesTokens = [];
        if (!this._includesAlias) {
            this._includesAlias = alias;
        }
        for (const kvp of timeSeriesToInclude.entries()) {
            for (const range of kvp[1].values()) {
                this._timeSeriesIncludesTokens.push(TimeSeriesIncludesToken.create(kvp[0], range));
            }
        }
    }
    getQueryType() {
        return this._clazz;
    }
    addFromAliasToWhereTokens(fromAlias) {
        const tokens = this._getCurrentWhereTokens();
        this._addFromAliasToTokens(fromAlias, tokens);
    }
    addFromAliasToOrderByTokens(fromAlias) {
        const tokens = this._getCurrentOrderByTokens();
        this._addFromAliasToTokens(fromAlias, tokens);
    }
    addFromAliasToFilterTokens(fromAlias) {
        const tokens = this._getCurrentFilterTokens();
        this._addFromAliasToTokens(fromAlias, tokens);
    }
    _addFromAliasToTokens(fromAlias, tokens) {
        if (!fromAlias) {
            throwError("InvalidArgumentException", "Alias cannot be null or empty.");
        }
        for (const token of tokens) {
            if (token instanceof WhereToken) {
                token.addAlias(fromAlias);
            }
            if (token instanceof OrderByToken) {
                token.addAlias(fromAlias);
            }
        }
    }
    addAliasToIncludesTokens(fromAlias) {
        if (!this._includesAlias) {
            return fromAlias;
        }
        if (!fromAlias) {
            fromAlias = this._includesAlias;
            this.addFromAliasToWhereTokens(fromAlias);
        }
        if (this._counterIncludesTokens) {
            for (const counterIncludesToken of this._counterIncludesTokens) {
                counterIncludesToken.addAliasToPath(fromAlias);
            }
        }
        if (this._timeSeriesIncludesTokens) {
            for (const token of this._timeSeriesIncludesTokens) {
                token.addAliasToPath(fromAlias);
            }
        }
        return fromAlias;
    }
    _includeRevisionsByDate(dateTime) {
        if (!this._revisionsIncludesTokens) {
            this._revisionsIncludesTokens = [];
        }
        if (this._theSession) {
            this._theSession.assertNoIncludesInNonTrackingSession();
        }
        this._revisionsIncludesTokens.push(RevisionIncludesToken.createForDate(dateTime));
    }
    _includeRevisionsByChangeVector(revisionsToIncludeByChangeVector) {
        if (!this._revisionsIncludesTokens) {
            this._revisionsIncludesTokens = [];
        }
        if (!revisionsToIncludeByChangeVector || revisionsToIncludeByChangeVector.size === 0) {
            return;
        }
        if (this._theSession) {
            this._theSession.assertNoIncludesInNonTrackingSession();
        }
        for (const changeVector of revisionsToIncludeByChangeVector) {
            this._revisionsIncludesTokens.push(RevisionIncludesToken.createForPath(changeVector));
        }
    }
    get parameterPrefix() {
        return this._parameterPrefix;
    }
    set parameterPrefix(prefix) {
        this._parameterPrefix = prefix;
    }
    /**
     * Performs a vector similarity search against a field containing vector embeddings
     * @param fieldName The field containing vector values or a field expression
     * @param valueOrFactory The query vector or a function that configures how to provide the vector value
     * @param options Additional vector search options
     */
    _vectorSearch(fieldName, valueOrFactory, options) {
        this._assertMethodIsCurrentlySupported("vectorSearch");
        const fieldAccessor = this._resolveVectorSearchFieldAccessor(fieldName);
        const { value, isDocumentId } = this._resolveVectorSearchValueFactory(valueOrFactory);
        const tokens = this._getCurrentWhereTokens();
        this._appendOperatorIfNeeded(tokens);
        this._negateIfNeeded(tokens, fieldAccessor.fieldName);
        const sourceQuantizationType = VectorSearchToken.getSourceQuantizationType(fieldAccessor);
        const targetQuantizationType = VectorSearchToken.getTargetQuantizationType(fieldAccessor);
        const taskIdentifier = VectorSearchToken.getTaskIdentifier(fieldAccessor);
        const parameterName = this._addQueryParameter(value);
        const vectorSearchToken = new VectorSearchToken(fieldAccessor.fieldName, parameterName, sourceQuantizationType, targetQuantizationType, options?.similarity || null, options?.numberOfCandidates || null, options?.isExact || VectorSearchToken.DEFAULT_IS_EXACT, isDocumentId, taskIdentifier);
        tokens.push(vectorSearchToken);
    }
    _resolveVectorSearchFieldAccessor(fieldName) {
        const vectorFactory = new VectorEmbeddingFieldFactory();
        if (typeof fieldName === "string") {
            return vectorFactory.withField(fieldName);
        }
        else if (typeof fieldName === "function") {
            return fieldName(vectorFactory);
        }
        else {
            throwError("InvalidArgumentException", "fieldName must be either a string or a function that selects a vector field");
        }
    }
    _resolveVectorSearchValueFactory(valueOrFactory) {
        if (typeof valueOrFactory === "function") {
            const fieldValueFactory = new VectorEmbeddingFieldValueFactory();
            valueOrFactory(fieldValueFactory);
            const value = fieldValueFactory.embedding || fieldValueFactory.embeddings ||
                fieldValueFactory.text || fieldValueFactory.texts || fieldValueFactory.byId;
            if (!value) {
                throwError("InvalidOperationException", "No value was provided in the valueFactory");
            }
            return { value, isDocumentId: !!fieldValueFactory.byId };
        }
        else {
            return { value: valueOrFactory, isDocumentId: false };
        }
    }
}
class FilterModeScope {
    _modeStack;
    constructor(modeStack, on) {
        this._modeStack = modeStack;
        this._modeStack.push(on);
    }
    dispose() {
        this._modeStack.pop();
    }
}
//# sourceMappingURL=AbstractDocumentQuery.js.map