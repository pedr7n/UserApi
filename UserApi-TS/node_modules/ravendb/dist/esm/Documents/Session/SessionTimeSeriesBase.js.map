{"version":3,"file":"SessionTimeSeriesBase.js","sourceRoot":"","sources":["../../../../src/Documents/Session/SessionTimeSeriesBase.ts"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * Abstract implementation for in memory session operations\r\n */\r\nimport { InMemoryDocumentSessionOperations } from \"./InMemoryDocumentSessionOperations.js\";\r\nimport { throwError } from \"../../Exceptions/index.js\";\r\nimport { TypeUtil } from \"../../Utility/TypeUtil.js\";\r\nimport { StringUtil } from \"../../Utility/StringUtil.js\";\r\nimport { AppendOperation, DeleteOperation, IncrementOperation } from \"../Operations/TimeSeries/TimeSeriesOperation.js\";\r\nimport { IdTypeAndName } from \"../IdTypeAndName.js\";\r\nimport { TimeSeriesBatchCommandData } from \"../Commands/Batches/TimeSeriesBatchCommandData.js\";\r\nimport { TimeSeriesEntry } from \"./TimeSeries/TimeSeriesEntry.js\";\r\nimport { TimeSeriesRangeResult } from \"../Operations/TimeSeries/TimeSeriesRangeResult.js\";\r\nimport { DatesComparator, definedDate, leftDate, rightDate } from \"../../Primitives/DatesComparator.js\";\r\nimport { GetTimeSeriesOperation } from \"../Operations/TimeSeries/GetTimeSeriesOperation.js\";\r\nimport { CaseInsensitiveKeysMap } from \"../../Primitives/CaseInsensitiveKeysMap.js\";\r\nimport { TimeSeriesRange } from \"../Operations/TimeSeries/TimeSeriesRange.js\";\r\nimport { GetMultipleTimeSeriesOperation } from \"../Operations/TimeSeries/GetMultipleTimeSeriesOperation.js\";\r\nimport { CONSTANTS } from \"../../Constants.js\";\r\nimport { ITimeSeriesIncludeBuilder } from \"./Loaders/ITimeSeriesIncludeBuilder.js\";\r\nimport { TimeSeriesDetails } from \"../Operations/TimeSeries/TimeSeriesDetails.js\";\r\nimport { IncrementalTimeSeriesBatchCommandData } from \"../Commands/Batches/IncrementalTimeSeriesBatchCommandData.js\";\r\n\r\nexport class SessionTimeSeriesBase {\r\n    protected docId: string;\r\n    protected name: string;\r\n    protected session: InMemoryDocumentSessionOperations;\r\n\r\n    protected constructor(session: InMemoryDocumentSessionOperations, entity: any, name: string)\r\n    protected constructor(session: InMemoryDocumentSessionOperations, documentId: string, name: string)\r\n    protected constructor(session: InMemoryDocumentSessionOperations, documentIdOrEntity: string | any, name: string) {\r\n        if (TypeUtil.isString(documentIdOrEntity)) {\r\n            const documentId = documentIdOrEntity;\r\n            if (!documentId) {\r\n                throwError(\"InvalidArgumentException\", \"DocumentId cannot be null\");\r\n            }\r\n\r\n            if (!name) {\r\n                throwError(\"InvalidArgumentException\", \"Name cannot be null\");\r\n            }\r\n\r\n            this.docId = documentId;\r\n            this.name = name;\r\n            this.session = session;\r\n        } else {\r\n            const entity = documentIdOrEntity;\r\n            if (!entity) {\r\n                throwError(\"InvalidArgumentException\", \"Entity cannot be null\");\r\n            }\r\n            const documentInfo = session.documentsByEntity.get(entity);\r\n            if (!documentInfo) {\r\n                this._throwEntityNotInSession();\r\n                return;\r\n            }\r\n\r\n            if (StringUtil.isNullOrWhitespace(name)) {\r\n                throwError(\"InvalidArgumentException\", \"Name cannot be null or whitespace\");\r\n            }\r\n\r\n            this.docId = documentInfo.id;\r\n            this.name = name;\r\n            this.session = session;\r\n        }\r\n    }\r\n\r\n    protected _appendInternal(timestamp: Date, valueOrValues: number[] | number, tag?: string): void {\r\n        const values = TypeUtil.isArray(valueOrValues) ? valueOrValues : [valueOrValues];\r\n\r\n        const documentInfo = this.session.documentsById.getValue(this.docId);\r\n        if (documentInfo && this.session.deletedEntities.contains(documentInfo.entity)) {\r\n            SessionTimeSeriesBase._throwDocumentAlreadyDeletedInSession(this.docId, this.name);\r\n        }\r\n\r\n        const op = new AppendOperation(timestamp, values, tag);\r\n        const command = this.session.deferredCommandsMap.get(IdTypeAndName.keyFor(this.docId, \"TimeSeries\", this.name));\r\n\r\n        if (command) {\r\n            const tsCmd = command as TimeSeriesBatchCommandData;\r\n            tsCmd.timeSeries.append(op);\r\n        } else {\r\n            const appends = [] as AppendOperation[];\r\n            appends.push(op);\r\n            this.session.defer(new TimeSeriesBatchCommandData(this.docId, this.name, appends, null));\r\n        }\r\n    }\r\n\r\n    public delete(): void\r\n    public delete(from: Date, to: Date): void;\r\n    public delete(from?: Date, to?: Date): void {\r\n        const documentInfo = this.session.documentsById.getValue(this.docId);\r\n        if (documentInfo && this.session.deletedEntities.contains(documentInfo.entity)) {\r\n            SessionTimeSeriesBase._throwDocumentAlreadyDeletedInSession(this.docId, this.name);\r\n        }\r\n\r\n        const op = new DeleteOperation(from, to);\r\n        const command = this.session.deferredCommandsMap.get(IdTypeAndName.keyFor(this.docId, \"TimeSeries\", this.name));\r\n        if (command) {\r\n            const tsCmd = command as TimeSeriesBatchCommandData;\r\n            tsCmd.timeSeries.delete(op);\r\n        } else {\r\n            const deletes = [] as DeleteOperation[];\r\n            deletes.push(op);\r\n            this.session.defer(new TimeSeriesBatchCommandData(this.docId, this.name, null, deletes));\r\n        }\r\n\r\n\r\n        this._removeFromCacheIfNeeded(from, to);\r\n    }\r\n\r\n    public deleteAt(at: Date) {\r\n        this.delete(at, at);\r\n    }\r\n\r\n    private _removeFromCacheIfNeeded(from: Date, to: Date) {\r\n        const cache = this.session.timeSeriesByDocId.get(this.docId);\r\n        if (!cache) {\r\n            return;\r\n        }\r\n\r\n        if (!from && !to) {\r\n            cache.delete(this.name);\r\n            return;\r\n        }\r\n\r\n        const ranges = cache.get(this.name);\r\n        if (ranges && ranges.length) {\r\n            const newRanges =\r\n                ranges.filter(range => DatesComparator.compare(leftDate(range.from), leftDate(from)) > 0\r\n                    || DatesComparator.compare(rightDate(range.to), rightDate(to)) < 0);\r\n            cache.set(this.name, newRanges);\r\n        }\r\n    }\r\n\r\n    protected _incrementInternal(timestamp: Date, values: number[]): void {\r\n        const documentInfo = this.session.documentsById.getValue(this.docId);\r\n        if (documentInfo && this.session.deletedEntities.contains(documentInfo.entity)) {\r\n            SessionTimeSeriesBase._throwDocumentAlreadyDeletedInSession(this.docId, this.name);\r\n        }\r\n\r\n        const op = new IncrementOperation();\r\n        op.timestamp = timestamp;\r\n        op.values = values;\r\n\r\n        const command = this.session.deferredCommandsMap.get(IdTypeAndName.keyFor(this.docId, \"TimeSeriesWithIncrements\", this.name));\r\n        if (command) {\r\n            const tsCmd = command as IncrementalTimeSeriesBatchCommandData;\r\n            tsCmd.timeSeries.increment(op);\r\n        } else {\r\n            const list: IncrementOperation[] = [];\r\n            list.push(op);\r\n            this.session.defer(new IncrementalTimeSeriesBatchCommandData(this.docId, this.name, list));\r\n        }\r\n    }\r\n\r\n    private static _throwDocumentAlreadyDeletedInSession(documentId: string, timeSeries: string) {\r\n        throwError(\"InvalidOperationException\", \"Can't modify timeseries \" + timeSeries\r\n            + \" of document \" + documentId + \", the document was already deleted in this session\");\r\n    }\r\n\r\n    protected _throwEntityNotInSession() {\r\n        throwError(\"InvalidArgumentException\", \"Entity is not associated with the session, cannot perform timeseries operations to it. \"\r\n            + \"Use documentId instead or track the entity in the session.\");\r\n    }\r\n\r\n    public async getTimeSeriesAndIncludes(from: Date, to: Date, includes: (builder: ITimeSeriesIncludeBuilder) => void, start: number, pageSize: number): Promise<TimeSeriesEntry[]> {\r\n        if (pageSize === 0) {\r\n            return [];\r\n        }\r\n\r\n        const document = this.session.documentsById.getValue(this.docId);\r\n\r\n        if (document) {\r\n            const metadataTimeSeries = document.metadata[CONSTANTS.Documents.Metadata.TIME_SERIES] as string[];\r\n            if (metadataTimeSeries && TypeUtil.isArray(metadataTimeSeries)) {\r\n\r\n                if (!metadataTimeSeries.some(x => StringUtil.equalsIgnoreCase(x, this.name))) {\r\n                    // the document is loaded in the session, but the metadata says that there is no such timeseries\r\n                    return [];\r\n                }\r\n            }\r\n        }\r\n\r\n        this.session.incrementRequestCount();\r\n\r\n        const rangeResult = await this.session.operations.send(new GetTimeSeriesOperation(this.docId, this.name, from, to, start, pageSize, includes), this.session.sessionInfo);\r\n\r\n        if (!rangeResult) {\r\n            return null;\r\n        }\r\n\r\n        if (!this.session.noTracking) {\r\n            this._handleIncludes(rangeResult);\r\n\r\n            let cache = this.session.timeSeriesByDocId.get(this.docId);\r\n            if (!cache) {\r\n                cache = CaseInsensitiveKeysMap.create();\r\n                this.session.timeSeriesByDocId.set(this.docId, cache);\r\n            }\r\n\r\n            const ranges = cache.get(this.name);\r\n            if (ranges && ranges.length > 0) {\r\n                // update\r\n                const index = DatesComparator.compare(leftDate(ranges[0].from), rightDate(to)) > 0 ? 0 : ranges.length;\r\n                ranges.splice(index, 0, rangeResult);\r\n            } else {\r\n                const item: TimeSeriesRangeResult[] = [];\r\n                item.push(rangeResult);\r\n                cache.set(this.name, item);\r\n            }\r\n        }\r\n\r\n        return rangeResult.entries;\r\n    }\r\n\r\n    private _handleIncludes(rangeResult: TimeSeriesRangeResult) {\r\n        if (!rangeResult.includes) {\r\n            return;\r\n        }\r\n\r\n        this.session.registerIncludes(rangeResult.includes);\r\n\r\n        rangeResult.includes = null;\r\n    }\r\n\r\n    private static _skipAndTrimRangeIfNeeded(from: Date,\r\n                                             to: Date,\r\n                                             fromRange: TimeSeriesRangeResult,\r\n                                             toRange: TimeSeriesRangeResult,\r\n                                             values: TimeSeriesEntry[],\r\n                                             skip: number,\r\n                                             trim: number) {\r\n        if (fromRange && DatesComparator.compare(rightDate(fromRange.to), leftDate(from)) >= 0) {\r\n            // need to skip a part of the first range\r\n            if (toRange && DatesComparator.compare(leftDate(toRange.from), rightDate(to)) <= 0) {\r\n                // also need to trim a part of the last range\r\n                return values.slice(skip, values.length - trim);\r\n            }\r\n\r\n            return values.slice(skip);\r\n        }\r\n\r\n        if (toRange && DatesComparator.compare(leftDate(toRange.from), rightDate(to)) <= 0) {\r\n            // trim a part of the last range\r\n            return values.slice(0, values.length - trim);\r\n        }\r\n\r\n        return values;\r\n    }\r\n\r\n    protected async _serveFromCache(from: Date, to: Date, start: number, pageSize: number, includes: (builder: ITimeSeriesIncludeBuilder) => void) {\r\n        const cache = this.session.timeSeriesByDocId.get(this.docId);\r\n        const ranges = cache.get(this.name);\r\n        // try to find a range in cache that contains [from, to]\r\n        // if found, chop just the relevant part from it and return to the user.\r\n\r\n        // otherwise, try to find two ranges (fromRange, toRange),\r\n        // such that 'fromRange' is the last occurence for which range.From <= from\r\n        // and 'toRange' is the first occurence for which range.To >= to.\r\n        // At the same time, figure out the missing partial ranges that we need to get from the server.\r\n\r\n        let toRangeIndex: number;\r\n        let fromRangeIndex = -1;\r\n\r\n        let rangesToGetFromServer: TimeSeriesRange[];\r\n\r\n        for (toRangeIndex = 0; toRangeIndex < ranges.length; toRangeIndex++) {\r\n            if (DatesComparator.compare(leftDate(ranges[toRangeIndex].from), leftDate(from)) <= 0) {\r\n                if (DatesComparator.compare(rightDate(ranges[toRangeIndex].to), rightDate(to)) >= 0\r\n                    || (ranges[toRangeIndex].entries.length - start >= pageSize)) {\r\n                    // we have the entire range in cache\r\n                    // we have all the range we need\r\n                    // or that we have all the results we need in smaller range\r\n\r\n                    return SessionTimeSeriesBase._chopRelevantRange(ranges[toRangeIndex], from, to, start, pageSize);\r\n                }\r\n\r\n                fromRangeIndex = toRangeIndex;\r\n                continue;\r\n            }\r\n\r\n            // can't get the entire range from cache\r\n            if (!rangesToGetFromServer) {\r\n                rangesToGetFromServer = [];\r\n            }\r\n\r\n            // add the missing part [f, t] between current range start (or 'from')\r\n            // and previous range end (or 'to') to the list of ranges we need to get from server\r\n\r\n            const fromToUse = toRangeIndex === 0 || DatesComparator.compare(rightDate(ranges[toRangeIndex - 1].to), leftDate(from)) < 0\r\n                ? from\r\n                : ranges[toRangeIndex - 1].to;\r\n\r\n            const toToUse = DatesComparator.compare(leftDate(ranges[toRangeIndex].from), rightDate(to)) <= 0\r\n                ? ranges[toRangeIndex].from\r\n                : to;\r\n\r\n            rangesToGetFromServer.push({\r\n                name: this.name,\r\n                from: fromToUse,\r\n                to: toToUse\r\n            });\r\n\r\n            if (DatesComparator.compare(rightDate(ranges[toRangeIndex].to), rightDate(to)) >= 0) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (toRangeIndex === ranges.length) {\r\n            // requested range [from, to] ends after all ranges in cache\r\n            // add the missing part between the last range end and 'to'\r\n            // to the list of ranges we need to get from server\r\n\r\n            if (!rangesToGetFromServer) {\r\n                rangesToGetFromServer = [];\r\n            }\r\n\r\n            rangesToGetFromServer.push({\r\n                name: this.name,\r\n                from: ranges.at(-1).to,\r\n                to\r\n            });\r\n        }\r\n\r\n        // get all the missing parts from server\r\n\r\n        this.session.incrementRequestCount();\r\n\r\n        const details = await this.session.operations.send(\r\n            new GetMultipleTimeSeriesOperation(this.docId, rangesToGetFromServer, start, pageSize, includes), this.session.sessionInfo);\r\n\r\n        if (includes) {\r\n            this._registerIncludes(details);\r\n        }\r\n\r\n        // merge all the missing parts we got from server\r\n        // with all the ranges in cache that are between 'fromRange' and 'toRange'\r\n\r\n        let resultToUser: TimeSeriesEntry[];\r\n\r\n        const mergedValues = SessionTimeSeriesBase._mergeRangesWithResults(\r\n            from,\r\n            to,\r\n            ranges,\r\n            fromRangeIndex,\r\n            toRangeIndex,\r\n            details.values.get(this.name),\r\n            r => resultToUser = r);\r\n\r\n        if (!this.session.noTracking) {\r\n            const fromDates = details.values.get(this.name)\r\n                .map(x => leftDate(x.from));\r\n\r\n            if (fromDates.length) {\r\n                from = fromDates[0].date;\r\n\r\n                for (const d of fromDates) {\r\n                    if (DatesComparator.compare(d, leftDate(from)) < 0) {\r\n                        from = d.date;\r\n                    }\r\n                }\r\n            } else {\r\n                from = null;\r\n            }\r\n\r\n            const toDates = details.values.get(this.name)\r\n                .map(x => rightDate(x.to))\r\n\r\n            if (toDates.length) {\r\n                to = toDates[0].date;\r\n                for (const d of toDates) {\r\n                    if (DatesComparator.compare(d, rightDate(to)) > 0) {\r\n                        to = d.date;\r\n                    }\r\n                }\r\n            } else {\r\n                to = null;\r\n            }\r\n\r\n            InMemoryDocumentSessionOperations.addToCache(this.name, from, to, fromRangeIndex, toRangeIndex, ranges, cache, mergedValues);\r\n        }\r\n\r\n        return resultToUser;\r\n    }\r\n\r\n    private _registerIncludes(details: TimeSeriesDetails) {\r\n        for (const rangeResult of details.values.get(this.name)) {\r\n            this._handleIncludes(rangeResult);\r\n        }\r\n    }\r\n\r\n    private static _mergeRangesWithResults(from: Date,\r\n                                           to: Date,\r\n                                           ranges: TimeSeriesRangeResult[],\r\n                                           fromRangeIndex: number,\r\n                                           toRangeIndex: number,\r\n                                           resultFromServer: TimeSeriesRangeResult[],\r\n                                           resultToUserSetter: (value: TimeSeriesEntry[]) => void): TimeSeriesEntry[] {\r\n        let skip = 0;\r\n        let trim = 0;\r\n        let currentResultIndex = 0;\r\n        const mergedValues: TimeSeriesEntry[] = [];\r\n\r\n        const start = fromRangeIndex !== -1 ? fromRangeIndex : 0;\r\n        const end = toRangeIndex === ranges.length ? ranges.length - 1 : toRangeIndex;\r\n\r\n        for (let i = start; i <= end; i++) {\r\n            if (i === fromRangeIndex) {\r\n                if (DatesComparator.compare(leftDate(ranges[i].from), leftDate(from)) <= 0 &&\r\n                    DatesComparator.compare(leftDate(from), rightDate(ranges[i].to)) <= 0) {\r\n                    // requested range [from, to] starts inside 'fromRange'\r\n                    // i.e fromRange.From <= from <= fromRange.To\r\n                    // so we might need to skip a part of it when we return the\r\n                    // result to the user (i.e. skip [fromRange.From, from])\r\n\r\n                    if (ranges[i].entries) {\r\n                        for (const v of ranges[i].entries) {\r\n                            mergedValues.push(v);\r\n\r\n                            if (DatesComparator.compare(definedDate(v.timestamp), leftDate(from)) < 0) {\r\n                                skip++;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                continue;\r\n            }\r\n\r\n            if (currentResultIndex < resultFromServer.length\r\n                && DatesComparator.compare(leftDate(resultFromServer[currentResultIndex].from), leftDate(ranges[i].from)) < 0) {\r\n                // add current result from server to the merged list\r\n                // in order to avoid duplication, skip first item in range\r\n                // (unless this is the first time we're adding to the merged list)\r\n\r\n                const toAdd = resultFromServer[currentResultIndex++]\r\n                    .entries\r\n                    .slice(mergedValues.length === 0 ? 0 : 1);\r\n\r\n                mergedValues.push(...toAdd);\r\n            }\r\n\r\n            if (i === toRangeIndex) {\r\n                if (DatesComparator.compare(leftDate(ranges[i].from), rightDate(to)) <= 0) {\r\n                    // requested range [from, to] ends inside 'toRange'\r\n                    // so we might need to trim a part of it when we return the\r\n                    // result to the user (i.e. trim [to, toRange.to])\r\n\r\n                    for (let index = mergedValues.length === 0 ? 0 : 1; index < ranges[i].entries.length; index++) {\r\n                        mergedValues.push(ranges[i].entries[index]);\r\n                        if (DatesComparator.compare(definedDate(ranges[i].entries[index].timestamp), rightDate(to)) > 0) {\r\n                            trim++;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                continue;\r\n            }\r\n\r\n            // add current range from cache to the merged list.\r\n            // in order to avoid duplication, skip first item in range if needed\r\n\r\n            let shouldSkip = false;\r\n            if (mergedValues.length > 0) {\r\n                shouldSkip = ranges[i].entries[0].timestamp.getTime() === mergedValues.at(-1).timestamp.getTime();\r\n            }\r\n\r\n            const toAdd = ranges[i].entries.slice(!shouldSkip ? 0 : 1);\r\n            mergedValues.push(...toAdd);\r\n        }\r\n\r\n        if (currentResultIndex < resultFromServer.length) {\r\n            // the requested range ends after all the ranges in cache,\r\n            // so the last missing part is from server\r\n            // add last missing part to the merged list\r\n\r\n            const toAdd = resultFromServer[currentResultIndex++]\r\n                .entries\r\n                .slice(mergedValues.length === 0 ? 0 : 1);\r\n            mergedValues.push(...toAdd);\r\n        }\r\n\r\n        resultToUserSetter(SessionTimeSeriesBase._skipAndTrimRangeIfNeeded(from,\r\n            to,\r\n            fromRangeIndex === -1 ? null : ranges[fromRangeIndex],\r\n            toRangeIndex === ranges.length ? null : ranges[toRangeIndex],\r\n            mergedValues,\r\n            skip,\r\n            trim));\r\n\r\n        return mergedValues;\r\n    }\r\n\r\n    private static _chopRelevantRange(range: TimeSeriesRangeResult, from: Date, to: Date, start: number, pageSize: number): TimeSeriesEntry[] {\r\n        if (!range.entries) {\r\n            return [];\r\n        }\r\n\r\n        const result: TimeSeriesEntry[] = [];\r\n\r\n        for (const value of range.entries) {\r\n            if (DatesComparator.compare(definedDate(value.timestamp), rightDate(to)) > 0) {\r\n                break;\r\n            }\r\n\r\n            if (DatesComparator.compare(definedDate(value.timestamp), leftDate(from)) < 0) {\r\n                continue;\r\n            }\r\n\r\n            if (start-- > 0) {\r\n                continue;\r\n            }\r\n\r\n            if (pageSize-- <= 0) {\r\n                break;\r\n            }\r\n\r\n            result.push(value);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    protected async _getFromCache(from: Date, to: Date, includes: (builder: ITimeSeriesIncludeBuilder) => void, start: number, pageSize: number) {\r\n        // RavenDB-16060\r\n        // Typed TimeSeries results need special handling when served from cache\r\n        // since we cache the results untyped\r\n\r\n        // in node we return untyped entries here\r\n\r\n        const resultToUser = await this._serveFromCache(from, to, start, pageSize, includes);\r\n        return resultToUser;\r\n    }\r\n\r\n    protected _notInCache(from: Date, to: Date) {\r\n        const cache = this.session.timeSeriesByDocId.get(this.docId);\r\n        if (!cache) {\r\n            return true;\r\n        }\r\n\r\n        const ranges = cache.get(this.name);\r\n        if (!ranges) {\r\n            return true;\r\n        }\r\n\r\n        return ranges.length === 0\r\n            || DatesComparator.compare(leftDate(ranges[0].from), rightDate(to)) > 0\r\n            || DatesComparator.compare(rightDate(ranges.at(-1).to), leftDate(from)) < 0;\r\n    }\r\n}\r\n\r\nexport interface CachedEntryInfo {\r\n    servedFromCache: boolean;\r\n    resultToUser: TimeSeriesEntry[];\r\n    mergedValues: TimeSeriesEntry[];\r\n    fromRangeIndex: number;\r\n    toRangeIndex: number;\r\n}\r\n"]}