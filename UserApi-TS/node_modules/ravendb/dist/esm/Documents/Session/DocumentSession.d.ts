import { Writable } from "node:stream";
import { ConcurrencyCheckMode, IDocumentSession, IDocumentSessionImpl, LoadOptions, SessionLoadInternalParameters, SessionLoadStartingWithOptions } from "./IDocumentSession.js";
import { DocumentConventions } from "../Conventions/DocumentConventions.js";
import { ClassConstructor, EntitiesCollectionObject, IRavenObject, ObjectTypeDescriptor } from "../../Types/index.js";
import { DocumentType } from "../DocumentAbstractions.js";
import { InMemoryDocumentSessionOperations } from "./InMemoryDocumentSessionOperations.js";
import { DocumentStore } from "../DocumentStore.js";
import { ILoaderWithInclude } from "./Loaders/ILoaderWithInclude.js";
import { IRawDocumentQuery } from "./IRawDocumentQuery.js";
import { AdvancedDocumentQueryOptions, DocumentQueryOptions } from "./QueryOptions.js";
import { IDocumentQuery } from "./IDocumentQuery.js";
import { IAttachmentsSessionOperations } from "./IAttachmentsSessionOperations.js";
import { IEagerSessionOperations } from "./Operations/Lazy/IEagerSessionOperations.js";
import { Lazy } from "../Lazy.js";
import { ILazyOperation } from "./Operations/Lazy/ILazyOperation.js";
import { ResponseTimeInformation } from "./ResponseTimeInformation.js";
import { ILazySessionOperations } from "./Operations/Lazy/ILazySessionOperations.js";
import { JavaScriptArray } from "./JavaScriptArray.js";
import { IRevisionsSessionOperations } from "./IRevisionsSessionOperations.js";
import { DocumentResultStream } from "./DocumentResultStream.js";
import { IAdvancedSessionOperations, StreamQueryStatisticsCallback } from "./IAdvancedSessionOperations.js";
import { IClusterTransactionOperations } from "./IClusterTransactionOperations.js";
import { ClusterTransactionOperationsBase } from "./ClusterTransactionOperationsBase.js";
import { SessionOptions } from "./SessionOptions.js";
import { ISessionDocumentCounters } from "./ISessionDocumentCounters.js";
import { ISessionDocumentTimeSeries } from "./ISessionDocumentTimeSeries.js";
import { ISessionDocumentTypedTimeSeries } from "./ISessionDocumentTypedTimeSeries.js";
import { ISessionDocumentRollupTypedTimeSeries } from "./ISessionDocumentRollupTypedTimeSeries.js";
import { JavaScriptMap } from "./JavaScriptMap.js";
import { AbstractCommonApiForIndexes } from "../Indexes/AbstractCommonApiForIndexes.js";
import { ConditionalLoadResult } from "./ConditionalLoadResult.js";
import { ISessionDocumentIncrementalTimeSeries } from "./ISessionDocumentIncrementalTimeSeries.js";
import { ISessionDocumentTypedIncrementalTimeSeries } from "./ISessionDocumentTypedIncrementalTimeSeries.js";
export interface IStoredRawEntityInfo {
    originalValue: object;
    metadata: object;
    originalMetadata: object;
    id: string;
    changeVector?: string | null;
    expectedChangeVector?: string | null;
    concurrencyCheckMode: ConcurrencyCheckMode;
    documentType: DocumentType;
}
export declare class DocumentSession extends InMemoryDocumentSessionOperations implements IDocumentSession, IDocumentSessionImpl {
    constructor(documentStore: DocumentStore, id: string, options: SessionOptions);
    get advanced(): IAdvancedSessionOperations;
    get session(): InMemoryDocumentSessionOperations;
    protected _generateId(entity: object): Promise<string>;
    numberOfRequestsInSession: number;
    load<TEntity extends object = IRavenObject>(id: string): Promise<TEntity | null>;
    load<TEntity extends object = IRavenObject>(id: string, options?: LoadOptions<TEntity>): Promise<TEntity | null>;
    load<TEntity extends object = IRavenObject>(id: string, documentType?: DocumentType<TEntity>): Promise<TEntity | null>;
    load<TEntity extends object = IRavenObject>(ids: string[]): Promise<EntitiesCollectionObject<TEntity>>;
    load<TEntity extends object = IRavenObject>(ids: string[], options?: LoadOptions<TEntity>): Promise<EntitiesCollectionObject<TEntity>>;
    load<TEntity extends object = IRavenObject>(ids: string[], documentType?: DocumentType<TEntity>): Promise<EntitiesCollectionObject<TEntity>>;
    private _prepareLoadInternalOpts;
    private _loadInternal;
    saveChanges(): Promise<void>;
    /**
     * Refreshes the specified entity from Raven server.
     */
    refresh<TEntity extends object>(entity: TEntity): Promise<void>;
    refresh<TEntity extends object>(entities: TEntity[]): Promise<void>;
    private _refreshEntityInternal;
    private _refreshEntitiesInternal;
    /**
     * Check if document exists without loading it
     */
    exists(id: string): Promise<boolean>;
    loadStartingWith<TEntity extends object>(idPrefix: string): Promise<TEntity[]>;
    loadStartingWith<TEntity extends object>(idPrefix: string, opts: SessionLoadStartingWithOptions<TEntity>): Promise<TEntity[]>;
    loadStartingWithIntoStream<TEntity extends object>(idPrefix: string, writable: Writable): Promise<void>;
    loadStartingWithIntoStream<TEntity extends object>(idPrefix: string, writable: Writable, opts: SessionLoadStartingWithOptions<TEntity>): Promise<void>;
    loadIntoStream(ids: string[], writable: Writable): Promise<void>;
    private _loadStartingWithInternal;
    loadInternal<TResult extends object>(ids: string[], opts: SessionLoadInternalParameters<TResult>): Promise<EntitiesCollectionObject<TResult>>;
    /**
     * Begin a load while including the specified path
     */
    include(path: string): ILoaderWithInclude;
    increment<T extends object, UValue>(id: string, path: string, valueToAdd: UValue): void;
    increment<T extends object, UValue>(entity: T, path: string, valueToAdd: UValue): void;
    addOrIncrement<T extends object, UValue>(id: string, entity: T, pathToObject: string, valToAdd: UValue): void;
    addOrPatchArray<T extends object, UValue>(id: string, entity: T, pathToArray: string, arrayAdder: (array: JavaScriptArray<UValue>) => void): void;
    addOrPatch<T extends object, UValue>(id: string, entity: T, pathToObject: string, value: UValue): void;
    private _valsCount;
    private _customCount;
    patch<TEntity extends object, UValue>(id: string, path: string, value: UValue): void;
    patch<TEntity extends object, UValue>(entity: TEntity, path: string, value: UValue): void;
    patchArray<TEntity extends object, UValue>(id: string, pathToArray: string, arrayAdder: (array: JavaScriptArray<UValue>) => void): void;
    patchArray<TEntity extends object, UValue>(entity: TEntity, pathToArray: string, arrayAdder: (array: JavaScriptArray<UValue>) => void): void;
    patchObject<TEntity extends object, TKey, TValue>(entity: TEntity, pathToObject: string, mapAdder: (map: JavaScriptMap<TKey, TValue>) => void): void;
    patchObject<TEntity extends object, TKey, TValue>(id: string, pathToObject: string, mapAdder: (map: JavaScriptMap<TKey, TValue>) => void): void;
    private _tryMergePatches;
    rawQuery<TEntity extends object>(query: string, documentType?: DocumentType<TEntity>): IRawDocumentQuery<TEntity>;
    query<TEntity extends object>(documentType: DocumentType<TEntity>): IDocumentQuery<TEntity>;
    query<TEntity extends object>(documentType: DocumentType<TEntity>, index: new () => AbstractCommonApiForIndexes): IDocumentQuery<TEntity>;
    query<TEntity extends object>(opts: DocumentQueryOptions<TEntity>): IDocumentQuery<TEntity>;
    documentQuery<T extends object>(opts: AdvancedDocumentQueryOptions<T>): IDocumentQuery<T>;
    documentQuery<T extends object>(documentType: DocumentType<T>): IDocumentQuery<T>;
    protected _processQueryParameters<T extends object>(opts: AdvancedDocumentQueryOptions<T>, conventions: DocumentConventions): {
        indexName: string;
        collection: string;
    };
    private _attachments;
    get attachments(): IAttachmentsSessionOperations;
    private _revisions;
    get revisions(): IRevisionsSessionOperations;
    private _clusterTransaction;
    get clusterTransaction(): IClusterTransactionOperations;
    protected _hasClusterSession(): boolean;
    protected _clearClusterSession(): void;
    get clusterSession(): ClusterTransactionOperationsBase;
    get lazily(): ILazySessionOperations;
    get eagerly(): IEagerSessionOperations;
    executeAllPendingLazyOperations(): Promise<ResponseTimeInformation>;
    private _executeLazyOperationsSingleStep;
    addLazyOperation<TLazyResult>(operation: ILazyOperation): Lazy<TLazyResult>;
    addLazyCountOperation(operation: ILazyOperation): Lazy<number>;
    lazyLoadInternal<TResult extends object>(ids: string[], includes: string[], clazz: ObjectTypeDescriptor<TResult>): Lazy<EntitiesCollectionObject<TResult>>;
    stream<T extends object>(query: IDocumentQuery<T>): Promise<DocumentResultStream<T>>;
    stream<T extends object>(query: IDocumentQuery<T>, streamQueryStats: StreamQueryStatisticsCallback): Promise<DocumentResultStream<T>>;
    stream<T extends object>(query: IRawDocumentQuery<T>): Promise<DocumentResultStream<T>>;
    stream<T extends object>(query: IRawDocumentQuery<T>, streamQueryStats: StreamQueryStatisticsCallback): Promise<DocumentResultStream<T>>;
    stream<T extends object>(idPrefix: string): Promise<DocumentResultStream<T>>;
    stream<T extends object>(idPrefix: string, opts: SessionLoadStartingWithOptions<T>): Promise<DocumentResultStream<T>>;
    private _streamStartingWith;
    private _streamQueryResults;
    private _getStreamResultTransform;
    /**
     *  Returns the results of a query directly into stream
     */
    streamInto<T extends object>(query: IDocumentQuery<T>, writable: Writable): Promise<void>;
    /**
     *  Returns the results of a query directly into stream
     */
    streamInto<T extends object>(query: IRawDocumentQuery<T>, writable: Writable): Promise<void>;
    countersFor(documentId: string): ISessionDocumentCounters;
    countersFor(entity: object): ISessionDocumentCounters;
    timeSeriesFor(documentId: string, name: string): ISessionDocumentTimeSeries;
    timeSeriesFor(entity: any, name: string): ISessionDocumentTimeSeries;
    timeSeriesFor<T extends object>(documentId: string, clazz: ClassConstructor<T>): ISessionDocumentTypedTimeSeries<T>;
    timeSeriesFor<T extends object>(documentId: string, name: string, clazz: ClassConstructor<T>): ISessionDocumentTypedTimeSeries<T>;
    timeSeriesFor<T extends object>(entity: object, clazz: ClassConstructor<T>): ISessionDocumentTypedTimeSeries<T>;
    timeSeriesFor<T extends object>(entity: object, name: string, clazz: ClassConstructor<T>): ISessionDocumentTypedTimeSeries<T>;
    timeSeriesRollupFor<T extends object>(entity: object, policy: string, clazz: ClassConstructor<T>): ISessionDocumentRollupTypedTimeSeries<T>;
    timeSeriesRollupFor<T extends object>(entity: object, policy: string, raw: string, clazz: ClassConstructor<T>): ISessionDocumentRollupTypedTimeSeries<T>;
    timeSeriesRollupFor<T extends object>(documentId: string, policy: string, clazz: ClassConstructor<T>): ISessionDocumentRollupTypedTimeSeries<T>;
    timeSeriesRollupFor<T extends object>(documentId: string, policy: string, raw: string, clazz: ClassConstructor<T>): ISessionDocumentRollupTypedTimeSeries<T>;
    incrementalTimeSeriesFor(documentId: string, name: string): ISessionDocumentIncrementalTimeSeries;
    incrementalTimeSeriesFor(entity: object, name: string): ISessionDocumentIncrementalTimeSeries;
    incrementalTimeSeriesFor<T extends object>(documentId: string, clazz: ClassConstructor<T>): ISessionDocumentTypedIncrementalTimeSeries<T>;
    incrementalTimeSeriesFor<T extends object>(documentId: string, name: string, clazz: ClassConstructor<T>): ISessionDocumentTypedIncrementalTimeSeries<T>;
    incrementalTimeSeriesFor<T extends object>(entity: object, clazz: ClassConstructor<T>): ISessionDocumentTypedIncrementalTimeSeries<T>;
    incrementalTimeSeriesFor<T extends object>(entity: object, name: string, clazz: ClassConstructor<T>): ISessionDocumentTypedIncrementalTimeSeries<T>;
    conditionalLoad<T extends object>(id: string, changeVector: string, clazz: ClassConstructor<T>): Promise<ConditionalLoadResult<T>>;
}
//# sourceMappingURL=DocumentSession.d.ts.map