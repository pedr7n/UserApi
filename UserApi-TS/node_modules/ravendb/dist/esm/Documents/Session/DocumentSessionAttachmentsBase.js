import { AdvancedSessionExtensionBase } from "./AdvancedSessionExtensionBase.js";
import { CONSTANTS } from "./../../Constants.js";
import { StringUtil } from "../../Utility/StringUtil.js";
import { throwError } from "../../Exceptions/index.js";
import { IdTypeAndName } from "../IdTypeAndName.js";
import { PutAttachmentCommandData } from "../Commands/Batches/PutAttachmentCommandData.js";
import { DeleteAttachmentCommandData } from "../Commands/Batches/DeleteAttachmentCommandData.js";
import { MoveAttachmentCommandData } from "../Commands/Batches/MoveAttachmentCommandData.js";
import { CopyAttachmentCommandData } from "../Commands/Batches/CopyAttachmentCommandData.js";
import { TypeUtil } from "../../Utility/TypeUtil.js";
export class DocumentSessionAttachmentsBase extends AdvancedSessionExtensionBase {
    constructor(session) {
        super(session);
    }
    getNames(entity) {
        if (!entity) {
            return [];
        }
        if (TypeUtil.isString(entity)) {
            throwError("InvalidArgumentException", "getNames requires a tracked entity object, other types such as documentId are not valid.");
        }
        const document = this._session.documentsByEntity.get(entity);
        if (!document) {
            this._throwEntityNotInSession(entity);
        }
        const results = document.metadata[CONSTANTS.Documents.Metadata.ATTACHMENTS];
        return results || [];
    }
    store(documentIdOrEntity, name, stream, contentType = null) {
        if (typeof documentIdOrEntity === "object") {
            return this._storeAttachmentByEntity(documentIdOrEntity, name, stream, contentType);
        }
        if (StringUtil.isNullOrWhitespace(documentIdOrEntity)) {
            throwError("InvalidArgumentException", "DocumentId cannot be null");
        }
        if (StringUtil.isNullOrWhitespace(name)) {
            throwError("InvalidArgumentException", "Name cannot be null");
        }
        if (this._deferredCommandsMap.has(IdTypeAndName.keyFor(documentIdOrEntity, "DELETE", null))) {
            DocumentSessionAttachmentsBase._throwOtherDeferredCommandException(documentIdOrEntity, name, "store", "delete");
        }
        if (this._deferredCommandsMap.has(IdTypeAndName.keyFor(documentIdOrEntity, "AttachmentPUT", name))) {
            DocumentSessionAttachmentsBase._throwOtherDeferredCommandException(documentIdOrEntity, name, "store", "create");
        }
        if (this._deferredCommandsMap.has(IdTypeAndName.keyFor(documentIdOrEntity, "AttachmentDELETE", name))) {
            DocumentSessionAttachmentsBase._throwOtherDeferredCommandException(documentIdOrEntity, name, "store", "delete");
        }
        if (this._deferredCommandsMap.has(IdTypeAndName.keyFor(documentIdOrEntity, "AttachmentMOVE", name))) {
            DocumentSessionAttachmentsBase._throwOtherDeferredCommandException(documentIdOrEntity, name, "store", "rename");
        }
        const documentInfo = this._documentsById.getValue(documentIdOrEntity);
        if (documentInfo && this._session.deletedEntities.contains(documentInfo.entity)) {
            DocumentSessionAttachmentsBase._throwDocumentAlreadyDeleted(documentIdOrEntity, name, "store", null, documentIdOrEntity);
        }
        this.defer(new PutAttachmentCommandData(documentIdOrEntity, name, stream, contentType, null));
    }
    _storeAttachmentByEntity(entity, name, stream, contentType) {
        const document = this._session.documentsByEntity.get(entity);
        if (!document) {
            this._throwEntityNotInSessionOrMissingId(entity);
        }
        return this.store(document.id, name, stream, contentType);
    }
    _throwEntityNotInSessionOrMissingId(entity) {
        return throwError("InvalidArgumentException", entity
            + " is not associated with the session. Use documentId instead or track the entity in the session.");
    }
    _throwEntityNotInSession(entity) {
        return throwError("InvalidArgumentException", entity
            + " is not associated with the session. You need to track the entity in the session");
    }
    _deleteAttachmentByEntity(entity, name) {
        const document = this._session.documentsByEntity.get(entity);
        if (!document) {
            this._throwEntityNotInSessionOrMissingId(entity);
        }
        return this.delete(document.id, name);
    }
    delete(entityOrId, name) {
        if (typeof entityOrId !== "string") {
            return this._deleteAttachmentByEntity(entityOrId, name);
        }
        if (StringUtil.isNullOrWhitespace(entityOrId)) {
            throwError("InvalidArgumentException", "DocumentId cannot be null");
        }
        if (StringUtil.isNullOrWhitespace(name)) {
            throwError("InvalidArgumentException", "Name cannot be null");
        }
        if (this._deferredCommandsMap.has(IdTypeAndName.keyFor(entityOrId, "DELETE", null)) ||
            this._deferredCommandsMap.has(IdTypeAndName.keyFor(entityOrId, "AttachmentDELETE", name))) {
            return; // no-op
        }
        const documentInfo = this._documentsById.getValue(entityOrId);
        if (documentInfo && this._session.deletedEntities.contains(documentInfo.entity)) {
            return; //no-op
        }
        if (this._deferredCommandsMap.has(IdTypeAndName.keyFor(entityOrId, "AttachmentPUT", name))) {
            DocumentSessionAttachmentsBase._throwOtherDeferredCommandException(entityOrId, name, "delete", "create");
        }
        if (this._deferredCommandsMap.has(IdTypeAndName.keyFor(entityOrId, "AttachmentMOVE", name))) {
            DocumentSessionAttachmentsBase._throwOtherDeferredCommandException(entityOrId, name, "delete", "rename");
        }
        this.defer(new DeleteAttachmentCommandData(entityOrId, name, null));
    }
    rename(entityOrId, name, newName) {
        this.move(entityOrId, name, entityOrId, newName);
    }
    move(sourceEntityOrId, sourceName, destinationEntityOrId, destinationName) {
        return typeof sourceEntityOrId === "string"
            ? this._moveByEntityIds(sourceEntityOrId, sourceName, destinationEntityOrId, destinationName)
            : this._moveByEntities(sourceEntityOrId, sourceName, destinationEntityOrId, destinationName);
    }
    _moveByEntities(sourceEntity, sourceName, destinationEntity, destinationName) {
        if (!sourceEntity) {
            throwError("InvalidArgumentException", "SourceEntity cannot be null");
        }
        if (!destinationEntity) {
            throwError("InvalidArgumentException", "DestinationEntity cannot be null");
        }
        const sourceDocument = this._session.documentsByEntity.get(sourceEntity);
        if (!sourceDocument) {
            this._throwEntityNotInSessionOrMissingId(sourceEntity);
        }
        const destinationDocument = this._session.documentsByEntity.get(destinationEntity);
        if (!destinationDocument) {
            this._throwEntityNotInSessionOrMissingId(destinationEntity);
        }
        this._moveByEntityIds(sourceDocument.id, sourceName, destinationDocument.id, destinationName);
    }
    _moveByEntityIds(sourceDocumentId, sourceName, destinationDocumentId, destinationName) {
        if (StringUtil.isNullOrWhitespace(sourceDocumentId)) {
            throwError("InvalidArgumentException", "SourceDocumentId is required.");
        }
        if (StringUtil.isNullOrWhitespace(sourceName)) {
            throwError("InvalidArgumentException", "SourceName is required.");
        }
        if (StringUtil.isNullOrWhitespace(destinationDocumentId)) {
            throwError("InvalidArgumentException", "DestinationDocumentId is required.");
        }
        if (StringUtil.isNullOrWhitespace(destinationName)) {
            throwError("InvalidArgumentException", "DestinationName is required.");
        }
        if (StringUtil.equalsIgnoreCase(sourceDocumentId, destinationDocumentId)
            && sourceName === destinationName) {
            return; // no-op
        }
        const sourceDocument = this._documentsById.getValue(sourceDocumentId);
        if (sourceDocument && this._session.deletedEntities.contains(sourceDocument.entity)) {
            DocumentSessionAttachmentsBase._throwDocumentAlreadyDeleted(sourceDocumentId, sourceName, "move", destinationDocumentId, sourceDocumentId);
        }
        const destinationDocument = this._documentsById.getValue(destinationDocumentId);
        if (destinationDocument && this._session.deletedEntities.contains(destinationDocument.entity)) {
            DocumentSessionAttachmentsBase._throwDocumentAlreadyDeleted(sourceDocumentId, sourceName, "move", destinationDocumentId, destinationDocumentId);
        }
        if (this._deferredCommandsMap.has(IdTypeAndName.keyFor(sourceDocumentId, "AttachmentDELETE", sourceName))) {
            DocumentSessionAttachmentsBase._throwOtherDeferredCommandException(sourceDocumentId, sourceName, "rename", "delete");
        }
        if (this._deferredCommandsMap.has(IdTypeAndName.keyFor(sourceDocumentId, "AttachmentMOVE", sourceName))) {
            DocumentSessionAttachmentsBase._throwOtherDeferredCommandException(sourceDocumentId, sourceName, "rename", "rename");
        }
        if (this._deferredCommandsMap.has(IdTypeAndName.keyFor(destinationDocumentId, "AttachmentDELETE", destinationName))) {
            DocumentSessionAttachmentsBase._throwOtherDeferredCommandException(sourceDocumentId, destinationName, "rename", "delete");
        }
        if (this._deferredCommandsMap.has(IdTypeAndName.keyFor(destinationDocumentId, "AttachmentMOVE", destinationName))) {
            DocumentSessionAttachmentsBase._throwOtherDeferredCommandException(sourceDocumentId, destinationName, "rename", "rename");
        }
        const cmdData = new MoveAttachmentCommandData(sourceDocumentId, sourceName, destinationDocumentId, destinationName, null);
        this.defer(cmdData);
    }
    copy(sourceEntityOrId, sourceName, destinationEntityOrId, destinationName) {
        return typeof sourceEntityOrId === "string"
            ? this._copyByEntityIds(sourceEntityOrId, sourceName, destinationEntityOrId, destinationName)
            : this._copyByEntities(sourceEntityOrId, sourceName, destinationEntityOrId, destinationName);
    }
    _copyByEntities(sourceEntity, sourceName, destinationEntity, destinationName) {
        if (!sourceEntity) {
            throwError("InvalidArgumentException", "SourceEntity cannot be null");
        }
        if (!destinationEntity) {
            throwError("InvalidArgumentException", "DestinationEntity cannot be null");
        }
        const sourceDocument = this._session.documentsByEntity.get(sourceEntity);
        if (!sourceDocument) {
            this._throwEntityNotInSessionOrMissingId(sourceEntity);
        }
        const destinationDocument = this._session.documentsByEntity.get(destinationEntity);
        if (!destinationDocument) {
            this._throwEntityNotInSessionOrMissingId(destinationEntity);
        }
        this.copy(sourceDocument.id, sourceName, destinationDocument.id, destinationName);
    }
    _copyByEntityIds(sourceDocumentId, sourceName, destinationDocumentId, destinationName) {
        if (StringUtil.isNullOrWhitespace(sourceDocumentId)) {
            throwError("InvalidArgumentException", "SourceDocumentId is required.");
        }
        if (StringUtil.isNullOrWhitespace(sourceName)) {
            throwError("InvalidArgumentException", "SourceName is required.");
        }
        if (StringUtil.isNullOrWhitespace(destinationDocumentId)) {
            throwError("InvalidArgumentException", "DestinationDocumentId is required.");
        }
        if (StringUtil.isNullOrWhitespace(destinationName)) {
            throwError("InvalidArgumentException", "DestinationName is required.");
        }
        if (StringUtil.equalsIgnoreCase(sourceDocumentId, destinationDocumentId)
            && sourceName === destinationName) {
            return; // no-op
        }
        const sourceDocument = this._documentsById.getValue(sourceDocumentId);
        if (sourceDocument && this._session.deletedEntities.contains(sourceDocument.entity)) {
            DocumentSessionAttachmentsBase._throwDocumentAlreadyDeleted(sourceDocumentId, sourceName, "copy", destinationDocumentId, sourceDocumentId);
        }
        const destinationDocument = this._documentsById.getValue(destinationDocumentId);
        if (destinationDocument && this._session.deletedEntities.contains(destinationDocument.entity)) {
            DocumentSessionAttachmentsBase._throwDocumentAlreadyDeleted(sourceDocumentId, sourceName, "copy", destinationDocumentId, destinationDocumentId);
        }
        if (this._deferredCommandsMap.has(IdTypeAndName.keyFor(sourceDocumentId, "AttachmentDELETE", sourceName))) {
            DocumentSessionAttachmentsBase._throwOtherDeferredCommandException(sourceDocumentId, sourceName, "copy", "delete");
        }
        if (this._deferredCommandsMap.has(IdTypeAndName.keyFor(sourceDocumentId, "AttachmentMOVE", sourceName))) {
            DocumentSessionAttachmentsBase._throwOtherDeferredCommandException(sourceDocumentId, sourceName, "copy", "rename");
        }
        if (this._deferredCommandsMap.has(IdTypeAndName.keyFor(destinationDocumentId, "AttachmentDELETE", destinationName))) {
            DocumentSessionAttachmentsBase._throwOtherDeferredCommandException(sourceDocumentId, destinationName, "copy", "delete");
        }
        if (this._deferredCommandsMap.has(IdTypeAndName.keyFor(destinationDocumentId, "AttachmentMOVE", destinationName))) {
            DocumentSessionAttachmentsBase._throwOtherDeferredCommandException(sourceDocumentId, destinationName, "copy", "rename");
        }
        const cmdData = new CopyAttachmentCommandData(sourceDocumentId, sourceName, destinationDocumentId, destinationName, null);
        this.defer(cmdData);
    }
    static _throwDocumentAlreadyDeleted(documentId, name, operation, destinationDocumentId, deletedDocumentId) {
        throwError("InvalidOperationException", "Can't " + operation + " attachment '" + name + "' of document '" + documentId + "' " +
            (destinationDocumentId ? " to '" + destinationDocumentId + "'" : "") +
            ", the document '" + deletedDocumentId + "' was already deleted in this session");
    }
    static _throwOtherDeferredCommandException(documentId, name, operation, previousOperation) {
        throwError("InvalidOperationException", "Can't " + operation + " attachment '" + name + "' of document '"
            + documentId + "', there is a deferred command registered to "
            + previousOperation + " an attachment with '" + name + "' name.");
    }
}
//# sourceMappingURL=DocumentSessionAttachmentsBase.js.map