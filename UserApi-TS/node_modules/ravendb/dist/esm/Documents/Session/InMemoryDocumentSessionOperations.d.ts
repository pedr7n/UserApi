import { EntityToJson } from "./EntityToJson.js";
import { IDisposable } from "../../Types/Contracts.js";
import { SessionInfo, ConcurrencyCheckMode, StoreOptions } from "./IDocumentSession.js";
import { IMetadataDictionary } from "./IMetadataDictionary.js";
import { ObjectTypeDescriptor, ServerResponse } from "../../Types/index.js";
import { SessionEventsEmitter } from "./SessionEvents.js";
import { RequestExecutor } from "../../Http/RequestExecutor.js";
import { IDocumentStore } from "../IDocumentStore.js";
import { ServerNode } from "../../Http/ServerNode.js";
import { DocumentsById, EntityInfo } from "./DocumentsById.js";
import { DocumentInfo } from "./DocumentInfo.js";
import { DocumentStoreBase } from "../DocumentStoreBase.js";
import { ICommandData, SaveChangesData } from "../Commands/CommandData.js";
import { GenerateEntityIdOnTheClient } from "../Identity/GenerateEntityIdOnTheClient.js";
import { DocumentType } from "../DocumentAbstractions.js";
import { DocumentsChanges } from "./DocumentsChanges.js";
import { EventEmitter } from "node:events";
import { IRavenObject } from "../../Types/IRavenObject.js";
import { GetDocumentsCommand } from "../Commands/GetDocumentsCommand.js";
import { DocumentConventions } from "../Conventions/DocumentConventions.js";
import { OperationExecutor } from "../Operations/OperationExecutor.js";
import { IndexBatchOptions, ReplicationBatchOptions } from "./IAdvancedSessionOperations.js";
import { ILazyOperation } from "./Operations/Lazy/ILazyOperation.js";
import { TransactionMode } from "./TransactionMode.js";
import { CounterTracking } from "./CounterInternalTypes.js";
import { DocumentStore } from "../DocumentStore.js";
import { SessionOptions } from "./SessionOptions.js";
import { ClusterTransactionOperationsBase } from "./ClusterTransactionOperationsBase.js";
import { BatchCommandResult } from "./Operations/BatchCommandResult.js";
import { Reference } from "../../Utility/Reference.js";
import { ForceRevisionStrategy } from "./ForceRevisionStrategy.js";
import { TimeSeriesRangeResult } from "../Operations/TimeSeries/TimeSeriesRangeResult.js";
import { TimeSeriesEntry } from "./TimeSeries/TimeSeriesEntry.js";
export declare abstract class InMemoryDocumentSessionOperations extends EventEmitter implements IDisposable, SessionEventsEmitter {
    protected _requestExecutor: RequestExecutor;
    private _operationExecutor;
    protected _pendingLazyOperations: ILazyOperation[];
    protected static _instancesCounter: number;
    private _hash;
    private _disposed;
    private readonly _id;
    get id(): string;
    protected _knownMissingIds: Set<string>;
    private _externalState;
    disableAtomicDocumentWritesInClusterWideTransaction: boolean;
    private _transactionMode;
    get externalState(): Map<string, object>;
    getCurrentSessionNode(): Promise<ServerNode>;
    documentsById: DocumentsById;
    /**
     * map holding the data required to manage Counters tracking for RavenDB's Unit of Work
     */
    get countersByDocId(): Map<string, CounterTracking>;
    private _countersByDocId;
    private _timeSeriesByDocId;
    get timeSeriesByDocId(): Map<string, Map<string, TimeSeriesRangeResult[]>>;
    readonly noTracking: boolean;
    idsForCreatingForcedRevisions: Map<string, ForceRevisionStrategy>;
    includedDocumentsById: Map<string, DocumentInfo>;
    /**
     * Translate between an CV and its associated entity
     */
    includeRevisionsByChangeVector: Map<string, DocumentInfo>;
    /**
     * Translate between an ID and its associated entity
     */
    includeRevisionsIdByDateTimeBefore: Map<string, Map<number, DocumentInfo>>;
    documentsByEntity: DocumentsByEntityHolder;
    deletedEntities: DeletedEntitiesHolder;
    protected _documentStore: DocumentStoreBase;
    private readonly _databaseName;
    private _saveChangesOptions;
    get databaseName(): string;
    get documentStore(): IDocumentStore;
    get requestExecutor(): RequestExecutor;
    get sessionInfo(): SessionInfo;
    get operations(): OperationExecutor;
    private _numberOfRequests;
    get numberOfRequests(): number;
    getNumberOfEntitiesInUnitOfWork(): number;
    get storeIdentifier(): string;
    get conventions(): DocumentConventions;
    maxNumberOfRequestsPerSession: number;
    useOptimisticConcurrency: boolean;
    protected _deferredCommands: ICommandData[];
    deferredCommandsMap: Map<string, ICommandData>;
    get deferredCommands(): ICommandData[];
    get deferredCommandsCount(): number;
    private readonly _generateEntityIdOnTheClient;
    get generateEntityIdOnTheClient(): GenerateEntityIdOnTheClient;
    private readonly _entityToJson;
    get entityToJson(): EntityToJson;
    protected _sessionInfo: SessionInfo;
    protected constructor(documentStore: DocumentStore, id: string, options: SessionOptions);
    protected abstract _generateId(entity: object): Promise<string>;
    /**
     * Gets the metadata for the specified entity.
     */
    getMetadataFor<T extends object>(instance: T): IMetadataDictionary;
    /**
     * Gets all counter names for the specified entity.
     */
    getCountersFor<T extends object>(instance: T): string[];
    /**
     * Gets all time series names for the specified entity.
     * @param instance Entity
     */
    getTimeSeriesFor<T extends object>(instance: T): string[];
    private _makeMetadataInstance;
    private _getDocumentInfo;
    protected _assertNoNonUniqueInstance(entity: object, id: string): void;
    /**
     * Gets the Change Vector for the specified entity.
     * If the entity is transient, it will load the change vector from the store
     * and associate the current state of the entity with the change vector from the server.
     */
    getChangeVectorFor<T extends object>(instance: T): string;
    getLastModifiedFor<T extends object>(instance: T): Date;
    /**
     * Returns whether a document with the specified id is loaded in the
     * current session
     */
    isLoaded(id: string): boolean;
    isLoadedOrDeleted(id: string): boolean;
    /**
     * Returns whether a document with the specified id is deleted
     * or known to be missing
     */
    isDeleted(id: string): boolean;
    /**
     * Gets the document id.
     */
    getDocumentId(instance: object): string;
    incrementRequestCount(): void;
    checkIfAllChangeVectorsAreAlreadyIncluded(changeVectors: string[]): boolean;
    checkIfRevisionByDateTimeBeforeAlreadyIncluded(id: string, dateTime: Date): boolean;
    checkIfIdAlreadyIncluded(ids: string[], includes: string[]): boolean;
    /**
     * Tracks the entity inside the unit of work
     */
    trackEntity<T extends object>(entityType: ObjectTypeDescriptor<T>, documentFound: DocumentInfo): T;
    trackEntity<T extends object>(entityType: ObjectTypeDescriptor<T>, id: string, document: object, metadata: object, noTracking: boolean): object;
    registerExternalLoadedIntoTheSession(info: DocumentInfo): void;
    private _deserializeFromTransformer;
    registerIncludes(includes: object): void;
    registerRevisionIncludes(revisionIncludes: any[]): void;
    registerMissingIncludes(results: object[], includes: object, includePaths: string[]): void;
    registerMissing(idOrIds: string | string[]): void;
    unregisterMissing(id: string): void;
    registerCounters(resultCounters: object, countersToInclude: {
        [key: string]: string[];
    }): void;
    registerCounters(resultCounters: object, ids: string[], countersToInclude: string[], gotAll: boolean): void;
    private _registerCountersWithIdsList;
    private _registerCountersWithCountersToIncludeObj;
    private _registerCountersInternal;
    private _registerCountersForDocument;
    private _setGotAllInCacheIfNeeded;
    private _setGotAllCountersForDocument;
    private _registerMissingCounters;
    registerTimeSeries(resultTimeSeries: Record<string, Record<string, ServerResponse<TimeSeriesRangeResult>[]>>): void;
    private static _addToCache;
    static addToCache(timeseries: string, from: Date, to: Date, fromRangeIndex: number, toRangeIndex: number, ranges: TimeSeriesRangeResult[], cache: Map<string, TimeSeriesRangeResult[]>, values: TimeSeriesEntry[]): void;
    private static _parseTimeSeriesRangeResult;
    private static _mergeRanges;
    private static _updateExistingRange;
    private _registerMissingCountersWithCountersToIncludeObj;
    private _registerMissingCountersWithIdsList;
    store<TEntity extends object>(entity: TEntity): Promise<void>;
    store<TEntity extends object>(entity: TEntity, id?: string): Promise<void>;
    store<TEntity extends object>(entity: TEntity, id?: string, documentType?: DocumentType<TEntity>): Promise<void>;
    store<TEntity extends object>(entity: TEntity, id?: string, options?: StoreOptions<TEntity>): Promise<void>;
    protected _generateDocumentKeysOnStore: boolean;
    private _storeInternal;
    protected _storeEntityInUnitOfWork(id: string, entity: object, changeVector: string, metadata: object, forceConcurrencyCheck: ConcurrencyCheckMode, documentType: DocumentType): void;
    protected _rememberEntityForDocumentIdGeneration(entity: object): void;
    prepareForSaveChanges(): SaveChangesData;
    validateClusterTransaction(result: SaveChangesData): void;
    protected _updateSessionAfterSaveChanges(result: BatchCommandResult): void;
    onBeforeConversionToDocumentInvoke(id: string, entity: object): void;
    onAfterConversionToDocumentInvoke(id: string, entity: object, document: Reference<object>): void;
    onBeforeConversionToEntityInvoke(id: string, type: DocumentType, document: Reference<object>): void;
    onAfterConversionToEntityInvoke(id: string, document: object, entity: object): void;
    private _prepareCompareExchangeEntities;
    protected abstract _hasClusterSession(): boolean;
    protected abstract _clearClusterSession(): void;
    abstract clusterSession: ClusterTransactionOperationsBase;
    private _newSaveChangesData;
    private _prepareForCreatingRevisionsFromIds;
    private _prepareForEntitiesDeletion;
    private _prepareForEntitiesPuts;
    protected _entityChanged(newObj: object, documentInfo: DocumentInfo, changes: {
        [id: string]: DocumentsChanges[];
    }): boolean;
    private static _throwInvalidModifiedDocumentWithDeferredCommand;
    private static _throwInvalidDeletedDocumentWithDeferredCommand;
    private static _updateMetadataModifications;
    delete(id: string): Promise<void>;
    delete(id: string, expectedChangeVector: string): Promise<void>;
    delete<TEntity extends IRavenObject>(entity: TEntity): Promise<void>;
    /**
     * Marks the specified entity for deletion. The entity will be deleted when SaveChanges is called.
     */
    private _deleteByEntity;
    /**
     * Marks the specified entity for deletion. The entity will be deleted when IDocumentSession.SaveChanges is called.
     * WARNING: This method will not call beforeDelete listener!
     */
    private _deleteById;
    /**
     * Defer commands to be executed on saveChanges()
     */
    defer(...commands: ICommandData[]): void;
    private _deferInternal;
    private _addCommand;
    protected _buildEntityDocInfoByIdHolder<T extends object>(entities: T[]): Map<string, [object, DocumentInfo]>;
    protected _refreshEntities(command: GetDocumentsCommand, idsEntitiesPairs: Map<string, [object, DocumentInfo]>): void;
    protected static _throwCouldNotRefreshDocument(msg: string): void;
    protected _refreshInternal<T extends object>(entity: T, cmd: object, documentInfo: DocumentInfo): void;
    /**
     * Returns all changes for the specified entity. Including name of the field/property that changed, its old and new value and change type.
     * @param entity Entity
     */
    whatChangedFor(entity: object): DocumentsChanges[];
    getTrackedEntities(): Map<string, EntityInfo>;
    /**
     * Gets a value indicating whether any of the entities tracked by the session has changes.
     */
    hasChanges(): boolean;
    /**
     * Evicts the specified entity from the session.
     * Remove the entity from the delete queue and stops tracking changes for this entity.
     */
    evict<T extends object>(entity: T): void;
    /**
     * Clears this instance.
     * Remove all entities from the delete queue and stops tracking changes for all entities.
     */
    clear(): void;
    /**
     * Determines whether the specified entity has changed.
     */
    hasChanged(entity: object): boolean;
    /**
     * SaveChanges will wait for the changes made to be replicates to `replicas` nodes
     */
    waitForReplicationAfterSaveChanges(): any;
    /**
     * SaveChanges will wait for the changes made to be replicates to `replicas` nodes
     */
    waitForReplicationAfterSaveChanges(opts: ReplicationBatchOptions): any;
    /**
     * SaveChanges will wait for the indexes to catch up with the saved changes
     */
    waitForIndexesAfterSaveChanges(): any;
    /**
     * SaveChanges will wait for the indexes to catch up with the saved changes
     */
    waitForIndexesAfterSaveChanges(opts: IndexBatchOptions): any;
    /**
     * Mark the entity as one that should be ignore for change tracking purposes,
     * it still takes part in the session, but is ignored for SaveChanges.
     */
    ignoreChangesFor(entity: object): void;
    whatChanged(): {
        [id: string]: DocumentsChanges[];
    };
    private _getAllEntitiesChanges;
    dispose(isDisposing?: boolean): void;
    get transactionMode(): TransactionMode;
    set transactionMode(value: TransactionMode);
    static validateTimeSeriesName(name: string): void;
    static validateIncrementalTimeSeriesName(name: string): void;
    assertNoIncludesInNonTrackingSession(): void;
    private static _throwNoDatabase;
}
export declare class DocumentsByEntityHolder implements Iterable<DocumentsByEntityEnumeratorResult> {
    private readonly _documentsByEntity;
    private _onBeforeStoreDocumentsByEntity;
    private _prepareEntitiesPuts;
    get size(): number;
    remove(entity: object): void;
    evict(entity: object): void;
    put(entity: object, documentInfo: DocumentInfo): void;
    private _createOnBeforeStoreDocumentsByEntityIfNeeded;
    clear(): void;
    get(entity: object): DocumentInfo;
    [Symbol.iterator](): Iterator<DocumentsByEntityEnumeratorResult>;
    prepareEntitiesPuts(): IDisposable;
}
export interface DocumentsByEntityEnumeratorResult {
    key: object;
    value: DocumentInfo;
    executeOnBeforeStore: boolean;
}
export declare class DeletedEntitiesHolder implements Iterable<DeletedEntitiesEnumeratorResult> {
    private readonly _deletedEntities;
    private _onBeforeDeletedEntities;
    private _prepareEntitiesDeletes;
    isEmpty(): boolean;
    get size(): number;
    add(entity: object): void;
    remove(entity: object): void;
    evict(entity: object): void;
    contains(entity: object): boolean;
    clear(): void;
    [Symbol.iterator](): Iterator<DeletedEntitiesEnumeratorResult>;
    prepareEntitiesDeletes(): IDisposable;
}
export interface DeletedEntitiesEnumeratorResult {
    entity: object;
    executeOnBeforeDelete: boolean;
}
export interface EntityInfoAndResult {
    entity: object;
    info: DocumentInfo;
    result: object;
}
//# sourceMappingURL=InMemoryDocumentSessionOperations.d.ts.map