import { EntityToJson } from "./EntityToJson.js";
import { SessionInfo } from "./IDocumentSession.js";
import { SessionBeforeStoreEventArgs, SessionBeforeDeleteEventArgs, BeforeConversionToDocumentEventArgs, AfterConversionToDocumentEventArgs, BeforeConversionToEntityEventArgs, AfterConversionToEntityEventArgs } from "./SessionEvents.js";
import { throwError } from "../../Exceptions/index.js";
import { DocumentsById, EntityInfo } from "./DocumentsById.js";
import { DocumentInfo } from "./DocumentInfo.js";
import { DeleteCommandData, SaveChangesData, PutCommandDataWithJson } from "../Commands/CommandData.js";
import { GenerateEntityIdOnTheClient } from "../Identity/GenerateEntityIdOnTheClient.js";
import { tryGetConflict } from "../../Mapping/Json/index.js";
import { CONSTANTS, HEADERS } from "../../Constants.js";
import { DateUtil } from "../../Utility/DateUtil.js";
import { ObjectUtil } from "../../Utility/ObjectUtil.js";
import { IncludesUtil } from "./IncludesUtil.js";
import { TypeUtil } from "../../Utility/TypeUtil.js";
import { IdTypeAndName } from "../IdTypeAndName.js";
import { DocumentsChanges } from "./DocumentsChanges.js";
import { EventEmitter } from "node:events";
import { JsonOperation } from "../../Mapping/JsonOperation.js";
import { createMetadataDictionary } from "../../Mapping/MetadataAsDictionary.js";
import { CaseInsensitiveKeysMap } from "../../Primitives/CaseInsensitiveKeysMap.js";
import { CaseInsensitiveStringSet } from "../../Primitives/CaseInsensitiveStringSet.js";
import { SessionOperationExecutor } from "../Operations/SessionOperationExecutor.js";
import { StringUtil } from "../../Utility/StringUtil.js";
import { ForceRevisionCommandData } from "../Commands/Batches/ForceRevisionCommandData.js";
import { TimeSeriesRangeResult } from "../Operations/TimeSeries/TimeSeriesRangeResult.js";
import { DatesComparator, leftDate, rightDate } from "../../Primitives/DatesComparator.js";
import { reviveTimeSeriesRangeResult } from "../Operations/TimeSeries/GetTimeSeriesOperation.js";
import { forBehavior } from "../Commands/Batches/ShardedBatchOptions.js";
export class InMemoryDocumentSessionOperations extends EventEmitter {
    _requestExecutor;
    _operationExecutor;
    _pendingLazyOperations = [];
    static _instancesCounter = 0;
    _hash = ++InMemoryDocumentSessionOperations._instancesCounter;
    _disposed;
    _id;
    get id() {
        return this._id;
    }
    _knownMissingIds = CaseInsensitiveStringSet.create();
    _externalState;
    disableAtomicDocumentWritesInClusterWideTransaction;
    _transactionMode;
    get externalState() {
        if (!this._externalState) {
            this._externalState = new Map();
        }
        return this._externalState;
    }
    getCurrentSessionNode() {
        return this.sessionInfo.getCurrentSessionNode(this._requestExecutor);
    }
    documentsById = new DocumentsById();
    /**
     * map holding the data required to manage Counters tracking for RavenDB's Unit of Work
     */
    get countersByDocId() {
        if (!this._countersByDocId) {
            this._countersByDocId = CaseInsensitiveKeysMap.create();
        }
        return this._countersByDocId;
    }
    _countersByDocId;
    _timeSeriesByDocId;
    get timeSeriesByDocId() {
        if (!this._timeSeriesByDocId) {
            this._timeSeriesByDocId = CaseInsensitiveKeysMap.create();
        }
        return this._timeSeriesByDocId;
    }
    noTracking;
    idsForCreatingForcedRevisions = CaseInsensitiveKeysMap.create();
    includedDocumentsById = CaseInsensitiveKeysMap.create();
    /**
     * Translate between an CV and its associated entity
     */
    includeRevisionsByChangeVector = CaseInsensitiveKeysMap.create();
    /**
     * Translate between an ID and its associated entity
     */
    includeRevisionsIdByDateTimeBefore = CaseInsensitiveKeysMap.create();
    documentsByEntity = new DocumentsByEntityHolder();
    deletedEntities = new DeletedEntitiesHolder();
    _documentStore;
    _databaseName;
    _saveChangesOptions;
    get databaseName() {
        return this._databaseName;
    }
    get documentStore() {
        return this._documentStore;
    }
    get requestExecutor() {
        return this._requestExecutor;
    }
    get sessionInfo() {
        return this._sessionInfo;
    }
    get operations() {
        if (!this._operationExecutor) {
            this._operationExecutor = new SessionOperationExecutor(this);
        }
        return this._operationExecutor;
    }
    _numberOfRequests = 0;
    get numberOfRequests() {
        return this._numberOfRequests;
    }
    getNumberOfEntitiesInUnitOfWork() {
        return this.documentsByEntity.size;
    }
    get storeIdentifier() {
        return `${this._documentStore.identifier};${this._databaseName}`;
    }
    get conventions() {
        return this._requestExecutor.conventions;
    }
    maxNumberOfRequestsPerSession;
    useOptimisticConcurrency;
    _deferredCommands = [];
    // keys are produced with IdTypeAndName.keyFor() method
    deferredCommandsMap = new Map();
    get deferredCommands() {
        return this._deferredCommands;
    }
    get deferredCommandsCount() {
        return this._deferredCommands.length;
    }
    _generateEntityIdOnTheClient;
    get generateEntityIdOnTheClient() {
        return this._generateEntityIdOnTheClient;
    }
    _entityToJson;
    get entityToJson() {
        return this._entityToJson;
    }
    _sessionInfo;
    constructor(documentStore, id, options) {
        super();
        this._id = id;
        this._databaseName = options.database || documentStore.database;
        if (StringUtil.isNullOrWhitespace(this._databaseName)) {
            InMemoryDocumentSessionOperations._throwNoDatabase();
        }
        this._documentStore = documentStore;
        this._requestExecutor =
            options.requestExecutor || documentStore.getRequestExecutor(this._databaseName);
        this.noTracking = options.noTracking;
        this.useOptimisticConcurrency = this._requestExecutor.conventions.isUseOptimisticConcurrency();
        this.maxNumberOfRequestsPerSession = this._requestExecutor.conventions.maxNumberOfRequestsPerSession;
        this._generateEntityIdOnTheClient =
            new GenerateEntityIdOnTheClient(this._requestExecutor.conventions, (obj) => this._generateId(obj));
        this._entityToJson = new EntityToJson(this);
        this._sessionInfo = new SessionInfo(this, options, documentStore);
        this._transactionMode = options.transactionMode;
        this.disableAtomicDocumentWritesInClusterWideTransaction = options.disableAtomicDocumentWritesInClusterWideTransaction;
        const shardedBatchBehavior = options.shardedBatchBehavior ?? this.requestExecutor.conventions.sharding.batchBehavior;
        const shardedBatchOptions = forBehavior(shardedBatchBehavior);
        if (shardedBatchOptions) {
            this._saveChangesOptions = {
                shardedOptions: shardedBatchOptions,
                replicationOptions: null,
                indexOptions: null
            };
        }
    }
    /**
     * Gets the metadata for the specified entity.
     */
    getMetadataFor(instance) {
        if (!instance) {
            throwError("InvalidOperationException", "Instance cannot be null or undefined.");
        }
        const documentInfo = this._getDocumentInfo(instance);
        return this._makeMetadataInstance(documentInfo);
    }
    /**
     * Gets all counter names for the specified entity.
     */
    getCountersFor(instance) {
        if (!instance) {
            throwError("InvalidArgumentException", "Instance cannot be null.");
        }
        const documentInfo = this._getDocumentInfo(instance);
        const countersArray = documentInfo.metadata[CONSTANTS.Documents.Metadata.COUNTERS];
        if (!countersArray) {
            return null;
        }
        return countersArray;
    }
    /**
     * Gets all time series names for the specified entity.
     * @param instance Entity
     */
    getTimeSeriesFor(instance) {
        if (!instance) {
            throwError("InvalidArgumentException", "Instance cannot be null");
        }
        const documentInfo = this._getDocumentInfo(instance);
        return documentInfo.metadata[CONSTANTS.Documents.Metadata.TIME_SERIES] || [];
    }
    _makeMetadataInstance(docInfo) {
        const metadataInstance = docInfo.metadataInstance;
        if (metadataInstance) {
            return metadataInstance;
        }
        const metadataAsJson = docInfo.metadata;
        const metadata = createMetadataDictionary({ raw: metadataAsJson });
        docInfo.entity[CONSTANTS.Documents.Metadata.KEY] = docInfo.metadataInstance = metadata;
        return metadata;
    }
    _getDocumentInfo(instance) {
        const documentInfo = this.documentsByEntity.get(instance);
        if (documentInfo) {
            return documentInfo;
        }
        let idRef;
        if (!this._generateEntityIdOnTheClient.tryGetIdFromInstance(instance, (_idRef) => idRef = _idRef)) {
            throwError("InvalidOperationException", "Could not find the document id for " + instance);
        }
        this._assertNoNonUniqueInstance(instance, idRef);
        throwError("InvalidArgumentException", "Document " + idRef + " doesn't exist in the session");
    }
    _assertNoNonUniqueInstance(entity, id) {
        if (!id
            || id.at(-1) === "|"
            || id.at(-1) === this.conventions.identityPartsSeparator) {
            return;
        }
        const info = this.documentsById.getValue(id);
        if (!info || info.entity === entity) {
            return;
        }
        throwError("NonUniqueObjectException", "Attempted to associate a different object with id '" + id + "'.");
    }
    /**
     * Gets the Change Vector for the specified entity.
     * If the entity is transient, it will load the change vector from the store
     * and associate the current state of the entity with the change vector from the server.
     */
    getChangeVectorFor(instance) {
        if (!instance) {
            throwError("InvalidArgumentException", "Instance cannot be null or undefined.");
        }
        const documentInfo = this._getDocumentInfo(instance);
        const changeVector = documentInfo.metadata[CONSTANTS.Documents.Metadata.CHANGE_VECTOR];
        if (changeVector) {
            return changeVector.toString();
        }
        return null;
    }
    getLastModifiedFor(instance) {
        if (!instance) {
            throwError("InvalidArgumentException", "Instance cannot be null or undefined.");
        }
        const documentInfo = this._getDocumentInfo(instance);
        const lastModified = documentInfo.metadata["@last-modified"];
        return DateUtil.utc.parse(lastModified);
    }
    /**
     * Returns whether a document with the specified id is loaded in the
     * current session
     */
    isLoaded(id) {
        return this.isLoadedOrDeleted(id);
    }
    isLoadedOrDeleted(id) {
        const documentInfo = this.documentsById.getValue(id);
        return !!(documentInfo && (documentInfo.document || documentInfo.entity))
            || this.isDeleted(id)
            || this.includedDocumentsById.has(id);
    }
    /**
     * Returns whether a document with the specified id is deleted
     * or known to be missing
     */
    isDeleted(id) {
        return this._knownMissingIds.has(id);
    }
    /**
     * Gets the document id.
     */
    getDocumentId(instance) {
        if (!instance) {
            return null;
        }
        const value = this.documentsByEntity.get(instance);
        return value ? value.id : null;
    }
    incrementRequestCount() {
        if (++this._numberOfRequests > this.maxNumberOfRequestsPerSession) {
            throwError("InvalidOperationException", `The maximum number of requests (${this.maxNumberOfRequestsPerSession}) allowed for this session has been reached.` +
                "Raven limits the number of remote calls that a session is allowed to make as an early warning system. Sessions are expected to be short lived, and " +
                "Raven provides facilities like load(string[] keys) to load multiple documents at once and batch saves (call SaveChanges() only once)." +
                "You can increase the limit by setting DocumentConvention.MaxNumberOfRequestsPerSession or MaxNumberOfRequestsPerSession, but it is" +
                "advisable that you'll look into reducing the number of remote calls first, since that will speed up your application significantly and result in a" +
                "more responsive application.");
        }
    }
    checkIfAllChangeVectorsAreAlreadyIncluded(changeVectors) {
        if (!this.includeRevisionsByChangeVector) {
            return false;
        }
        for (const cv of changeVectors) {
            if (!this.includeRevisionsByChangeVector.has(cv)) {
                return false;
            }
        }
        return true;
    }
    checkIfRevisionByDateTimeBeforeAlreadyIncluded(id, dateTime) {
        if (!this.includeRevisionsIdByDateTimeBefore) {
            return false;
        }
        const dictionaryDateTimeToDocument = this.includeRevisionsIdByDateTimeBefore.get(id);
        return dictionaryDateTimeToDocument && dictionaryDateTimeToDocument.has(dateTime.getTime());
    }
    checkIfIdAlreadyIncluded(ids, includes) {
        for (const id of ids) {
            if (this._knownMissingIds.has(id)) {
                continue;
            }
            // Check if document was already loaded, the check if we've received it through include
            let documentInfo = this.documentsById.getValue(id);
            if (!documentInfo) {
                documentInfo = this.includedDocumentsById.get(id);
                if (!documentInfo) {
                    return false;
                }
            }
            if (!documentInfo.entity && !documentInfo.document) {
                return false;
            }
            if (!includes) {
                continue;
            }
            for (const include of includes) {
                let hasAll = true;
                IncludesUtil.include(documentInfo.document, include, (includeId) => {
                    hasAll = hasAll && this.isLoaded(includeId);
                });
                if (!hasAll) {
                    return false;
                }
            }
        }
        return true;
    }
    trackEntity(entityType, idOrDocumentInfo, document, metadata, noTracking) {
        let id;
        if (TypeUtil.isObject(idOrDocumentInfo)) {
            const info = idOrDocumentInfo;
            return this.trackEntity(entityType, info.id, info.document, info.metadata, this.noTracking);
        }
        else {
            id = idOrDocumentInfo;
        }
        // if noTracking is session-wide then we want to override the passed argument
        noTracking = this.noTracking || noTracking;
        if (!id) {
            return this._deserializeFromTransformer(entityType, null, document, false);
        }
        let docInfo = this.documentsById.getValue(id);
        if (docInfo) {
            // the local instance may have been changed, we adhere to the current Unit of Work
            // instance, and return that, ignoring anything new.
            if (!docInfo.entity) {
                docInfo.entity = this.entityToJson.convertToEntity(entityType, id, document, !noTracking);
                this._makeMetadataInstance(docInfo);
            }
            if (!noTracking) {
                this.includedDocumentsById.delete(id);
                this.documentsByEntity.put(docInfo.entity, docInfo);
            }
            this.onAfterConversionToEntityInvoke(id, docInfo.document, docInfo.entity);
            return docInfo.entity;
        }
        docInfo = this.includedDocumentsById.get(id);
        if (docInfo) {
            if (!docInfo.entity) {
                docInfo.entity = this.entityToJson.convertToEntity(entityType, id, document, !noTracking);
                this._makeMetadataInstance(docInfo);
            }
            if (!noTracking) {
                this.includedDocumentsById.delete(id);
                this.documentsById.add(docInfo);
                this.documentsByEntity.put(docInfo.entity, docInfo);
            }
            this.onAfterConversionToEntityInvoke(id, docInfo.document, docInfo.entity);
            return docInfo.entity;
        }
        const entity = this.entityToJson.convertToEntity(entityType, id, document, !noTracking);
        const changeVector = metadata[CONSTANTS.Documents.Metadata.CHANGE_VECTOR];
        if (!changeVector) {
            throwError("InvalidOperationException", "Document " + id + " must have Change Vector.");
        }
        if (!noTracking) {
            const newDocumentInfo = new DocumentInfo();
            newDocumentInfo.id = id;
            newDocumentInfo.document = document;
            newDocumentInfo.metadata = metadata;
            newDocumentInfo.entity = entity;
            newDocumentInfo.changeVector = changeVector;
            this.documentsById.add(newDocumentInfo);
            this.documentsByEntity.put(entity, newDocumentInfo);
            this._makeMetadataInstance(newDocumentInfo);
        }
        this.onAfterConversionToEntityInvoke(id, document, entity);
        return entity;
    }
    registerExternalLoadedIntoTheSession(info) {
        if (this.noTracking) {
            return;
        }
        const existing = this.documentsById.getValue(info.id);
        if (existing) {
            if (existing.entity === info.entity) {
                return;
            }
            throwError("InvalidOperationException", "The document " + info.id + " is already in the session with a different entity instance.");
        }
        const existingEntity = this.documentsByEntity.get(info.entity);
        if (existingEntity) {
            if (StringUtil.equalsIgnoreCase(existingEntity.id, info.id)) {
                return;
            }
            throwError("InvalidOperationException", "Attempted to load an entity with id "
                + info.id
                + ", but the entity instance already exists in the session with id: " + existing.id);
        }
        this.documentsByEntity.put(info.entity, info);
        this.documentsById.add(info);
        this.includedDocumentsById.delete(info.id);
    }
    _deserializeFromTransformer(clazz, id, document, trackEntity) {
        const entity = this.entityToJson.convertToEntity(clazz, id, document, trackEntity);
        this.onAfterConversionToEntityInvoke(id, document, entity);
        return entity;
    }
    registerIncludes(includes) {
        if (this.noTracking) {
            return;
        }
        if (!includes) {
            return;
        }
        for (const fieldName of Object.keys(includes)) {
            const fieldValue = includes[fieldName];
            if (TypeUtil.isNullOrUndefined(fieldValue)) {
                continue;
            }
            const newDocumentInfo = DocumentInfo.getNewDocumentInfo(fieldValue);
            if (tryGetConflict(newDocumentInfo.metadata)) {
                continue;
            }
            this.includedDocumentsById.set(newDocumentInfo.id, newDocumentInfo);
        }
    }
    registerRevisionIncludes(revisionIncludes) {
        if (this.noTracking) {
            return;
        }
        if (!revisionIncludes) {
            return;
        }
        if (!this.includeRevisionsByChangeVector) {
            this.includeRevisionsByChangeVector = CaseInsensitiveKeysMap.create();
        }
        if (!this.includeRevisionsIdByDateTimeBefore) {
            this.includeRevisionsIdByDateTimeBefore = CaseInsensitiveKeysMap.create();
        }
        for (const obj of revisionIncludes) {
            if (!obj) {
                continue;
            }
            const json = obj;
            const id = json.Id;
            const changeVector = json.ChangeVector;
            const beforeAsText = json.Before;
            const dateTime = beforeAsText ? DateUtil.utc.parse(beforeAsText) : null;
            const revision = json.Revision;
            this.includeRevisionsByChangeVector.set(changeVector, DocumentInfo.getNewDocumentInfo(revision));
            if (dateTime && !StringUtil.isNullOrWhitespace(id)) {
                const map = new Map();
                this.includeRevisionsIdByDateTimeBefore.set(id, map);
                const documentInfo = new DocumentInfo();
                documentInfo.document = revision;
                map.set(dateTime.getTime(), documentInfo);
            }
        }
    }
    registerMissingIncludes(results, includes, includePaths) {
        if (this.noTracking) {
            return;
        }
        if (!includePaths || !includePaths.length) {
            return;
        }
        for (const result of results) {
            for (const include of includePaths) {
                if (include === CONSTANTS.Documents.Indexing.Fields.DOCUMENT_ID_FIELD_NAME) {
                    continue;
                }
                IncludesUtil.include(result, include, id => {
                    if (!id) {
                        return;
                    }
                    if (this.isLoaded(id)) {
                        return;
                    }
                    const document = includes[id];
                    if (document) {
                        const metadata = document.get(CONSTANTS.Documents.Metadata.KEY);
                        if (tryGetConflict(metadata)) {
                            return;
                        }
                    }
                    this.registerMissing(id);
                });
            }
        }
    }
    registerMissing(idOrIds) {
        if (this.noTracking) {
            return;
        }
        if (TypeUtil.isArray(idOrIds)) {
            for (const id of idOrIds) {
                this._knownMissingIds.add(id);
            }
        }
        else {
            this._knownMissingIds.add(idOrIds);
        }
    }
    unregisterMissing(id) {
        this._knownMissingIds.delete(id);
    }
    registerCounters(resultCounters, idsOrCountersToInclude, countersToInclude, gotAll) {
        if (Array.isArray(idsOrCountersToInclude)) {
            this._registerCountersWithIdsList(resultCounters, idsOrCountersToInclude, countersToInclude, gotAll);
        }
        else {
            this._registerCountersWithCountersToIncludeObj(resultCounters, idsOrCountersToInclude);
        }
    }
    _registerCountersWithIdsList(resultCounters, ids, countersToInclude, gotAll) {
        if (this.noTracking) {
            return;
        }
        if (!resultCounters || Object.keys(resultCounters).length === 0) {
            if (gotAll) {
                for (const id of ids) {
                    this._setGotAllCountersForDocument(id);
                }
                return;
            }
        }
        else {
            this._registerCountersInternal(resultCounters, null, false, gotAll);
        }
        this._registerMissingCounters(ids, countersToInclude);
    }
    _registerCountersWithCountersToIncludeObj(resultCounters, countersToInclude) {
        if (this.noTracking) {
            return;
        }
        if (!resultCounters || Object.keys(resultCounters).length === 0) {
            this._setGotAllInCacheIfNeeded(countersToInclude);
        }
        else {
            this._registerCountersInternal(resultCounters, countersToInclude, true, false);
        }
        this._registerMissingCounters(countersToInclude);
    }
    _registerCountersInternal(resultCounters, countersToInclude, fromQueryResult, gotAll) {
        for (const [field, value] of Object.entries(resultCounters)) {
            if (!value) {
                continue;
            }
            let counters = [];
            if (fromQueryResult) {
                counters = countersToInclude[field];
                gotAll = counters && counters.length === 0;
            }
            if (value.length === 0 && !gotAll) {
                const cache = this.countersByDocId.get(field);
                if (!cache) {
                    continue;
                }
                for (const counter of counters) {
                    cache.data.delete(counter);
                }
                this._countersByDocId.set(field, cache);
                continue;
            }
            this._registerCountersForDocument(field, gotAll, value, countersToInclude);
        }
    }
    _registerCountersForDocument(id, gotAll, counters, countersToInclude) {
        let cache = this.countersByDocId.get(id);
        if (!cache) {
            cache = { gotAll, data: CaseInsensitiveKeysMap.create() };
        }
        const deletedCounters = cache.data.size === 0
            ? new Set()
            : (countersToInclude[id].length === 0 ? new Set(cache.data.keys()) : new Set(countersToInclude[id]));
        for (const counterJson of counters) {
            if (!counterJson) {
                continue;
            }
            const counterName = counterJson["counterName"];
            const totalValue = counterJson["totalValue"];
            if (counterName && totalValue) {
                cache.data.set(counterName, totalValue);
                deletedCounters.delete(counterName);
            }
        }
        if (deletedCounters.size > 0) {
            for (const name of deletedCounters) {
                cache.data.delete(name);
            }
        }
        cache.gotAll = gotAll;
        this._countersByDocId.set(id, cache);
    }
    _setGotAllInCacheIfNeeded(countersToInclude) {
        for (const [key, value] of Object.entries(countersToInclude)) {
            if (value.length > 0) {
                continue;
            }
            this._setGotAllCountersForDocument(key);
        }
    }
    _setGotAllCountersForDocument(id) {
        let cache = this.countersByDocId.get(id);
        if (!cache) {
            cache = { gotAll: false, data: CaseInsensitiveKeysMap.create() };
        }
        cache.gotAll = true;
        this._countersByDocId.set(id, cache);
    }
    _registerMissingCounters(idsOrCountersToInclude, countersToInclude) {
        if (Array.isArray(idsOrCountersToInclude)) {
            this._registerMissingCountersWithIdsList(idsOrCountersToInclude, countersToInclude);
        }
        else {
            this._registerMissingCountersWithCountersToIncludeObj(idsOrCountersToInclude);
        }
    }
    registerTimeSeries(resultTimeSeries) {
        if (this.noTracking || !resultTimeSeries) {
            return;
        }
        for (const [id, perDocTs] of Object.entries(resultTimeSeries)) {
            if (!perDocTs) {
                continue;
            }
            let cache = this.timeSeriesByDocId.get(id);
            if (!cache) {
                cache = CaseInsensitiveKeysMap.create();
                this.timeSeriesByDocId.set(id, cache);
            }
            if (!TypeUtil.isObject(perDocTs)) {
                throwError("InvalidOperationException", "Unable to read time series range results on document: '" + id + "'.");
            }
            for (const [name, perNameTs] of Object.entries(perDocTs)) {
                if (!perNameTs) {
                    continue;
                }
                if (!TypeUtil.isArray(perNameTs)) {
                    throwError("InvalidOperationException", "Unable to read time series range results on document: '" + id + "', time series: '" + name + "'.");
                }
                for (const range of perNameTs) {
                    const newRange = InMemoryDocumentSessionOperations._parseTimeSeriesRangeResult(range, id, name);
                    InMemoryDocumentSessionOperations._addToCache(cache, newRange, name);
                }
            }
        }
    }
    static _addToCache(cache, newRange, name) {
        const localRanges = cache.get(name);
        if (!localRanges || !localRanges.length) {
            // no local ranges in cache for this series
            cache.set(name, [newRange]);
            return;
        }
        if (DatesComparator.compare(leftDate(localRanges[0].from), rightDate(newRange.to)) > 0
            || DatesComparator.compare(rightDate(localRanges.at(-1).to), leftDate(newRange.from)) < 0) {
            // the entire range [from, to] is out of cache bounds
            const index = DatesComparator.compare(leftDate(localRanges[0].from), rightDate(newRange.to)) > 0 ? 0 : localRanges.length;
            localRanges.splice(index, 0, newRange);
            return;
        }
        let toRangeIndex;
        let fromRangeIndex = -1;
        let rangeAlreadyInCache = false;
        for (toRangeIndex = 0; toRangeIndex < localRanges.length; toRangeIndex++) {
            if (DatesComparator.compare(leftDate(localRanges[toRangeIndex].from), leftDate(newRange.from)) <= 0) {
                if (DatesComparator.compare(rightDate(localRanges[toRangeIndex].to), rightDate(newRange.to)) >= 0) {
                    rangeAlreadyInCache = true;
                    break;
                }
                fromRangeIndex = toRangeIndex;
                continue;
            }
            if (DatesComparator.compare(rightDate(localRanges[toRangeIndex].to), rightDate(newRange.to)) >= 0) {
                break;
            }
        }
        if (rangeAlreadyInCache) {
            InMemoryDocumentSessionOperations._updateExistingRange(localRanges[toRangeIndex], newRange);
            return;
        }
        const mergedValues = InMemoryDocumentSessionOperations._mergeRanges(fromRangeIndex, toRangeIndex, localRanges, newRange);
        InMemoryDocumentSessionOperations.addToCache(name, newRange.from, newRange.to, fromRangeIndex, toRangeIndex, localRanges, cache, mergedValues);
    }
    static addToCache(timeseries, from, to, fromRangeIndex, toRangeIndex, ranges, cache, values) {
        if (fromRangeIndex === -1) {
            // didn't find a 'fromRange' => all ranges in cache start after 'from'
            if (toRangeIndex === ranges.length) {
                // the requested range [from, to] contains all the ranges that are in cache
                // e.g. if cache is : [[2,3], [4,5], [7, 10]]
                // and the requested range is : [1, 15]
                // after this action cache will be : [[1, 15]]
                const timeSeriesRangeResult = new TimeSeriesRangeResult();
                timeSeriesRangeResult.from = from;
                timeSeriesRangeResult.to = to;
                timeSeriesRangeResult.entries = values;
                const result = [];
                result.push(timeSeriesRangeResult);
                cache.set(timeseries, result);
                return;
            }
            if (DatesComparator.compare(leftDate(ranges[toRangeIndex].from), rightDate(to)) > 0) {
                // requested range ends before 'toRange' starts
                // remove all ranges that come before 'toRange' from cache
                // add the new range at the beginning of the list
                // e.g. if cache is : [[2,3], [4,5], [7,10]]
                // and the requested range is : [1,6]
                // after this action cache will be : [[1,6], [7,10]]
                ranges.splice(0, toRangeIndex);
                const timeSeriesRangeResult = new TimeSeriesRangeResult();
                timeSeriesRangeResult.from = from;
                timeSeriesRangeResult.to = to;
                timeSeriesRangeResult.entries = values;
                ranges.splice(0, 0, timeSeriesRangeResult);
                return;
            }
            // the requested range ends inside 'toRange'
            // merge the result from server into 'toRange'
            // remove all ranges that come before 'toRange' from cache
            // e.g. if cache is : [[2,3], [4,5], [7,10]]
            // and the requested range is : [1,8]
            // after this action cache will be : [[1,10]]
            ranges[toRangeIndex].from = from;
            ranges[toRangeIndex].entries = values;
            ranges.splice(0, toRangeIndex);
            return;
        }
        // found a 'fromRange'
        if (toRangeIndex === ranges.length) {
            // didn't find a 'toRange' => all the ranges in cache end before 'to'
            if (DatesComparator.compare(rightDate(ranges[fromRangeIndex].to), leftDate(from)) < 0) {
                // requested range starts after 'fromRange' ends,
                // so it needs to be placed right after it
                // remove all the ranges that come after 'fromRange' from cache
                // add the merged values as a new range at the end of the list
                // e.g. if cache is : [[2,3], [5,6], [7,10]]
                // and the requested range is : [4,12]
                // then 'fromRange' is : [2,3]
                // after this action cache will be : [[2,3], [4,12]]
                ranges.splice(fromRangeIndex + 1, ranges.length - fromRangeIndex - 1);
                const timeSeriesRangeResult = new TimeSeriesRangeResult();
                timeSeriesRangeResult.from = from;
                timeSeriesRangeResult.to = to;
                timeSeriesRangeResult.entries = values;
                ranges.push(timeSeriesRangeResult);
                return;
            }
            // the requested range starts inside 'fromRange'
            // merge result into 'fromRange'
            // remove all the ranges from cache that come after 'fromRange'
            // e.g. if cache is : [[2,3], [4,6], [7,10]]
            // and the requested range is : [5,12]
            // then 'fromRange' is [4,6]
            // after this action cache will be : [[2,3], [4,12]]
            ranges[fromRangeIndex].to = to;
            ranges[fromRangeIndex].entries = values;
            ranges.splice(fromRangeIndex + 1, ranges.length - fromRangeIndex - 1);
            return;
        }
        // found both 'fromRange' and 'toRange'
        // the requested range is inside cache bounds
        if (DatesComparator.compare(rightDate(ranges[fromRangeIndex].to), leftDate(from)) < 0) {
            // requested range starts after 'fromRange' ends
            if (DatesComparator.compare(leftDate(ranges[toRangeIndex].from), rightDate(to)) > 0) {
                // requested range ends before 'toRange' starts
                // remove all ranges in between 'fromRange' and 'toRange'
                // place new range in between 'fromRange' and 'toRange'
                // e.g. if cache is : [[2,3], [5,6], [7,8], [10,12]]
                // and the requested range is : [4,9]
                // then 'fromRange' is [2,3] and 'toRange' is [10,12]
                // after this action cache will be : [[2,3], [4,9], [10,12]]
                ranges.splice(fromRangeIndex + 1, toRangeIndex - fromRangeIndex - 1);
                const timeSeriesRangeResult = new TimeSeriesRangeResult();
                timeSeriesRangeResult.from = from;
                timeSeriesRangeResult.to = to;
                timeSeriesRangeResult.entries = values;
                ranges.splice(fromRangeIndex + 1, 0, timeSeriesRangeResult);
                return;
            }
            // requested range ends inside 'toRange'
            // merge the new range into 'toRange'
            // remove all ranges in between 'fromRange' and 'toRange'
            // e.g. if cache is : [[2,3], [5,6], [7,10]]
            // and the requested range is : [4,9]
            // then 'fromRange' is [2,3] and 'toRange' is [7,10]
            // after this action cache will be : [[2,3], [4,10]]
            ranges.splice(fromRangeIndex + 1, toRangeIndex - fromRangeIndex - 1);
            ranges[toRangeIndex].from = from;
            ranges[toRangeIndex].entries = values;
            return;
        }
        // the requested range starts inside 'fromRange'
        if (DatesComparator.compare(leftDate(ranges[toRangeIndex].from), rightDate(to)) > 0) {
            // requested range ends before 'toRange' starts
            // remove all ranges in between 'fromRange' and 'toRange'
            // merge new range into 'fromRange'
            // e.g. if cache is : [[2,4], [5,6], [8,10]]
            // and the requested range is : [3,7]
            // then 'fromRange' is [2,4] and 'toRange' is [8,10]
            // after this action cache will be : [[2,7], [8,10]]
            ranges[fromRangeIndex].to = to;
            ranges[fromRangeIndex].entries = values;
            ranges.splice(fromRangeIndex + 1, toRangeIndex - fromRangeIndex - 1);
            return;
        }
        // the requested range starts inside 'fromRange'
        // and ends inside 'toRange'
        // merge all ranges in between 'fromRange' and 'toRange'
        // into a single range [fromRange.From, toRange.To]
        // e.g. if cache is : [[2,4], [5,6], [8,10]]
        // and the requested range is : [3,9]
        // then 'fromRange' is [2,4] and 'toRange' is [8,10]
        // after this action cache will be : [[2,10]]
        ranges[fromRangeIndex].to = ranges[toRangeIndex].to;
        ranges[fromRangeIndex].entries = values;
        ranges.splice(fromRangeIndex + 1, toRangeIndex - fromRangeIndex);
    }
    static _parseTimeSeriesRangeResult(json, id, databaseName) {
        return reviveTimeSeriesRangeResult(json);
    }
    static _mergeRanges(fromRangeIndex, toRangeIndex, localRanges, newRange) {
        const mergedValues = [];
        if (fromRangeIndex !== -1 && localRanges[fromRangeIndex].to.getTime() >= newRange.from.getTime()) {
            for (const val of localRanges[fromRangeIndex].entries) {
                if (val.timestamp.getTime() >= newRange.from.getTime()) {
                    break;
                }
                mergedValues.push(val);
            }
        }
        mergedValues.push(...newRange.entries);
        if (toRangeIndex < localRanges.length
            && DatesComparator.compare(leftDate(localRanges[toRangeIndex].from), rightDate(newRange.to)) <= 0) {
            for (const val of localRanges[toRangeIndex].entries) {
                if (val.timestamp.getTime() <= newRange.to.getTime()) {
                    continue;
                }
                mergedValues.push(val);
            }
        }
        return mergedValues;
    }
    static _updateExistingRange(localRange, newRange) {
        const newValues = [];
        let index;
        for (index = 0; index < localRange.entries.length; index++) {
            if (localRange.entries[index].timestamp.getTime() >= newRange.from.getTime()) {
                break;
            }
            newValues.push(localRange.entries[index]);
        }
        newValues.push(...newRange.entries);
        for (const item of localRange.entries) {
            if (item.timestamp.getTime() <= newRange.to.getTime()) {
                continue;
            }
            newValues.push(item);
        }
        localRange.entries = newValues;
    }
    _registerMissingCountersWithCountersToIncludeObj(countersToInclude) {
        if (!countersToInclude) {
            return;
        }
        for (const [key, value] of Object.entries(countersToInclude)) {
            let cache = this.countersByDocId.get(key);
            if (!cache) {
                cache = { gotAll: false, data: CaseInsensitiveKeysMap.create() };
                this.countersByDocId.set(key, cache);
            }
            for (const counter of value) {
                if (cache.data.has(counter)) {
                    continue;
                }
                cache.data.set(counter, null);
            }
        }
    }
    _registerMissingCountersWithIdsList(ids, countersToInclude) {
        if (!countersToInclude) {
            return;
        }
        for (const counter of countersToInclude) {
            for (const id of ids) {
                let cache = this.countersByDocId.get(id);
                if (!cache) {
                    cache = { gotAll: false, data: CaseInsensitiveKeysMap.create() };
                    this.countersByDocId.set(id, cache);
                }
                if (cache.data.has(counter)) {
                    continue;
                }
                cache.data.set(counter, null);
            }
        }
    }
    store(entity, id, docTypeOrOptions) {
        let documentType = null;
        let options = {};
        // figure out third arg
        if (TypeUtil.isDocumentType(docTypeOrOptions)) {
            documentType = docTypeOrOptions;
        }
        else if (TypeUtil.isObject(docTypeOrOptions)) {
            options = docTypeOrOptions;
        }
        const changeVector = options.changeVector;
        documentType = documentType || options.documentType;
        this.conventions.tryRegisterJsType(documentType);
        if (entity.constructor !== Object) {
            this.conventions.tryRegisterJsType(entity.constructor);
        }
        let forceConcurrencyCheck;
        if (!TypeUtil.isUndefined(changeVector)) {
            forceConcurrencyCheck = changeVector === null ? "Disabled" : "Forced";
        }
        else if (!TypeUtil.isNullOrUndefined(id)) {
            forceConcurrencyCheck = "Auto";
        }
        else {
            const hasId = this._generateEntityIdOnTheClient.tryGetIdFromInstance(entity);
            forceConcurrencyCheck = !hasId ? "Forced" : "Auto";
        }
        return this._storeInternal(entity, changeVector, id, forceConcurrencyCheck, documentType);
    }
    _generateDocumentKeysOnStore = true;
    async _storeInternal(entity, changeVector, id, forceConcurrencyCheck, documentType) {
        if (this.noTracking) {
            throwError("InvalidOperationException", "Cannot store entity. Entity tracking is disabled in this session.");
        }
        if (!entity) {
            throwError("InvalidArgumentException", "Entity cannot be null or undefined.");
        }
        const value = this.documentsByEntity.get(entity);
        if (value) {
            if (id && !StringUtil.equalsIgnoreCase(value.id, id)) {
                throwError("InvalidOperationException", "Cannot store the same entity (id: " + value.id + ") with different id (" + id + ")");
            }
            value.changeVector = changeVector || value.changeVector;
            value.concurrencyCheckMode = forceConcurrencyCheck;
            return;
        }
        if (!id) {
            if (this._generateDocumentKeysOnStore) {
                id = await this._generateEntityIdOnTheClient.generateDocumentKeyForStorage(entity);
            }
            else {
                this._rememberEntityForDocumentIdGeneration(entity);
            }
        }
        else {
            this._generateEntityIdOnTheClient.trySetIdentity(entity, id);
        }
        const cmdKey = IdTypeAndName.keyFor(id, "ClientAnyCommand", null);
        if (this.deferredCommandsMap.has(cmdKey)) {
            throwError("InvalidOperationException", "Can't store document, there is a deferred command registered "
                + "for this document in the session. Document id: " + id);
        }
        if (this.deletedEntities.contains(entity)) {
            throwError("InvalidOperationException", "Can't store object, it was already deleted in this session. Document id: " + id);
        }
        // we make the check here even if we just generated the ID
        // users can override the ID generation behavior, and we need
        // to detect if they generate duplicates.
        this._assertNoNonUniqueInstance(entity, id);
        const conventions = this._requestExecutor.conventions;
        const typeDesc = conventions.getJsTypeByDocumentType(documentType);
        const collectionName = documentType
            ? conventions.getCollectionNameForType(typeDesc)
            : conventions.getCollectionNameForEntity(entity);
        const metadata = {};
        if (collectionName) {
            metadata[CONSTANTS.Documents.Metadata.COLLECTION] = collectionName;
        }
        const entityType = documentType
            ? conventions.getJsTypeByDocumentType(documentType)
            : conventions.getTypeDescriptorByEntity(entity);
        const jsType = conventions.getJsTypeName(entityType);
        if (jsType) {
            metadata[CONSTANTS.Documents.Metadata.RAVEN_JS_TYPE] = jsType;
        }
        if (id) {
            this._knownMissingIds.delete(id);
        }
        this._storeEntityInUnitOfWork(id, entity, changeVector, metadata, forceConcurrencyCheck, documentType);
    }
    _storeEntityInUnitOfWork(id, entity, changeVector, metadata, forceConcurrencyCheck, documentType) {
        if (id) {
            this._knownMissingIds.delete(id);
        }
        if (this.transactionMode === "ClusterWide") {
            if (!changeVector) {
                let changeVectorInner;
                if (this.clusterSession.tryGetMissingAtomicGuardFor(id, r => changeVectorInner = r)) {
                    changeVector = changeVectorInner;
                }
            }
        }
        const documentInfo = new DocumentInfo();
        documentInfo.id = id;
        documentInfo.metadata = metadata;
        documentInfo.changeVector = changeVector;
        documentInfo.concurrencyCheckMode = forceConcurrencyCheck;
        documentInfo.entity = entity;
        documentInfo.newDocument = true;
        documentInfo.document = null;
        this.documentsByEntity.put(entity, documentInfo);
        if (id) {
            this.documentsById.add(documentInfo);
        }
    }
    _rememberEntityForDocumentIdGeneration(entity) {
        throwError("NotImplementedException", "You cannot set GenerateDocumentIdsOnStore to false"
            + " without implementing RememberEntityForDocumentIdGeneration");
    }
    prepareForSaveChanges() {
        const result = this._newSaveChangesData();
        const deferredCommandsCount = this._deferredCommands.length;
        this._prepareForEntitiesDeletion(result, null);
        this._prepareForEntitiesPuts(result);
        this._prepareForCreatingRevisionsFromIds(result);
        this._prepareCompareExchangeEntities(result);
        if (this._deferredCommands.length > deferredCommandsCount) {
            // this allow OnBeforeStore to call Defer during the call to include
            // additional values during the same SaveChanges call
            for (let i = deferredCommandsCount; i < this._deferredCommands.length; i++) {
                result.deferredCommands.push(this._deferredCommands[i]);
            }
            for (const item of this.deferredCommandsMap.entries()) {
                result.deferredCommandsMap.set(item[0], item[1]);
            }
        }
        for (const deferredCommand of result.deferredCommands) {
            if (deferredCommand.onBeforeSaveChanges) {
                deferredCommand.onBeforeSaveChanges(this);
            }
        }
        return result;
    }
    validateClusterTransaction(result) {
        if (this._transactionMode !== "ClusterWide") {
            return;
        }
        if (this.useOptimisticConcurrency) {
            throwError("InvalidOperationException", "useOptimisticConcurrency is not supported with TransactionMode set to "
                + "ClusterWide");
        }
        for (const commandData of result.sessionCommands) {
            switch (commandData.type) {
                case "PUT":
                case "DELETE": {
                    if (commandData.changeVector) {
                        throwError("InvalidOperationException", "Optimistic concurrency for "
                            + commandData.id + " is not supported when using a cluster transaction.");
                    }
                    break;
                }
                case "CompareExchangeDELETE":
                case "CompareExchangePUT": {
                    break;
                }
                default: {
                    throwError("InvalidOperationException", "The command '" + commandData.type + "' is not supported in a cluster session.");
                }
            }
        }
    }
    _updateSessionAfterSaveChanges(result) {
        const returnedTransactionIndex = result.transactionIndex;
        this._documentStore.setLastTransactionIndex(this.databaseName, returnedTransactionIndex);
        this.sessionInfo.lastClusterTransactionIndex = returnedTransactionIndex;
    }
    onBeforeConversionToDocumentInvoke(id, entity) {
        const args = new BeforeConversionToDocumentEventArgs(this, id, entity);
        this.emit("beforeConversionToDocument", args);
    }
    onAfterConversionToDocumentInvoke(id, entity, document) {
        if (this.listenerCount("afterConversionToDocument")) {
            const eventArgs = new AfterConversionToDocumentEventArgs(this, id, entity, document);
            this.emit("afterConversionToDocument", eventArgs);
            if (eventArgs.document.value && eventArgs.document.value !== document.value) {
                document.value = eventArgs.document.value; //TODO: test if doc ref changes
            }
        }
    }
    onBeforeConversionToEntityInvoke(id, type, document) {
        if (this.listenerCount("beforeConversionToEntity")) {
            const eventArgs = new BeforeConversionToEntityEventArgs(this, id, type, document.value);
            this.emit("beforeConversionToEntity", eventArgs);
            if (eventArgs.document && eventArgs.document !== document) {
                document.value = eventArgs.document;
            }
        }
    }
    onAfterConversionToEntityInvoke(id, document, entity) {
        const eventArgs = new AfterConversionToEntityEventArgs(this, id, document, entity);
        this.emit("afterConversionToEntity", eventArgs);
    }
    _prepareCompareExchangeEntities(result) {
        if (!this._hasClusterSession()) {
            return;
        }
        const clusterTransactionOperations = this.clusterSession;
        if (!clusterTransactionOperations.numberOfTrackedCompareExchangeValues) {
            return;
        }
        if (this._transactionMode !== "ClusterWide") {
            throwError("InvalidOperationException", "Performing cluster transaction operation require the TransactionMode to be set to ClusterWide");
        }
        this.clusterSession.prepareCompareExchangeEntities(result);
    }
    _newSaveChangesData() {
        return new SaveChangesData({
            deferredCommands: [...this._deferredCommands],
            deferredCommandsMap: new Map(this.deferredCommandsMap),
            options: this._saveChangesOptions,
            session: this
        });
    }
    _prepareForCreatingRevisionsFromIds(result) {
        // Note: here there is no point checking 'Before' or 'After' because if there were changes then forced revision is done from the PUT command....
        for (const idEntry of this.idsForCreatingForcedRevisions.keys()) {
            result.sessionCommands.push(new ForceRevisionCommandData(idEntry));
        }
        this.idsForCreatingForcedRevisions.clear();
    }
    _prepareForEntitiesDeletion(result, changes) {
        const deletes = this.deletedEntities.prepareEntitiesDeletes();
        try {
            for (const deletedEntity of this.deletedEntities) {
                let documentInfo = this.documentsByEntity.get(deletedEntity.entity);
                if (!documentInfo) {
                    continue;
                }
                if (changes) {
                    const docChanges = [];
                    const change = new DocumentsChanges();
                    change.fieldNewValue = "";
                    change.fieldOldValue = "";
                    change.change = "DocumentDeleted";
                    docChanges.push(change);
                    changes[documentInfo.id] = docChanges;
                }
                else {
                    const command = result.deferredCommandsMap.get(IdTypeAndName.keyFor(documentInfo.id, "ClientAnyCommand", null));
                    if (command) {
                        InMemoryDocumentSessionOperations._throwInvalidDeletedDocumentWithDeferredCommand(command);
                    }
                    let changeVector = null;
                    documentInfo = this.documentsById.getValue(documentInfo.id);
                    if (documentInfo) {
                        changeVector = documentInfo.changeVector;
                        if (documentInfo.entity) {
                            result.onSuccess.removeDocumentByEntity(documentInfo.entity);
                            result.entities.push(documentInfo.entity);
                        }
                        result.onSuccess.removeDocumentById(documentInfo.id);
                    }
                    if (!this.useOptimisticConcurrency) {
                        changeVector = null;
                    }
                    const beforeDeleteEventArgs = new SessionBeforeDeleteEventArgs(this, documentInfo.id, documentInfo.entity);
                    this.emit("beforeDelete", beforeDeleteEventArgs);
                    result.sessionCommands.push(new DeleteCommandData(documentInfo.id, changeVector, documentInfo.changeVector));
                }
                if (!changes) {
                    result.onSuccess.clearDeletedEntities();
                }
            }
        }
        finally {
            deletes.dispose();
        }
    }
    _prepareForEntitiesPuts(result) {
        const putsContext = this.documentsByEntity.prepareEntitiesPuts();
        try {
            const shouldIgnoreEntityChanges = this.conventions.shouldIgnoreEntityChanges;
            for (const entry of this.documentsByEntity) {
                const { key: entityKey, value: entityValue } = entry;
                if (entityValue.ignoreChanges) {
                    continue;
                }
                if (shouldIgnoreEntityChanges) {
                    if (shouldIgnoreEntityChanges(this, entry.value.entity, entry.value.id)) {
                        continue;
                    }
                }
                if (this.isDeleted(entityValue.id)) {
                    continue;
                }
                const dirtyMetadata = InMemoryDocumentSessionOperations._updateMetadataModifications(entityValue);
                let document = this.entityToJson.convertEntityToJson(entityKey, entityValue);
                if (!this._entityChanged(document, entityValue, null) && !dirtyMetadata) {
                    continue;
                }
                const command = result.deferredCommandsMap.get(IdTypeAndName.keyFor(entityValue.id, "ClientModifyDocumentCommand", null));
                if (command) {
                    InMemoryDocumentSessionOperations._throwInvalidModifiedDocumentWithDeferredCommand(command);
                }
                const beforeStoreEventArgs = new SessionBeforeStoreEventArgs(this, entityValue.id, entityKey);
                if (this.emit("beforeStore", beforeStoreEventArgs)) { //TODO: && entity.executeOnBeforeStore
                    if (beforeStoreEventArgs.isMetadataAccessed()) {
                        InMemoryDocumentSessionOperations._updateMetadataModifications(entityValue);
                    }
                    if (beforeStoreEventArgs.isMetadataAccessed() || this._entityChanged(document, entityValue, null)) {
                        document = this.entityToJson.convertEntityToJson(entityKey, entityValue);
                    }
                }
                result.entities.push(entityKey);
                if (entityValue.id) {
                    result.onSuccess.removeDocumentById(entityValue.id);
                }
                result.onSuccess.updateEntityDocumentInfo(entityValue, document);
                let changeVector;
                if (this.useOptimisticConcurrency) {
                    if (entityValue.concurrencyCheckMode !== "Disabled") {
                        // if the user didn't provide a change vector, we'll test for an empty one
                        changeVector = entityValue.changeVector || "";
                    }
                    else {
                        changeVector = null;
                    }
                }
                else if (entityValue.concurrencyCheckMode === "Forced") {
                    changeVector = entityValue.changeVector;
                }
                else {
                    changeVector = null;
                }
                let forceRevisionCreationStrategy = "None";
                if (entityValue.id) {
                    // Check if user wants to Force a Revision
                    const creationStrategy = this.idsForCreatingForcedRevisions.get(entityValue.id);
                    if (creationStrategy) {
                        this.idsForCreatingForcedRevisions.delete(entityValue.id);
                        forceRevisionCreationStrategy = creationStrategy;
                    }
                }
                result.sessionCommands.push(new PutCommandDataWithJson(entityValue.id, changeVector, entityValue.changeVector, document, forceRevisionCreationStrategy));
            }
        }
        finally {
            putsContext.dispose();
        }
    }
    _entityChanged(newObj, documentInfo, changes) {
        return JsonOperation.entityChanged(newObj, documentInfo, changes);
    }
    static _throwInvalidModifiedDocumentWithDeferredCommand(resultCommand) {
        throwError("InvalidOperationException", "Cannot perform save because document " + resultCommand.id
            + " has been modified by the session and is also taking part in deferred "
            + resultCommand.type + " command");
    }
    static _throwInvalidDeletedDocumentWithDeferredCommand(resultCommand) {
        throwError("InvalidOperationException", "Cannot perform save because document " + resultCommand.id
            + " has been deleted by the session and is also taking part in deferred "
            + resultCommand.type + " command");
    }
    static _updateMetadataModifications(documentInfo) {
        let dirty = false;
        if (documentInfo.metadataInstance) {
            if (documentInfo.metadataInstance.isDirty()) {
                dirty = true;
            }
            for (const prop of Object.keys(documentInfo.metadataInstance)) {
                const propValue = documentInfo.metadataInstance[prop];
                if (propValue && (typeof propValue["isDirty"] === "function"
                    && propValue.isDirty())) {
                    dirty = true;
                }
                documentInfo.metadata[prop] = ObjectUtil.deepJsonClone(propValue);
            }
        }
        return dirty;
    }
    async delete(idOrEntity, expectedChangeVector = null) {
        if (TypeUtil.isString(idOrEntity)) {
            this._deleteById(idOrEntity, expectedChangeVector);
            return;
        }
        this._deleteByEntity(idOrEntity);
    }
    /**
     * Marks the specified entity for deletion. The entity will be deleted when SaveChanges is called.
     */
    _deleteByEntity(entity) {
        if (!entity) {
            throwError("InvalidArgumentException", "Entity cannot be null.");
        }
        const value = this.documentsByEntity.get(entity);
        if (!value) {
            throwError("InvalidOperationException", entity + " is not associated with the session, cannot delete unknown entity instance");
        }
        this.deletedEntities.add(entity);
        this.includedDocumentsById.delete(value.id);
        if (this._countersByDocId) {
            this._countersByDocId.delete(value.id);
        }
        if (this._timeSeriesByDocId) {
            this._timeSeriesByDocId.delete(value.id);
        }
        this._knownMissingIds.add(value.id);
    }
    _deleteById(id, expectedChangeVector = null) {
        if (!id) {
            throwError("InvalidArgumentException", "Id cannot be null.");
        }
        let changeVector = null;
        const documentInfo = this.documentsById.getValue(id);
        if (documentInfo) {
            const newObj = this.entityToJson.convertEntityToJson(documentInfo.entity, documentInfo);
            if (documentInfo.entity && this._entityChanged(newObj, documentInfo, null)) {
                throwError("InvalidOperationException", "Can't delete changed entity using identifier. Use delete(T entity) instead.");
            }
            if (documentInfo.entity) {
                this.documentsByEntity.remove(documentInfo.entity);
            }
            this.documentsById.remove(id);
            changeVector = documentInfo.changeVector;
        }
        this._knownMissingIds.add(id);
        changeVector = this.useOptimisticConcurrency ? changeVector : null;
        if (this._countersByDocId) {
            this._countersByDocId.delete(id);
        }
        this.defer(new DeleteCommandData(id, expectedChangeVector || changeVector, expectedChangeVector || documentInfo?.changeVector));
    }
    /**
     * Defer commands to be executed on saveChanges()
     */
    defer(...commands) {
        this._deferredCommands.push(...commands);
        for (const command of commands) {
            this._deferInternal(command);
        }
    }
    _deferInternal(command) {
        if (command.type === "BatchPATCH") {
            const batchPatchCommand = command;
            for (const kvp of batchPatchCommand.ids) {
                this._addCommand(command, kvp.id, "PATCH", command.name);
            }
            return;
        }
        this._addCommand(command, command.id, command.type, command.name);
    }
    _addCommand(command, id, commandType, commandName) {
        this.deferredCommandsMap.set(IdTypeAndName.keyFor(id, commandType, commandName), command);
        this.deferredCommandsMap.set(IdTypeAndName.keyFor(id, "ClientAnyCommand", null), command);
        if (command.type !== "AttachmentPUT"
            && command.type !== "AttachmentDELETE"
            && command.type !== "AttachmentCOPY"
            && command.type !== "AttachmentMOVE"
            && command.type !== "Counters"
            && command.type !== "TimeSeries"
            && command.type !== "TimeSeriesWithIncrements"
            && command.type !== "TimeSeriesCopy") {
            this.deferredCommandsMap.set(IdTypeAndName.keyFor(id, "ClientModifyDocumentCommand", null), command);
        }
    }
    _buildEntityDocInfoByIdHolder(entities) {
        const idsEntitiesPairs = new Map();
        for (const entity of entities) {
            const docInfo = this.documentsByEntity.get(entity);
            if (!docInfo) {
                InMemoryDocumentSessionOperations._throwCouldNotRefreshDocument("Cannot refresh a transient instance.");
            }
            idsEntitiesPairs.set(docInfo.id, [entity, docInfo]);
        }
        return idsEntitiesPairs;
    }
    _refreshEntities(command, idsEntitiesPairs) {
        const list = [];
        let hasDeleted = false;
        const resultsCollection = command.result.results;
        for (const result of resultsCollection) {
            if (!result) {
                hasDeleted = true;
                break;
            }
            const id = result[CONSTANTS.Documents.Metadata.KEY][CONSTANTS.Documents.Metadata.ID];
            const tuple = idsEntitiesPairs.get(id);
            if (!tuple) {
                InMemoryDocumentSessionOperations._throwCouldNotRefreshDocument("Could not refresh an entity, the server returned an invalid id: " + id + ". Should not happen!");
            }
            list.push({
                entity: tuple[0],
                info: tuple[1],
                result
            });
        }
        if (hasDeleted) {
            InMemoryDocumentSessionOperations._throwCouldNotRefreshDocument("Some of the requested documents are no longer exists and were probably deleted!");
        }
        for (const tuple of list) {
            this._refreshInternal(tuple.entity, tuple.result, tuple.info);
        }
    }
    static _throwCouldNotRefreshDocument(msg) {
        throwError("InvalidArgumentException", msg);
    }
    _refreshInternal(entity, cmd, documentInfo) {
        const document = cmd;
        if (!document) {
            throwError("InvalidOperationException", "Document '" + documentInfo.id + "' no longer exists and was probably deleted");
        }
        const value = document[CONSTANTS.Documents.Metadata.KEY];
        documentInfo.metadata = value;
        if (documentInfo.metadata) {
            const changeVector = value[CONSTANTS.Documents.Metadata.CHANGE_VECTOR];
            documentInfo.changeVector = changeVector;
        }
        if (documentInfo.entity && !this.noTracking) {
            this.entityToJson.removeFromMissing(documentInfo.entity);
        }
        const entityType = this.conventions.getTypeDescriptorByEntity(entity);
        documentInfo.entity = this.entityToJson.convertToEntity(entityType, documentInfo.id, document, !this.noTracking);
        documentInfo.document = document;
        Object.assign(entity, documentInfo.entity);
        const documentInfoById = this.documentsById.getValue(documentInfo.id);
        if (documentInfoById) {
            documentInfoById.entity = entity;
        }
        this.onAfterConversionToEntityInvoke(documentInfo.id, documentInfo.document, documentInfo.entity);
    }
    /**
     * Returns all changes for the specified entity. Including name of the field/property that changed, its old and new value and change type.
     * @param entity Entity
     */
    whatChangedFor(entity) {
        const documentInfo = this.documentsByEntity.get(entity);
        if (!documentInfo) {
            return [];
        }
        if (this.deletedEntities.contains(entity)) {
            const change = new DocumentsChanges();
            change.fieldNewValue = "";
            change.fieldOldValue = "";
            change.change = "DocumentDeleted";
            return [change];
        }
        InMemoryDocumentSessionOperations._updateMetadataModifications(documentInfo);
        const document = this.entityToJson.convertEntityToJson(documentInfo.entity, documentInfo);
        const changes = {};
        if (!this._entityChanged(document, documentInfo, changes)) {
            return [];
        }
        return changes[documentInfo.id];
    }
    getTrackedEntities() {
        const tracked = this.documentsById.getTrackedEntities(this);
        for (const id of this._knownMissingIds) {
            if (tracked.has(id)) {
                continue;
            }
            const entityInfo = new EntityInfo();
            entityInfo.id = id;
            entityInfo.isDeleted = true;
            tracked.set(id, entityInfo);
        }
        return tracked;
    }
    /**
     * Gets a value indicating whether any of the entities tracked by the session has changes.
     */
    hasChanges() {
        for (const entity of this.documentsByEntity) {
            const document = this.entityToJson.convertEntityToJson(entity.key, entity.value);
            if (this._entityChanged(document, entity.value, null)) {
                return true;
            }
        }
        return !!this.deletedEntities.size || this.deferredCommands.length > 0;
    }
    /**
     * Evicts the specified entity from the session.
     * Remove the entity from the delete queue and stops tracking changes for this entity.
     */
    evict(entity) {
        const documentInfo = this.documentsByEntity.get(entity);
        if (documentInfo) {
            this.documentsByEntity.evict(entity);
            this.documentsById.remove(documentInfo.id);
            if (this._countersByDocId) {
                this._countersByDocId.delete(documentInfo.id);
            }
            if (this._timeSeriesByDocId) {
                this._timeSeriesByDocId.delete(documentInfo.id);
            }
        }
        this.deletedEntities.evict(entity);
        this.entityToJson.removeFromMissing(entity);
    }
    /**
     * Clears this instance.
     * Remove all entities from the delete queue and stops tracking changes for all entities.
     */
    clear() {
        this.documentsByEntity.clear();
        this.deletedEntities.clear();
        this.documentsById.clear();
        this._knownMissingIds.clear();
        if (this._countersByDocId) {
            this._countersByDocId.clear();
        }
        this.deferredCommands.length = 0;
        this.deferredCommandsMap.clear();
        this._clearClusterSession();
        this._pendingLazyOperations.length = 0;
        this.entityToJson.clear();
    }
    /**
     * Determines whether the specified entity has changed.
     */
    hasChanged(entity) {
        const documentInfo = this.documentsByEntity.get(entity);
        if (!documentInfo) {
            return false;
        }
        const document = this.entityToJson.convertEntityToJson(entity, documentInfo);
        return this._entityChanged(document, documentInfo, null);
    }
    /**
     * SaveChanges will wait for the changes made to be replicates to `replicas` nodes
     */
    waitForReplicationAfterSaveChanges(opts) {
        if (!this._saveChangesOptions) {
            this._saveChangesOptions = {
                indexOptions: null,
                replicationOptions: null
            };
        }
        opts = opts || {};
        this._saveChangesOptions.replicationOptions = {
            replicas: opts.replicas || 1,
            throwOnTimeout: TypeUtil.isUndefined(opts.throwOnTimeout) ? true : opts.throwOnTimeout,
            majority: TypeUtil.isNullOrUndefined(opts.majority) ? false : opts.majority,
            timeout: opts.timeout || this.conventions.waitForReplicationAfterSaveChangesTimeout
        };
    }
    /**
     * SaveChanges will wait for the indexes to catch up with the saved changes
     */
    waitForIndexesAfterSaveChanges(opts) {
        if (!this._saveChangesOptions) {
            this._saveChangesOptions = {
                indexOptions: null,
                replicationOptions: null
            };
        }
        opts = opts || {};
        this._saveChangesOptions.indexOptions = {
            indexes: opts.indexes || [],
            throwOnTimeout: TypeUtil.isNullOrUndefined(opts.throwOnTimeout) ? true : opts.throwOnTimeout,
            timeout: opts.timeout || this.conventions.waitForIndexesAfterSaveChangesTimeout
        };
    }
    /**
     * Mark the entity as one that should be ignore for change tracking purposes,
     * it still takes part in the session, but is ignored for SaveChanges.
     */
    ignoreChangesFor(entity) {
        this._getDocumentInfo(entity).ignoreChanges = true;
    }
    whatChanged() {
        const changes = {};
        this._getAllEntitiesChanges(changes);
        this._prepareForEntitiesDeletion(null, changes);
        return changes;
    }
    _getAllEntitiesChanges(changes) {
        for (const pair of this.documentsById.entries()) {
            InMemoryDocumentSessionOperations._updateMetadataModifications(pair[1]);
            const newObj = this.entityToJson.convertEntityToJson(pair[1].entity, pair[1]);
            this._entityChanged(newObj, pair[1], changes);
        }
    }
    dispose(isDisposing) {
        if (this._disposed) {
            return;
        }
        this.emit("sessionDisposing", { session: this });
        this._disposed = true;
    }
    get transactionMode() {
        return this._transactionMode;
    }
    set transactionMode(value) {
        this._transactionMode = value;
    }
    static validateTimeSeriesName(name) {
        if (StringUtil.isNullOrEmpty(name)) {
            throwError("InvalidArgumentException", "Time Series name must contain at least one character");
        }
        if (StringUtil.startsWithIgnoreCase(name, HEADERS.INCREMENTAL_TIME_SERIES_PREFIX) && !name.includes("@")) {
            throwError("InvalidArgumentException", "Time Series name cannot start with " + HEADERS.INCREMENTAL_TIME_SERIES_PREFIX + " prefix");
        }
    }
    static validateIncrementalTimeSeriesName(name) {
        if (StringUtil.isNullOrEmpty(name)) {
            throwError("InvalidArgumentException", "Incremental Time Series name must contain at least one character");
        }
        if (!StringUtil.startsWithIgnoreCase(name, HEADERS.INCREMENTAL_TIME_SERIES_PREFIX)) {
            throwError("InvalidArgumentException", "Time Series name must start with " + HEADERS.INCREMENTAL_TIME_SERIES_PREFIX + " prefix");
        }
        if (name.includes("@")) {
            throwError("InvalidArgumentException", "Time Series from type Rollup cannot be Incremental");
        }
    }
    assertNoIncludesInNonTrackingSession() {
        if (this.noTracking) {
            throw new Error("This session does not track any entities, because of that registering " +
                "includes is forbidden to avoid false expectations when later load operations are performed " +
                "on those and no requests are being sent to the server. Please avoid any 'include' " +
                "operations during non-tracking session actions like load or query.");
        }
    }
    static _throwNoDatabase() {
        return throwError("InvalidOperationException", "Cannot open a Session without specifying a name of a database " +
            "to operate on. Database name can be passed as an argument when Session is" +
            " being opened or default database can be defined using 'DocumentStore.setDatabase()' method");
    }
}
export class DocumentsByEntityHolder {
    _documentsByEntity = new Map();
    _onBeforeStoreDocumentsByEntity;
    _prepareEntitiesPuts;
    get size() {
        return this._documentsByEntity.size + (this._onBeforeStoreDocumentsByEntity ? this._onBeforeStoreDocumentsByEntity.size : 0);
    }
    remove(entity) {
        this._documentsByEntity.delete(entity);
        if (this._onBeforeStoreDocumentsByEntity) {
            this._onBeforeStoreDocumentsByEntity.delete(entity);
        }
    }
    evict(entity) {
        if (this._prepareEntitiesPuts) {
            throwError("InvalidArgumentException", "Cannot Evict entity during OnBeforeStore");
        }
        this._documentsByEntity.delete(entity);
    }
    put(entity, documentInfo) {
        if (!this._prepareEntitiesPuts) {
            this._documentsByEntity.set(entity, documentInfo);
            return;
        }
        this._createOnBeforeStoreDocumentsByEntityIfNeeded();
        this._onBeforeStoreDocumentsByEntity.set(entity, documentInfo);
    }
    _createOnBeforeStoreDocumentsByEntityIfNeeded() {
        if (this._onBeforeStoreDocumentsByEntity) {
            return;
        }
        this._onBeforeStoreDocumentsByEntity = new Map();
    }
    clear() {
        this._documentsByEntity.clear();
        if (this._onBeforeStoreDocumentsByEntity) {
            this._onBeforeStoreDocumentsByEntity.clear();
        }
    }
    get(entity) {
        const documentInfo = this._documentsByEntity.get(entity);
        if (documentInfo) {
            return documentInfo;
        }
        if (this._onBeforeStoreDocumentsByEntity) {
            return this._onBeforeStoreDocumentsByEntity.get(entity);
        }
        return null;
    }
    [Symbol.iterator]() {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const self = this;
        const generator = function* () {
            const firstIterator = self._documentsByEntity.entries();
            for (const item of firstIterator) {
                const mapped = {
                    key: item[0],
                    value: item[1],
                    executeOnBeforeStore: true
                };
                yield mapped;
            }
            if (!self._onBeforeStoreDocumentsByEntity) {
                return;
            }
            for (const item of self._onBeforeStoreDocumentsByEntity.entries()) {
                const mapped = {
                    key: item[0],
                    value: item[1],
                    executeOnBeforeStore: false
                };
                yield mapped;
            }
        };
        return generator();
    }
    prepareEntitiesPuts() {
        this._prepareEntitiesPuts = true;
        const turnOff = () => this._prepareEntitiesPuts = false;
        return {
            dispose: turnOff
        };
    }
}
export class DeletedEntitiesHolder {
    _deletedEntities = new Set();
    _onBeforeDeletedEntities;
    _prepareEntitiesDeletes;
    isEmpty() {
        return this.size === 0;
    }
    get size() {
        return this._deletedEntities.size + (this._onBeforeDeletedEntities ? this._onBeforeDeletedEntities.size : 0);
    }
    add(entity) {
        if (this._prepareEntitiesDeletes) {
            if (!this._onBeforeDeletedEntities) {
                this._onBeforeDeletedEntities = new Set();
            }
            this._onBeforeDeletedEntities.add(entity);
            return;
        }
        this._deletedEntities.add(entity);
    }
    remove(entity) {
        this._deletedEntities.delete(entity);
        if (this._onBeforeDeletedEntities) {
            this._onBeforeDeletedEntities.delete(entity);
        }
    }
    evict(entity) {
        if (this._prepareEntitiesDeletes) {
            throwError("InvalidOperationException", "Cannot Evict entity during OnBeforeDelete");
        }
        this._deletedEntities.delete(entity);
    }
    contains(entity) {
        if (this._deletedEntities.has(entity)) {
            return true;
        }
        if (!this._onBeforeDeletedEntities) {
            return false;
        }
        return this._onBeforeDeletedEntities.has(entity);
    }
    clear() {
        this._deletedEntities.clear();
        if (this._onBeforeDeletedEntities) {
            this._onBeforeDeletedEntities.clear();
        }
    }
    [Symbol.iterator]() {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const self = this;
        const generator = function* () {
            const deletedIterator = self._deletedEntities.values();
            for (const item of deletedIterator) {
                const mapped = {
                    entity: item,
                    executeOnBeforeDelete: true
                };
                yield mapped;
            }
            if (!self._onBeforeDeletedEntities) {
                return;
            }
            for (const item of self._onBeforeDeletedEntities.values()) {
                const mapped = {
                    entity: item,
                    executeOnBeforeDelete: false
                };
                yield mapped;
            }
        };
        return generator();
    }
    prepareEntitiesDeletes() {
        this._prepareEntitiesDeletes = true;
        return {
            dispose() {
                this._prepareEntitiesDeletes = false;
            }
        };
    }
}
//# sourceMappingURL=InMemoryDocumentSessionOperations.js.map