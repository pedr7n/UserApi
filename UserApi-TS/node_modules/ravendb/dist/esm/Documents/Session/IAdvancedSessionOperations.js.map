{"version":3,"file":"IAdvancedSessionOperations.js","sourceRoot":"","sources":["../../../../src/Documents/Session/IAdvancedSessionOperations.ts"],"names":[],"mappings":"","sourcesContent":["import { StreamQueryStatistics } from \"./StreamQueryStatistics.js\";\r\nimport { RequestExecutor } from \"../../Http/RequestExecutor.js\";\r\nimport { ServerNode } from \"../../Http/ServerNode.js\";\r\nimport { ICommandData } from \"../Commands/CommandData.js\";\r\nimport { IDocumentStore } from \"../IDocumentStore.js\";\r\nimport { DocumentsChanges } from \"./DocumentsChanges.js\";\r\nimport { EntityToJson } from \"./EntityToJson.js\";\r\nimport { IMetadataDictionary } from \"./IMetadataDictionary.js\";\r\nimport { SessionEventsEmitter } from \"./SessionEvents.js\";\r\nimport { TransactionMode } from \"./TransactionMode.js\";\r\nimport { IEagerSessionOperations } from \"./Operations/Lazy/IEagerSessionOperations.js\";\r\nimport { ILazySessionOperations } from \"./Operations/Lazy/ILazySessionOperations.js\";\r\nimport { IAttachmentsSessionOperations } from \"./IAttachmentsSessionOperations.js\";\r\nimport { IRevisionsSessionOperations } from \"./IRevisionsSessionOperations.js\";\r\nimport { IClusterTransactionOperations } from \"./IClusterTransactionOperations.js\";\r\nimport { DocumentType } from \"../DocumentAbstractions.js\";\r\nimport { IRawDocumentQuery } from \"./IRawDocumentQuery.js\";\r\nimport { SessionInfo, SessionLoadStartingWithOptions } from \"./IDocumentSession.js\";\r\nimport { IDocumentQuery } from \"./IDocumentQuery.js\";\r\nimport { JavaScriptArray } from \"./JavaScriptArray.js\";\r\nimport { DocumentResultStream } from \"./DocumentResultStream.js\";\r\nimport { Writable } from \"node:stream\";\r\nimport { IDocumentQueryBuilder } from \"./IDocumentQueryBuilder.js\";\r\nimport { JavaScriptMap } from \"./JavaScriptMap.js\";\r\nimport { ConditionalLoadResult } from \"./ConditionalLoadResult.js\";\r\nimport { EntityInfo } from \"./DocumentsById.js\";\r\n\r\nexport type StreamQueryStatisticsCallback = (stats: StreamQueryStatistics) => void;\r\n\r\n/**\r\n * It gives the ability to construct queries with the usage of {@link IDocumentQuery} interface\r\n */\r\nexport interface IAdvancedSessionOperations extends IAdvancedDocumentSessionOperations, IDocumentQueryBuilder {\r\n\r\n    /**\r\n     *  Access the eager operations\r\n     */\r\n    eagerly: IEagerSessionOperations;\r\n\r\n    /**\r\n     * Access the lazy operations\r\n     */\r\n    lazily: ILazySessionOperations;\r\n\r\n    /**\r\n     * Access the attachments operations\r\n     */\r\n    attachments: IAttachmentsSessionOperations;\r\n\r\n    /**\r\n     * Access the revisions operations\r\n     */\r\n    revisions: IRevisionsSessionOperations;\r\n\r\n    /**\r\n     * Access cluster transaction operations\r\n     */\r\n    clusterTransaction: IClusterTransactionOperations;\r\n\r\n    /**\r\n     * Updates entity with latest changes from server\r\n     */\r\n    refresh<TEntity extends object>(entity: TEntity): Promise<void>;\r\n\r\n    /**\r\n     * Updates entities with latest changes from server\r\n     */\r\n    refresh<TEntity extends object>(entities: TEntity[]): Promise<void>;\r\n\r\n    /**\r\n     * Query the specified index using provided raw query\r\n     */\r\n\r\n    rawQuery<TResult extends object>(query: string, documentType?: DocumentType<TResult>): IRawDocumentQuery<TResult>;\r\n\r\n    exists(id: string): Promise<boolean>;\r\n\r\n    loadStartingWith<T extends object>(idPrefix: string, opts: SessionLoadStartingWithOptions<T>): Promise<T[]>;\r\n\r\n    loadStartingWith<T extends object>(idPrefix: string): Promise<T[]>;\r\n\r\n    increment<TEntity extends object, UValue>(id: string, path: string, valueToAdd: UValue): void;\r\n\r\n    increment<TEntity extends object, UValue>(entity: TEntity, path: string, valueToAdd: UValue): void;\r\n\r\n    patch<TEntity extends object, UValue>(id: string, path: string, value: UValue): void;\r\n\r\n    patch<TEntity extends object, UValue>(entity: TEntity, path: string, value: UValue): void;\r\n\r\n    patchArray<TEntity extends object, UValue>(\r\n        id: string, pathToArray: string, arrayAdder: (array: JavaScriptArray<UValue>) => void): void;\r\n\r\n    patchArray<TEntity extends object, UValue>(\r\n        entity: TEntity, pathToArray: string, arrayAdder: (array: JavaScriptArray<UValue>) => void): void;\r\n\r\n    patchObject<TEntity extends object, TKey, TValue>(\r\n        entity: TEntity, pathToObject: string, mapAdder: (map: JavaScriptMap<TKey, TValue>) => void): void;\r\n\r\n    patchObject<TEntity extends object, TKey, TValue>(\r\n        id: string, pathToObject: string, mapAdder: (map: JavaScriptMap<TKey, TValue>) => void): void;\r\n\r\n    addOrPatch<TEntity extends object, UValue>(id: string, entity: TEntity, pathToObject: string, value: UValue): void;\r\n\r\n    addOrPatchArray<TEntity extends object, UValue>(\r\n        id: string, entity: TEntity, pathToObject: string, arrayAdder: (array: JavaScriptArray<UValue>) => void): void;\r\n\r\n    addOrIncrement<TEntity extends object, UValue>(id: string, entity: TEntity, pathToObject: string, valToAdd: UValue): void;\r\n\r\n    /**\r\n     *  Returns the results of a query directly into stream\r\n     */\r\n    streamInto<T extends object>(query: IDocumentQuery<T>, writable: Writable): Promise<void>;\r\n\r\n    /**\r\n     * Returns the results of a query directly into stream\r\n     */\r\n    streamInto<T extends object>(query: IRawDocumentQuery<T>, writable: Writable): Promise<void>;\r\n\r\n    loadIntoStream(\r\n        ids: string[], writable: Writable): Promise<void>;\r\n\r\n    loadStartingWithIntoStream<TEntity extends object>(\r\n        idPrefix: string,\r\n        writable: Writable): Promise<void>;\r\n\r\n    loadStartingWithIntoStream<TEntity extends object>(\r\n        idPrefix: string,\r\n        writable: Writable,\r\n        opts: SessionLoadStartingWithOptions<TEntity>): Promise<void>;\r\n\r\n    /**\r\n     * Stream the results on the query to the client.\r\n     *\r\n     * Does NOT track the entities in the session, and will not include changes there when saveChanges() is called\r\n     */\r\n    stream<T extends object>(query: IDocumentQuery<T>): Promise<DocumentResultStream<T>>;\r\n\r\n    /**\r\n     * Stream the results on the query to the client.\r\n     *\r\n     * Does NOT track the entities in the session, and will not include changes there when saveChanges() is called\r\n     */\r\n    stream<T extends object>(\r\n        query: IDocumentQuery<T>,\r\n        streamQueryStats: StreamQueryStatisticsCallback)\r\n        : Promise<DocumentResultStream<T>>;\r\n\r\n    /**\r\n     * Stream the results on the query to the client.\r\n     *\r\n     * Does NOT track the entities in the session, and will not include changes there when saveChanges() is called\r\n     */\r\n    stream<T extends object>(query: IRawDocumentQuery<T>)\r\n        : Promise<DocumentResultStream<T>>;\r\n\r\n    /**\r\n     * Stream the results on the query to the client.\r\n     *\r\n     * Does NOT track the entities in the session, and will not include changes there when saveChanges() is called\r\n     */\r\n    stream<T extends object>(\r\n        query: IRawDocumentQuery<T>,\r\n        streamQueryStats: StreamQueryStatisticsCallback)\r\n        : Promise<DocumentResultStream<T>>;\r\n\r\n    /**\r\n     * Stream the results on the query to the client.\r\n     *\r\n     * Does NOT track the entities in the session, and will not include changes there when saveChanges() is called\r\n     */\r\n    stream<T extends object>(idPrefix: string)\r\n        : Promise<DocumentResultStream<T>>;\r\n\r\n    /**\r\n     * Stream the results on the query to the client.\r\n     *\r\n     * Does NOT track the entities in the session, and will not include changes there when saveChanges() is called\r\n     */\r\n    stream<T extends object>(idPrefix: string, opts: SessionLoadStartingWithOptions<T>)\r\n        : Promise<DocumentResultStream<T>>;\r\n\r\n    /**\r\n     * Loads the specified entity with the specified id and changeVector.\r\n     * If the entity is loaded into the session, the tracked entity will be returned otherwise the entity will be loaded only if it is fresher then the provided changeVector.\r\n     * @param id Identifier of a entity that will be conditional loaded.\r\n     * @param changeVector Change vector of a entity that will be conditional loaded.\r\n     * @param clazz Result class\r\n     */\r\n    conditionalLoad<T extends object>(id: string, changeVector: string, clazz: DocumentType<T>): Promise<ConditionalLoadResult<T>>;\r\n}\r\n\r\nexport interface ReplicationBatchOptions {\r\n    timeout?: number;\r\n    throwOnTimeout?: boolean;\r\n    replicas?: number;\r\n    majority?: boolean;\r\n}\r\n\r\nexport interface IndexBatchOptions {\r\n    timeout?: number;\r\n    throwOnTimeout?: boolean;\r\n    indexes?: string[];\r\n}\r\n\r\nexport interface IAdvancedDocumentSessionOperations extends SessionEventsEmitter {\r\n\r\n    /**\r\n     * The document store associated with this session\r\n     */\r\n    documentStore: IDocumentStore;\r\n\r\n    /**\r\n     * Allow extensions to provide additional state per session\r\n     */\r\n    externalState: Map<string, object>;\r\n\r\n    getCurrentSessionNode(): Promise<ServerNode>;\r\n\r\n    requestExecutor: RequestExecutor;\r\n\r\n    sessionInfo: SessionInfo;\r\n\r\n    /**\r\n     * Gets a value indicating whether any of the entities tracked by the session has changes.\r\n     */\r\n    hasChanges(): boolean;\r\n\r\n    maxNumberOfRequestsPerSession: number;\r\n\r\n    /**\r\n     * Gets the number of requests for this session\r\n     */\r\n    numberOfRequests: number;\r\n    /**\r\n     * Gets the store identifier for this session.\r\n     * The store identifier is the identifier for the particular RavenDB instance.\r\n     */\r\n    storeIdentifier: string;\r\n\r\n    /**\r\n     * Gets value indicating whether the session should use optimistic concurrency.\r\n     * When set to true, a check is made so that a change made behind the session back would fail\r\n     * and raise ConcurrencyException\r\n     */\r\n    useOptimisticConcurrency: boolean;\r\n\r\n    /**\r\n     * Clears this instance.\r\n     * Remove all entities from the delete queue and stops tracking changes for all entities.\r\n     */\r\n    clear(): void;\r\n\r\n    /**\r\n     * Defer commands to be executed on saveChanges()\r\n     */\r\n    defer(...commands: ICommandData[]): void;\r\n\r\n    /**\r\n     * Evicts the specified entity from the session.\r\n     * Remove the entity from the delete queue and stops tracking changes for this entity.\r\n     */\r\n    evict<TEntity extends object>(entity: TEntity): void;\r\n\r\n    /**\r\n     * Gets the document id for the specified entity.\r\n     *\r\n     *  This function may return null if the entity isn't tracked by the session, or if the entity is\r\n     *   a new entity with an ID that should be generated on the server.\r\n     */\r\n    getDocumentId(entity: object): string;\r\n\r\n    /**\r\n     * Gets the metadata for the specified entity.\r\n     * If the entity is transient, it will load the metadata from the store\r\n     * and associate the current state of the entity with the metadata from the server.\r\n     */\r\n    getMetadataFor<T extends object>(instance: T): IMetadataDictionary;\r\n\r\n    /**\r\n     * Gets change vector for the specified entity.\r\n     * If the entity is transient, it will load the metadata from the store\r\n     * and associate the current state of the entity with the metadata from the server.\r\n     */\r\n    getChangeVectorFor<T extends object>(instance: T): string;\r\n\r\n    /**\r\n     * Gets all the counter names for the specified entity.\r\n     */\r\n    getCountersFor<T extends object>(instance: T): string[];\r\n\r\n    /**\r\n     * Gets all time series names for the specified entity.\r\n     * @param instance The instance\r\n     */\r\n    getTimeSeriesFor<T extends object>(instance: T): string[];\r\n\r\n    /**\r\n     * Gets last modified date for the specified entity.\r\n     * If the entity is transient, it will load the metadata from the store\r\n     * and associate the current state of the entity with the metadata from the server.\r\n     */\r\n    getLastModifiedFor<T extends object>(instance: T): Date;\r\n\r\n    /**\r\n     * Determines whether the specified entity has changed.\r\n     */\r\n    hasChanged(entity: object): boolean;\r\n\r\n    /**\r\n     * Returns whether a document with the specified id is loaded in the\r\n     * current session\r\n     */\r\n    isLoaded(id: string): boolean;\r\n\r\n    /**\r\n     * Mark the entity as one that should be ignore for change tracking purposes,\r\n     * it still takes part in the session, but is ignored for SaveChanges.\r\n     */\r\n    ignoreChangesFor(entity: object): void;\r\n\r\n    /**\r\n     * Returns all changes for each entity stored within session.\r\n     * Including name of the field/property that changed, its old and new value and change type.\r\n     */\r\n    whatChanged(): { [id: string]: DocumentsChanges[] };\r\n\r\n    /**\r\n     * Returns all changes for the specified entity. Including name of the field/property that changed, its old and new value and change type.\r\n     * @param entity Entity\r\n     */\r\n    whatChangedFor(entity: object): DocumentsChanges[];\r\n\r\n    /**\r\n     * Returns all the tracked entities in this session.\r\n     */\r\n    getTrackedEntities(): Map<string, EntityInfo>;\r\n\r\n    /**\r\n     * SaveChanges will wait for the changes made to be replicates to `replicas` nodes\r\n     */\r\n    waitForReplicationAfterSaveChanges(): void;\r\n\r\n    /**\r\n     * SaveChanges will wait for the changes made to be replicates to `replicas` nodes\r\n     */\r\n    waitForReplicationAfterSaveChanges(opts: ReplicationBatchOptions): void;\r\n\r\n    /**\r\n     * SaveChanges will wait for the indexes to catch up with the saved changes\r\n     */\r\n    waitForIndexesAfterSaveChanges(): void;\r\n\r\n    /**\r\n     * SaveChanges will wait for the indexes to catch up with the saved changes\r\n     */\r\n    waitForIndexesAfterSaveChanges(opts: IndexBatchOptions): void;\r\n\r\n    entityToJson: EntityToJson;\r\n\r\n    /**\r\n     * Overwrite the existing transaction mode for the current session.\r\n     */\r\n    transactionMode: TransactionMode;\r\n}\r\n"]}