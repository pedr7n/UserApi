import { StringUtil } from "../../Utility/StringUtil.js";
import { throwError } from "../../Exceptions/index.js";
import { HeadersBuilder } from "../../Utility/HttpUtil.js";
import { pipelineAsync } from "../../Utility/StreamUtil.js";
import { dirname, resolve, extname } from "node:path";
import { BackupUtils } from "./BackupUtils.js";
import { OperationCompletionAwaiter } from "../Operations/OperationCompletionAwaiter.js";
import { GetNextOperationIdCommand } from "../Commands/GetNextOperationIdCommand.js";
import { RavenCommand } from "../../Http/RavenCommand.js";
export class DatabaseSmuggler {
    _store;
    _databaseName;
    _requestExecutor;
    constructor(store, databaseName) {
        this._store = store;
        this._databaseName = databaseName ?? store.database;
        if (this._databaseName) {
            this._requestExecutor = store.getRequestExecutor(this._databaseName);
        }
        else {
            this._requestExecutor = null;
        }
    }
    forDatabase(databaseName) {
        if (StringUtil.equalsIgnoreCase(databaseName, this._databaseName)) {
            return this;
        }
        return new DatabaseSmuggler(this._store, databaseName);
    }
    async export(options, toFile) {
        const directory = dirname(resolve(toFile));
        const { existsSync, mkdirSync, createWriteStream } = await import("node:fs");
        if (!existsSync(directory)) {
            mkdirSync(directory, { recursive: true });
        }
        return await this._export(options, async (response) => {
            const fileStream = createWriteStream(toFile);
            await pipelineAsync(response, fileStream);
        });
    }
    async _export(options, handleStreamResponse) {
        if (!options) {
            throwError("InvalidArgumentException", "Options cannot be null");
        }
        if (!this._requestExecutor) {
            throwError("InvalidOperationException", "Cannot use smuggler without a database defined, did you forget to call 'forDatabase'?");
        }
        const getOperationIdCommand = new GetNextOperationIdCommand();
        await this._requestExecutor.execute(getOperationIdCommand);
        const operationId = getOperationIdCommand.result;
        const command = new ExportCommand(this._requestExecutor.conventions, options, handleStreamResponse, operationId, getOperationIdCommand.nodeTag);
        await this._requestExecutor.execute(command);
        return new OperationCompletionAwaiter(this._requestExecutor, this._requestExecutor.conventions, operationId, getOperationIdCommand.nodeTag);
    }
    async importIncremental(options, fromDirectory) {
        const { statSync, readdirSync } = await import("node:fs");
        const mProvider = f => statSync(f).mtimeMs;
        const files = readdirSync(fromDirectory)
            .filter(x => BackupUtils.BACKUP_FILE_SUFFIXES.includes("." + extname(x)))
            .sort((a, b) => BackupUtils.comparator(a, b, mProvider));
        if (!files.length) {
            return;
        }
        const oldOperateOnTypes = DatabaseSmuggler.configureOptionsFromIncrementalImport(options);
        for (let i = 0; i < files.length - 1; i++) {
            const filePath = files[i];
            await this.import(options, resolve(filePath));
        }
        options.operateOnTypes = oldOperateOnTypes;
        const lastFile = files.at(-1);
        await this.import(options, resolve(lastFile));
    }
    static configureOptionsFromIncrementalImport(options) {
        options.operateOnTypes.push("Tombstones");
        options.operateOnTypes.push("CompareExchangeTombstones");
        // we import the indexes and Subscriptions from the last file only,
        const oldOperateOnTypes = [...options.operateOnTypes];
        options.operateOnTypes = options.operateOnTypes.filter(x => x !== "Indexes" && x !== "Subscriptions");
        return oldOperateOnTypes;
    }
    async import(options, fromFile) {
        let countOfFileParts = 0;
        const { existsSync } = await import("node:fs");
        let result;
        do {
            result = await this._import(options, fromFile);
            countOfFileParts++;
            fromFile = StringUtil.format("{0}.part{1}", fromFile, countOfFileParts);
        } while (existsSync(fromFile));
        return result;
    }
    async _import(options, file) {
        if (!options) {
            throwError("InvalidArgumentException", "Options cannot be null");
        }
        if (!file) {
            throwError("InvalidArgumentException", "File cannot be null");
        }
        if (!this._requestExecutor) {
            throwError("InvalidOperationException", "Cannot use smuggler without a database defined, did you forget to call 'forDatabase'?");
        }
        const getOperationIdCommand = new GetNextOperationIdCommand();
        await this._requestExecutor.execute(getOperationIdCommand);
        const operationId = getOperationIdCommand.result;
        const command = new ImportCommand(this._requestExecutor.conventions, options, file, operationId, getOperationIdCommand.nodeTag);
        await this._requestExecutor.execute(command);
        return new OperationCompletionAwaiter(this._requestExecutor, this._requestExecutor.conventions, operationId, getOperationIdCommand.nodeTag);
    }
}
class ExportCommand extends RavenCommand {
    _options;
    _handleStreamResponse;
    _operationId;
    constructor(conventions, options, handleStreamResponse, operationId, nodeTag) {
        super();
        if (!conventions) {
            throwError("InvalidArgumentException", "Conventions cannot be null");
        }
        if (!options) {
            throwError("InvalidArgumentException", "Options cannot be null");
        }
        if (!handleStreamResponse) {
            throwError("InvalidArgumentException", "HandleStreamResponse cannot be null");
        }
        this._handleStreamResponse = handleStreamResponse;
        const { operateOnTypes, ...restOptions } = options;
        this._options = conventions.objectMapper.toObjectLiteral({
            operateOnTypes: operateOnTypes.join(","),
            ...restOptions
        });
        this._operationId = operationId;
        this._selectedNodeTag = nodeTag;
    }
    get isReadRequest() {
        return false;
    }
    createRequest(node) {
        const uri = node.url + "/databases/" + node.database + "/smuggler/export?operationId=" + this._operationId;
        const body = this._serializer.serialize(this._options);
        const headers = HeadersBuilder.create()
            .typeAppJson().build();
        return {
            method: "POST",
            uri,
            body,
            headers
        };
    }
    async processResponse(cache, response, bodyStream, url) {
        await this._handleStreamResponse(bodyStream);
        return "Automatic";
    }
}
class ImportCommand extends RavenCommand {
    _options;
    _file;
    _operationId;
    get isReadRequest() {
        return false;
    }
    constructor(conventions, options, file, operationId, nodeTag) {
        super();
        this._responseType = "Empty";
        if (!file) {
            throwError("InvalidArgumentException", "File cannot be null");
        }
        if (!conventions) {
            throwError("InvalidArgumentException", "Conventions cannot be null");
        }
        if (!options) {
            throwError("InvalidArgumentException", "Options cannot be null");
        }
        this._file = file;
        const { operateOnTypes, ...restOptions } = options;
        this._options = conventions.objectMapper.toObjectLiteral({
            operateOnTypes: operateOnTypes.join(","),
            ...restOptions
        });
        this._operationId = operationId;
        this._selectedNodeTag = nodeTag;
    }
    async send(agent, requestOptions) {
        const { body } = requestOptions;
        const { readFileSync } = await import("node:fs");
        if (body instanceof FormData) {
            const buffer = readFileSync(this._file);
            body.append("name", new Blob([buffer], { type: "text/plain" }));
        }
        return super.send(agent, requestOptions);
    }
    createRequest(node) {
        const uri = node.url + "/databases/" + node.database + "/smuggler/import?operationId=" + this._operationId;
        const multipart = new FormData();
        multipart.append("importOptions", this._serializer.serialize(this._options));
        // we append file in send method
        return {
            method: "POST",
            uri,
            body: multipart,
        };
    }
}
//# sourceMappingURL=DatabaseSmuggler.js.map