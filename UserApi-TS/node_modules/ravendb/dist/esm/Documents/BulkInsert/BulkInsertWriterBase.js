import { Buffer } from "node:buffer";
import { pipeline, Readable } from "node:stream";
import { promisify } from "node:util";
import { TypeUtil } from "../../Utility/TypeUtil.js";
export class BulkInsertWriterBase {
    _maxSizeInBuffer = 1024 * 1024;
    _asyncWrite = Promise.resolve();
    _asyncWriteDone = true;
    _currentWriter;
    _backgroundWriter;
    _isInitialWrite = true;
    lastFlushToStream;
    requestBodyStream;
    requestBodyStreamFinished = false;
    compressedStream;
    constructor() {
        this.requestBodyStream = new RequestBodyStream();
        this._currentWriter = new BulkInsertStream();
        this._backgroundWriter = new BulkInsertStream();
        this._updateFlushTime();
    }
    async dispose() {
        if (this.requestBodyStreamFinished) {
            return;
        }
        try {
            if (this.requestBodyStream) {
                this._currentWriter.push("]");
                await this._asyncWrite;
                await this.writeToStream(this._currentWriter.toBuffer());
                await this.requestBodyStream.flush();
            }
        }
        finally {
            this.requestBodyStreamFinished = true;
        }
    }
    initialize() {
        this.onCurrentWriteStreamSet(this._currentWriter);
    }
    isFlushNeeded() {
        return this._currentWriter.length > this._maxSizeInBuffer || this._asyncWriteDone;
    }
    async flushIfNeeded(force = false) {
        if (this.isFlushNeeded()) {
            await this._asyncWrite;
            const tmp = this._currentWriter;
            this._currentWriter = this._backgroundWriter;
            this._backgroundWriter = tmp;
            this._currentWriter = new BulkInsertStream();
            const buffer = this._backgroundWriter.toBuffer();
            force = true; // original version: force || this.isHeartbeatIntervalExceeded() || ; in node.js we need to force flush to use backpressure in steams
            this._asyncWriteDone = false;
            this._asyncWrite = this.writeToStream(buffer, force);
        }
    }
    _updateFlushTime() {
        this.lastFlushToStream = new Date();
    }
    onCurrentWriteStreamSet(currentWriteStream) {
        // empty by design
    }
    async writeToStream(buffer, forceDstFlush = false) {
        try {
            this.requestBodyStream.write(buffer);
            if (forceDstFlush) {
                this._updateFlushTime();
                await this.requestBodyStream.flush();
            }
            if (this.compressedStream) {
                const flush = promisify(this.compressedStream.flush);
                await flush.call(this.compressedStream);
            }
        }
        finally {
            this._asyncWriteDone = true;
        }
    }
    async ensureStream(compression) {
        if (compression === "Gzip") {
            const { createGzip } = await import("node:zlib");
            this.compressedStream = createGzip();
            pipeline(this.requestBodyStream, this.compressedStream, TypeUtil.NOOP);
        }
        this._currentWriter.push("[");
    }
}
export class BulkInsertStream {
    _items = [];
    totalLength = 0;
    push(data) {
        this._items.push(data);
        this.totalLength += Buffer.isBuffer(data) ? data.length : Buffer.byteLength(data);
    }
    toBuffer() {
        const result = Buffer.allocUnsafe(this.totalLength);
        let idx = 0;
        for (const inputElement of this._items) {
            if (Buffer.isBuffer(inputElement)) {
                inputElement.copy(result, idx);
                idx += inputElement.length;
            }
            else {
                result.write(inputElement, idx);
                idx += Buffer.byteLength(inputElement);
            }
        }
        return result;
    }
    get length() {
        return this.totalLength;
    }
}
export class RequestBodyStream extends Readable {
    constructor() {
        super({
            highWaterMark: 1024 * 1024
        });
    }
    _pending;
    _resume;
    _read(size) {
        this._resume?.();
    }
    write(data) {
        const canConsumeMore = this.push(data);
        if (!canConsumeMore) {
            this._pending = new Promise(resolve => {
                this._resume = () => {
                    this._resume = null;
                    resolve();
                };
            });
        }
    }
    async flush() {
        await this._pending;
    }
}
//# sourceMappingURL=BulkInsertWriterBase.js.map