import { ServerNode } from "./ServerNode.js";
import { RavenCommand } from "./RavenCommand.js";
import { Topology } from "./Topology.js";
import { NodeSelector } from "./NodeSelector.js";
import { IDisposable } from "../Types/Contracts.js";
import { IRequestAuthOptions, IAuthOptions } from "../Auth/AuthOptions.js";
import { ICertificate } from "../Auth/Certificate.js";
import { HttpCache } from "./HttpCache.js";
import { AggressiveCacheOptions } from "./AggressiveCacheOptions.js";
import CurrentIndexAndNode from "./CurrentIndexAndNode.js";
import { HttpRequestParameters, HttpRequestParametersWithoutUri } from "../Primitives/Http.js";
import { DocumentConventions } from "../Documents/Conventions/DocumentConventions.js";
import { SessionInfo } from "../Documents/Session/IDocumentSession.js";
import { PromiseStatusTracker } from "../Utility/PromiseUtil.js";
import { BeforeRequestEventArgs, FailedRequestEventArgs, SucceedRequestEventArgs, TopologyUpdatedEventArgs } from "../Documents/Session/SessionEvents.js";
import { UpdateTopologyParameters } from "./UpdateTopologyParameters.js";
import { Dispatcher } from "undici-types";
export interface ExecuteOptions<TResult> {
    chosenNode: ServerNode;
    nodeIndex: number;
    shouldRetry: boolean;
    abortRef?: (controller: AbortController) => void;
}
export interface ITopologyUpdateEvent {
    topologyJson: object;
    serverNodeUrl: string;
    requestedDatabase?: string;
    forceUpdate?: boolean;
    wasUpdated?: boolean;
}
export interface IRequestExecutorOptions {
    authOptions?: IRequestAuthOptions;
    documentConventions?: DocumentConventions;
}
export declare class NodeStatus implements IDisposable {
    private _nodeStatusCallback;
    private _timerPeriodInMs;
    readonly node: ServerNode;
    readonly requestExecutor: RequestExecutor;
    private _timer;
    constructor(node: ServerNode, requestExecutor: RequestExecutor, nodeStatusCallback: (nodeStatus: NodeStatus) => Promise<void>);
    private _nextTimerPeriod;
    startTimer(): void;
    updateTimer(): void;
    dispose(): void;
}
export declare class RequestExecutor implements IDisposable {
    private _emitter;
    private static GLOBAL_APPLICATION_IDENTIFIER;
    private static readonly INITIAL_TOPOLOGY_ETAG;
    private _log;
    static readonly CLIENT_VERSION = "7.1.0";
    private _updateDatabaseTopologySemaphore;
    private _updateClientConfigurationSemaphore;
    private static _backwardCompatibilityFailureCheckOperation;
    private static readonly _failureCheckOperation;
    private static readonly _useOldFailureCheckOperation;
    private _failedNodesTimers;
    protected _databaseName: string;
    protected _certificate: ICertificate;
    private _lastReturnedResponse;
    private readonly _cache;
    private _topologyTakenFromNode;
    aggressiveCaching: AggressiveCacheOptions;
    private _updateTopologyTimer;
    protected _nodeSelector: NodeSelector;
    private _defaultTimeout;
    numberOfServerRequests: number;
    protected _disposed: boolean;
    protected _firstTopologyUpdatePromiseInternal: any;
    private _httpAgent;
    private static KEEP_ALIVE_HTTP_AGENT;
    private static readonly HTTPS_AGENT_CACHE;
    protected get firstTopologyUpdatePromise(): Promise<void>;
    protected set firstTopologyUpdatePromise(value: Promise<void>);
    protected _firstTopologyUpdateStatus: PromiseStatusTracker<void>;
    protected _lastKnownUrls: string[];
    protected _clientConfigurationEtag: string;
    protected _topologyEtag: number;
    private readonly _conventions;
    private readonly _authOptions;
    protected _disableTopologyUpdates: boolean;
    protected _disableClientConfigurationUpdates: boolean;
    protected _topologyHeaderName: string;
    protected _lastServerVersion: string;
    protected _customHttpRequestOptions: HttpRequestParametersWithoutUri;
    protected _defaultRequestOptions: HttpRequestParametersWithoutUri;
    static requestPostProcessor: (req: HttpRequestParameters) => void;
    get customHttpRequestOptions(): HttpRequestParametersWithoutUri;
    set customHttpRequestOptions(value: HttpRequestParametersWithoutUri);
    getAuthOptions(): IAuthOptions;
    getTopologyEtag(): number;
    get lastServerVersion(): string;
    get defaultTimeout(): number;
    set defaultTimeout(timeout: number);
    private _secondBroadcastAttemptTimeout;
    get secondBroadcastAttemptTimeout(): number;
    set secondBroadcastAttemptTimeout(timeout: number);
    private _firstBroadcastAttemptTimeout;
    get firstBroadcastAttemptTimeout(): number;
    set firstBroadcastAttemptTimeout(timeout: number);
    on(event: "topologyUpdated", handler: (value: TopologyUpdatedEventArgs) => void): this;
    on(event: "failedRequest", handler: (value: FailedRequestEventArgs) => void): this;
    on(event: "beforeRequest", handler: (value: BeforeRequestEventArgs) => void): this;
    on(event: "succeedRequest", handler: (value: SucceedRequestEventArgs) => void): this;
    off(event: "topologyUpdated", handler: (value: TopologyUpdatedEventArgs) => void): this;
    off(event: "failedRequest", handler: (value: FailedRequestEventArgs) => void): this;
    off(event: "beforeRequest", handler: (value: BeforeRequestEventArgs) => void): this;
    off(event: "succeedRequest", handler: (value: SucceedRequestEventArgs) => void): this;
    private _onFailedRequestInvoke;
    get conventions(): DocumentConventions;
    getClientConfigurationEtag(): string;
    get cache(): HttpCache;
    get disposed(): boolean;
    getUrl(): string;
    getTopology(): Topology;
    getHttpAgent(): Promise<Dispatcher>;
    private _createHttpAgent;
    private compressionHeaders;
    private static createAgent;
    getTopologyNodes(): ServerNode[];
    protected constructor(database: string, authOptions: IRequestAuthOptions, conventions: DocumentConventions);
    static create(initialUrls: string[], database: string): RequestExecutor;
    static create(initialUrls: string[], database: string, opts?: IRequestExecutorOptions): RequestExecutor;
    private static getGlobalApplicationIdentifier;
    static createForSingleNodeWithConfigurationUpdates(url: string, database: string, opts: IRequestExecutorOptions): RequestExecutor;
    static createForSingleNodeWithoutConfigurationUpdates(url: string, database: string, opts: IRequestExecutorOptions): RequestExecutor;
    protected _updateClientConfiguration(serverNode: ServerNode): Promise<void>;
    private _updateClientConfigurationInternal;
    updateTopology(parameters: UpdateTopologyParameters): Promise<boolean>;
    protected _updateNodeSelector(topology: Topology, forceUpdate: boolean): void;
    protected _disposeAllFailedNodesTimers(): void;
    execute<TResult>(command: RavenCommand<TResult>): Promise<void>;
    execute<TResult>(command: RavenCommand<TResult>, sessionInfo?: SessionInfo): Promise<void>;
    execute<TResult>(command: RavenCommand<TResult>, sessionInfo?: SessionInfo, options?: ExecuteOptions<TResult>): Promise<void>;
    chooseNodeForRequest<TResult>(cmd: RavenCommand<TResult>, sessionInfo: SessionInfo): CurrentIndexAndNode;
    private _unlikelyExecute;
    private _waitForTopologyUpdate;
    private _updateTopologyCallback;
    protected _singleTopologyUpdateAsync(initialUrls: string[], applicationIdentifier: string): Promise<void>;
    protected _firstTopologyUpdate(inputUrls: string[], applicationIdentifier?: string): Promise<void>;
    protected _throwExceptions(details: string): void;
    static validateUrls(initialUrls: string[], authOptions: IAuthOptions): any[];
    private _initializeUpdateTopologyTimer;
    private _executeOnSpecificNode;
    private _refreshIfNeeded;
    private _sendRequestToServer;
    private _send;
    private _setRequestHeaders;
    private _tryGetFromCache;
    private static _tryGetServerVersion;
    private _throwFailedToContactAllNodes;
    inSpeedTestPhase(): boolean;
    private _shouldExecuteOnAll;
    private _executeOnAllToFigureOutTheFastest;
    private _getFromCache;
    private _nodeSelectorHasMultipleNodes;
    private _createRequest;
    private static appendToQuery;
    private _handleUnsuccessfulResponse;
    private _handleServerDown;
    private _shouldBroadcast;
    private _broadcast;
    private _waitForBroadcastResult;
    private _sendToAllNodes;
    handleServerNotResponsive(url: string, chosenNode: ServerNode, nodeIndex: number, e: Error): Promise<ServerNode>;
    private _spawnHealthChecks;
    private _checkNodeStatusCallback;
    protected _performHealthCheck(serverNode: ServerNode, nodeIndex: number): Promise<void>;
    private _executeOldHealthCheck;
    private static _readExceptionFromServer;
    private _setDefaultRequestOptions;
    dispose(): void;
    getRequestedNode(nodeTag: string, throwIfContainsFailures?: boolean): Promise<CurrentIndexAndNode>;
    getPreferredNode(): Promise<CurrentIndexAndNode>;
    getNodeBySessionId(sessionId: number): Promise<CurrentIndexAndNode>;
    getFastestNode(): Promise<CurrentIndexAndNode>;
    private _ensureNodeSelector;
    protected _onTopologyUpdatedInvoke(newTopology: Topology, reason: string): void;
}
//# sourceMappingURL=RequestExecutor.d.ts.map