import { DocumentConventions } from "../Documents/Conventions/DocumentConventions.js";
import { MetadataObject } from "../Documents/Session/MetadataObject.js";
import { CompareExchangeResultItem } from "../Documents/Operations/CompareExchange/CompareExchangeValueResultParser.js";
import { ServerCasing, ServerResponse } from "../Types/index.js";
import { TimeSeriesRangeResult } from "../Documents/Operations/TimeSeries/TimeSeriesRangeResult.js";
import { CounterDetail } from "../Documents/Operations/Counters/CounterDetail.js";
import { AttachmentDetails } from "../Documents/Attachments/index.js";
export declare class ObjectUtil {
    static camelCase: (input: string, locale?: string) => string;
    static camel: (input: string, locale?: string) => string;
    static pascalCase: (input: string, locale?: string) => string;
    static pascal: (input: string, locale?: string) => string;
    /**
     * @deprecated Use deepJsonClone or deepLiteralClone for better performance
     * @param o Object to clone
     */
    static clone(o: any): any;
    static deepJsonClone(o: any): any;
    static deepLiteralClone(item: any): any;
    static mapToLiteral<TValue>(input: Map<string, TValue>): {
        [key: string]: TValue;
    };
    static mapToLiteral<TValue, TResult>(input: Map<string, TValue>, valueTransformFunc: (value: string, key: TValue) => TResult): {
        [key: string]: TResult;
    };
    static transformObjectKeys(obj: object, opts?: ObjectChangeCaseOptions): object;
    static transformDocumentKeys(obj: any, conventions: DocumentConventions): any;
    static transformMetadataKeys(metadata: MetadataObject, conventions: DocumentConventions): MetadataObject;
    static mapAttachmentDetailsToLocalObject(json: any): AttachmentDetails;
    static mapIncludesToLocalObject(json: any, conventions: DocumentConventions): Record<string, any>;
    static mapCompareExchangeToLocalObject(json: Record<string, any>): Record<string, CompareExchangeResultItem>;
    static mapTimeSeriesIncludesToLocalObject(json: ServerCasing<ServerResponse<TimeSeriesRangeResult>>): Record<string, Record<string, {
        from: string;
        to: string;
        entries: {
            timestamp: string;
            tag: string;
            values: number[];
            isRollup: boolean;
            nodeValues: {
                [x: string]: number[];
            };
            value: number;
            asTypedEntry: {};
        }[];
        totalResults: number;
        includes: any;
    }[]>>;
    static mapCounterIncludesToLocalObject(json: object): Record<string, CounterDetail[]>;
    static isEmpty(object: Record<string, unknown>): boolean;
}
export type FieldNameConversion = (fieldName: string) => string;
export interface ObjectChangeCaseOptionsBase {
    recursive?: boolean;
    arrayRecursive?: boolean;
    ignoreKeys?: (string | RegExp)[];
    ignorePaths?: (string | RegExp)[];
    paths?: {
        transform: FieldNameConversion;
        path?: RegExp;
    }[];
}
export interface ObjectChangeCaseOptions extends ObjectChangeCaseOptionsBase {
    defaultTransform: FieldNameConversion;
}
//# sourceMappingURL=ObjectUtil.d.ts.map