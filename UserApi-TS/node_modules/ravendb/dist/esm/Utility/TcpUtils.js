import { Certificate } from "../Auth/Certificate.js";
import { getError, throwError } from "../Exceptions/index.js";
export class TcpUtils {
    static async connect(urlString, serverCertificate, clientCertificate) {
        const url = new URL(urlString);
        const host = url.hostname;
        const port = Number.parseInt(url.port, 10);
        if (serverCertificate && clientCertificate) {
            const { connect } = await import("node:tls");
            return new Promise((resolve, reject) => {
                const agentOptions = Certificate.createFromOptions(clientCertificate).toSocketOptions();
                agentOptions.checkServerIdentity = (host, peerCertificate) => {
                    const remoteCert = peerCertificate.raw;
                    const expectedCert = Buffer.from(serverCertificate, "base64");
                    let sameCert = true;
                    if (remoteCert.length !== expectedCert.length) {
                        sameCert = false;
                    }
                    for (let i = 0; i < remoteCert.length; i++) {
                        if (remoteCert[i] !== expectedCert[i]) {
                            sameCert = false;
                            break;
                        }
                    }
                    if (!sameCert) {
                        return getError("AuthenticationException", "Invalid server certificate.");
                    }
                };
                const socket = connect(port, host, agentOptions, () => {
                    socket.removeListener("error", reject);
                    resolve(socket);
                });
                socket.once("error", reject);
                socket.setNoDelay(true);
            });
        }
        else {
            const { Socket } = await import("node:net");
            return new Promise((resolve, reject) => {
                const socket = new Socket();
                socket.setNoDelay(true);
                socket.connect(port, host, () => {
                    socket.removeListener("error", reject);
                    resolve(socket);
                });
                socket.once("error", reject);
            });
        }
    }
    static async connectSecuredTcpSocket(info, serverCertificate, clientCertificate, operationType, negotiationCallback) {
        if (info.urls) {
            for (const url of info.urls) {
                try {
                    const socket = await this.connect(url, serverCertificate, clientCertificate);
                    const supportedFeatures = await this._invokeNegotiation(info, operationType, negotiationCallback, url, socket);
                    return new ConnectSecuredTcpSocketResult(url, socket, supportedFeatures);
                }
                catch {
                    // ignored
                }
            }
        }
        const socket = await this.connect(info.url, serverCertificate, clientCertificate);
        const supportedFeatures = await this._invokeNegotiation(info, operationType, negotiationCallback, info.url, socket);
        return new ConnectSecuredTcpSocketResult(info.url, socket, supportedFeatures);
    }
    static _invokeNegotiation(info, operationType, negotiationCallback, url, socket) {
        switch (operationType) {
            case "Subscription": {
                return negotiationCallback(url, info, socket);
            }
            default: {
                throwError("NotSupportedException", "Operation type '" + operationType + "' not supported");
            }
        }
    }
}
export class ConnectSecuredTcpSocketResult {
    url;
    socket;
    supportedFeatures;
    constructor(url, socket, supportedFeatures) {
        this.url = url;
        this.socket = socket;
        this.supportedFeatures = supportedFeatures;
    }
}
//# sourceMappingURL=TcpUtils.js.map