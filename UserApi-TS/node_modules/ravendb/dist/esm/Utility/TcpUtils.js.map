{"version":3,"file":"TcpUtils.js","sourceRoot":"","sources":["../../../src/Utility/TcpUtils.ts"],"names":[],"mappings":"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","sourcesContent":["\r\nimport { Socket } from \"node:net\";\r\nimport { IAuthOptions } from \"../Auth/AuthOptions.js\";\r\nimport { Certificate } from \"../Auth/Certificate.js\";\r\nimport { PeerCertificate } from \"node:tls\";\r\nimport { getError, throwError } from \"../Exceptions/index.js\";\r\nimport { TcpConnectionInfo } from \"../ServerWide/Commands/GetTcpInfoCommand.js\";\r\nimport { OperationTypes, SupportedFeatures } from \"../ServerWide/Tcp/TcpConnectionHeaderMessage.js\";\r\n\r\nexport class TcpUtils {\r\n    public static async connect(\r\n        urlString: string, \r\n        serverCertificate: string,\r\n        clientCertificate: IAuthOptions): Promise<Socket> {\r\n        const url = new URL(urlString);\r\n        const host = url.hostname;\r\n        const port = Number.parseInt(url.port, 10);\r\n\r\n        if (serverCertificate && clientCertificate) {\r\n            const { connect } = await import(\"node:tls\");\r\n\r\n            return new Promise<Socket>((resolve, reject) => {\r\n                const agentOptions = Certificate.createFromOptions(clientCertificate).toSocketOptions();\r\n                agentOptions.checkServerIdentity = (host: string, peerCertificate: PeerCertificate) => {\r\n                    const remoteCert = peerCertificate.raw;\r\n                    const expectedCert = Buffer.from(serverCertificate, \"base64\");\r\n                    let sameCert = true;\r\n                    if (remoteCert.length !== expectedCert.length) {\r\n                        sameCert = false;\r\n                    }\r\n                    \r\n                    for (let i = 0; i < remoteCert.length; i++) {\r\n                        if (remoteCert[i] !== expectedCert[i]) {\r\n                            sameCert = false;\r\n                            break;\r\n                        }\r\n                    }\r\n\r\n                    if (!sameCert) {\r\n                        return getError(\"AuthenticationException\", \"Invalid server certificate.\");\r\n                    }\r\n                };\r\n                const socket = connect(port, host, agentOptions, () => {\r\n                    socket.removeListener(\"error\", reject);\r\n                    resolve(socket);\r\n                });\r\n\r\n                socket.once(\"error\", reject);\r\n                socket.setNoDelay(true);\r\n            });\r\n\r\n        } else {\r\n            const { Socket } = await import(\"node:net\");\r\n\r\n            return new Promise<Socket>((resolve, reject) => {\r\n                const socket = new Socket();\r\n                socket.setNoDelay(true);\r\n\r\n                socket.connect(port, host, () => {\r\n                    socket.removeListener(\"error\", reject);\r\n                    resolve(socket);\r\n                });\r\n\r\n                socket.once(\"error\", reject);\r\n            });\r\n        }\r\n    }\r\n\r\n    public static async connectSecuredTcpSocket(info: TcpConnectionInfo, serverCertificate: string,\r\n                                            clientCertificate: IAuthOptions, operationType: OperationTypes, negotiationCallback: NegotiationCallback): Promise<ConnectSecuredTcpSocketResult> {\r\n        if (info.urls) {\r\n            for (const url of info.urls) {\r\n                try {\r\n                    const socket = await this.connect(url, serverCertificate, clientCertificate);\r\n                    const supportedFeatures = await this._invokeNegotiation(info, operationType, negotiationCallback, url, socket);\r\n                    return new ConnectSecuredTcpSocketResult(url, socket, supportedFeatures);\r\n                } catch {\r\n                    // ignored\r\n                }\r\n            }\r\n        }\r\n\r\n        const socket = await this.connect(info.url, serverCertificate, clientCertificate);\r\n        const supportedFeatures = await this._invokeNegotiation(info, operationType, negotiationCallback, info.url, socket);\r\n        return new ConnectSecuredTcpSocketResult(info.url, socket, supportedFeatures);\r\n    }\r\n\r\n    private static _invokeNegotiation(info: TcpConnectionInfo, operationType: OperationTypes, negotiationCallback: NegotiationCallback, url: string, socket: Socket) {\r\n        switch (operationType) {\r\n            case \"Subscription\": {\r\n                return negotiationCallback(url, info, socket);\r\n            }\r\n            default: {\r\n                throwError(\"NotSupportedException\", \"Operation type '\" + operationType + \"' not supported\");\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ntype NegotiationCallback = (url: string, info: TcpConnectionInfo, socket: Socket) => Promise<SupportedFeatures>;\r\n\r\nexport class ConnectSecuredTcpSocketResult {\r\n    url: string;\r\n    socket: Socket;\r\n    supportedFeatures: SupportedFeatures;\r\n\r\n\r\n    constructor(url: string, socket: Socket, supportedFeatures: SupportedFeatures) {\r\n        this.url = url;\r\n        this.socket = socket;\r\n        this.supportedFeatures = supportedFeatures;\r\n    }\r\n}\r\n"]}