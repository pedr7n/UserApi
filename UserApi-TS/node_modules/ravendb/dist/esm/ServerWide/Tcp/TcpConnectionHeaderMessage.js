import { throwError } from "../../Exceptions/index.js";
import { TypeUtil } from "../../Utility/TypeUtil.js";
export const NUMBER_OR_RETRIES_FOR_SENDING_TCP_HEADER = 2;
export const PING_BASE_LINE = -1;
export const NONE_BASE_LINE = -1;
export const DROP_BASE_LINE = -2;
export const HEARTBEATS_BASE_LINE = 20;
export const HEARTBEATS_41200 = 41_200;
export const HEARTBEATS_42000 = 42_000;
export const HEARTBEATS_WITH_TCP_COMPRESSION = 54_000;
export const SUBSCRIPTION_BASE_LINE = 40;
export const SUBSCRIPTION_INCLUDES = 41_400;
export const SUBSCRIPTION_COUNTER_INCLUDES = 50_000;
export const SUBSCRIPTION_TIME_SERIES_INCLUDES = 51_000;
export const TCP_CONNECTIONS_WITH_COMPRESSION = 53_000;
export const TEST_CONNECTION_BASE_LINE = 50;
export const HEARTBEATS_TCP_VERSION = HEARTBEATS_WITH_TCP_COMPRESSION;
export const SUBSCRIPTION_TCP_VERSION = TCP_CONNECTIONS_WITH_COMPRESSION;
export const TEST_CONNECTION_TCP_VERSION = TEST_CONNECTION_BASE_LINE;
export class PingFeatures {
    baseLine = true;
}
export class NoneFeatures {
    baseLine = true;
}
export class DropFeatures {
    baseLine = true;
}
export class SubscriptionFeatures {
    baseLine = true;
    includes = false;
    counterIncludes = false;
    timeSeriesIncludes = false;
}
export class HeartbeatsFeatures {
    baseLine = true;
    sendChangesOnly = false;
    includeServerInfo;
}
export class TestConnectionFeatures {
    baseLine = true;
}
export class SupportedFeatures {
    protocolVersion;
    constructor(versionOrSource) {
        if (TypeUtil.isNumber(versionOrSource)) {
            this.protocolVersion = versionOrSource;
            return;
        }
        const source = versionOrSource;
        this.protocolVersion = source.protocolVersion;
        this.ping = source.ping;
        this.none = source.none;
        this.drop = source.drop;
        this.subscription = source.subscription;
        this.heartbeats = source.heartbeats;
        this.testConnection = source.testConnection;
        this.dataCompression = source.dataCompression;
    }
    ping;
    none;
    drop;
    subscription;
    heartbeats;
    testConnection;
    dataCompression;
}
const operationsToSupportedProtocolVersions = new Map();
const supportedFeaturesByProtocol = new Map();
{
    operationsToSupportedProtocolVersions.set("Ping", [PING_BASE_LINE]);
    operationsToSupportedProtocolVersions.set("None", [NONE_BASE_LINE]);
    operationsToSupportedProtocolVersions.set("Drop", [DROP_BASE_LINE]);
    operationsToSupportedProtocolVersions.set("Subscription", [
        TCP_CONNECTIONS_WITH_COMPRESSION, SUBSCRIPTION_TIME_SERIES_INCLUDES, SUBSCRIPTION_COUNTER_INCLUDES,
        SUBSCRIPTION_INCLUDES, SUBSCRIPTION_BASE_LINE
    ]);
    operationsToSupportedProtocolVersions.set("Heartbeats", [
        HEARTBEATS_TCP_VERSION,
        HEARTBEATS_42000,
        HEARTBEATS_41200,
        HEARTBEATS_BASE_LINE
    ]);
    operationsToSupportedProtocolVersions.set("TestConnection", [TEST_CONNECTION_BASE_LINE]);
    const pingFeaturesMap = new Map();
    supportedFeaturesByProtocol.set("Ping", pingFeaturesMap);
    const pingFeatures = new SupportedFeatures(PING_BASE_LINE);
    pingFeatures.ping = new PingFeatures();
    pingFeaturesMap.set(PING_BASE_LINE, pingFeatures);
    const noneFeaturesMap = new Map();
    supportedFeaturesByProtocol.set("None", noneFeaturesMap);
    const noneFeatures = new SupportedFeatures(NONE_BASE_LINE);
    noneFeatures.none = new NoneFeatures();
    noneFeaturesMap.set(NONE_BASE_LINE, noneFeatures);
    const dropFeaturesMap = new Map();
    supportedFeaturesByProtocol.set("Drop", dropFeaturesMap);
    const dropFeatures = new SupportedFeatures(DROP_BASE_LINE);
    dropFeatures.drop = new DropFeatures();
    dropFeaturesMap.set(DROP_BASE_LINE, dropFeatures);
    const subscriptionFeaturesMap = new Map();
    supportedFeaturesByProtocol.set("Subscription", subscriptionFeaturesMap);
    const subscriptionFeatures = new SupportedFeatures(SUBSCRIPTION_BASE_LINE);
    subscriptionFeatures.subscription = new SubscriptionFeatures();
    subscriptionFeaturesMap.set(SUBSCRIPTION_BASE_LINE, subscriptionFeatures);
    const subscriptions41400Features = new SupportedFeatures(SUBSCRIPTION_INCLUDES);
    subscriptions41400Features.subscription = new SubscriptionFeatures();
    subscriptions41400Features.subscription.includes = true;
    subscriptionFeaturesMap.set(SUBSCRIPTION_INCLUDES, subscriptions41400Features);
    const subscriptions50000Features = new SupportedFeatures(SUBSCRIPTION_COUNTER_INCLUDES);
    subscriptions50000Features.subscription = new SubscriptionFeatures();
    subscriptions50000Features.subscription.includes = true;
    subscriptions50000Features.subscription.counterIncludes = true;
    subscriptionFeaturesMap.set(SUBSCRIPTION_COUNTER_INCLUDES, subscriptions50000Features);
    const subscriptions51000Features = new SupportedFeatures(SUBSCRIPTION_TIME_SERIES_INCLUDES);
    subscriptions51000Features.subscription = new SubscriptionFeatures();
    subscriptions51000Features.subscription.includes = true;
    subscriptions51000Features.subscription.counterIncludes = true;
    subscriptions51000Features.subscription.timeSeriesIncludes = true;
    subscriptionFeaturesMap.set(SUBSCRIPTION_TIME_SERIES_INCLUDES, subscriptions51000Features);
    const subscriptions53000Features = new SupportedFeatures(TCP_CONNECTIONS_WITH_COMPRESSION);
    subscriptions53000Features.dataCompression = true;
    subscriptions53000Features.subscription = new SubscriptionFeatures();
    subscriptions53000Features.subscription.includes = true;
    subscriptions53000Features.subscription.counterIncludes = true;
    subscriptions53000Features.subscription.timeSeriesIncludes = true;
    subscriptionFeaturesMap.set(TCP_CONNECTIONS_WITH_COMPRESSION, subscriptions53000Features);
    const heartbeatsFeaturesMap = new Map();
    supportedFeaturesByProtocol.set("Heartbeats", heartbeatsFeaturesMap);
    const heartbeatsFeatures = new SupportedFeatures(HEARTBEATS_BASE_LINE);
    heartbeatsFeatures.heartbeats = new HeartbeatsFeatures();
    heartbeatsFeaturesMap.set(HEARTBEATS_BASE_LINE, heartbeatsFeatures);
    const heartbeats41200Features = new SupportedFeatures(HEARTBEATS_41200);
    heartbeats41200Features.heartbeats = new HeartbeatsFeatures();
    heartbeats41200Features.heartbeats.sendChangesOnly = true;
    heartbeatsFeaturesMap.set(HEARTBEATS_41200, heartbeats41200Features);
    const heartbeats42000Features = new SupportedFeatures(HEARTBEATS_42000);
    heartbeats42000Features.heartbeats = new HeartbeatsFeatures();
    heartbeats42000Features.heartbeats.sendChangesOnly = true;
    heartbeats42000Features.heartbeats.includeServerInfo = true;
    heartbeatsFeaturesMap.set(HEARTBEATS_42000, heartbeats42000Features);
    const heartbeatsWithTcpCompressionFeatures = new SupportedFeatures(HEARTBEATS_WITH_TCP_COMPRESSION);
    heartbeatsWithTcpCompressionFeatures.heartbeats = new HeartbeatsFeatures();
    heartbeatsWithTcpCompressionFeatures.heartbeats.sendChangesOnly = true;
    heartbeatsWithTcpCompressionFeatures.heartbeats.includeServerInfo = true;
    heartbeatsWithTcpCompressionFeatures.dataCompression = true;
    heartbeatsFeaturesMap.set(HEARTBEATS_WITH_TCP_COMPRESSION, heartbeatsWithTcpCompressionFeatures);
    const testConnectionFeaturesMap = new Map();
    supportedFeaturesByProtocol.set("TestConnection", testConnectionFeaturesMap);
    const testConnectionFeatures = new SupportedFeatures(TEST_CONNECTION_BASE_LINE);
    testConnectionFeatures.testConnection = new TestConnectionFeatures();
    testConnectionFeaturesMap.set(TEST_CONNECTION_BASE_LINE, testConnectionFeatures);
}
export function operationVersionSupported(operationType, version, currentRef) {
    currentRef(-1);
    const supportedProtocols = operationsToSupportedProtocolVersions.get(operationType);
    if (!supportedProtocols) {
        throwError("InvalidOperationException", "This is a bug. Probably you forgot to add '"
            + operationType + "' operation to the operationsToSupportedProtocolVersions map");
    }
    for (const current of supportedProtocols) {
        currentRef(current);
        if (current === version) {
            return "Supported";
        }
        if (current < version) {
            return "NotSupported";
        }
    }
    return "OutOfRange";
}
export function getOperationTcpVersion(operationType, index) {
    // we don't check the if the index go out of range, since this is expected and means that we don't have
    switch (operationType) {
        case "Ping":
        case "None": {
            return -1;
        }
        case "Drop": {
            return -2;
        }
        case "Subscription":
        case "Replication":
        case "Cluster":
        case "Heartbeats":
        case "TestConnection": {
            return operationsToSupportedProtocolVersions.get(operationType)[index];
        }
        default: {
            throwError("InvalidArgumentException", "Invalid operation type: " + operationType);
        }
    }
}
export function getSupportedFeaturesFor(type, protocolVersion) {
    const features = supportedFeaturesByProtocol.get(type).get(protocolVersion);
    if (!features) {
        throwError("InvalidArgumentException", type + "in protocol " + protocolVersion + " was not found in the features set");
    }
    return features;
}
export class AuthorizationInfo {
    authorizeAs;
    authorizationFor;
}
//# sourceMappingURL=TcpConnectionHeaderMessage.js.map